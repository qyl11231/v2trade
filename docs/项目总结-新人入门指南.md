# V2-Trade 项目总结 - 新人入门指南

> **本文档目标**：为新人提供项目的完整概览，包括需求、架构、技术栈、数据库设计和业务思想。本文档独立完整，不依赖其他文档。

**文档版本**：v1.0  
**最后更新**：2026-01-06

---

## 📚 目录

1. [项目概述](#项目概述)
2. [业务需求](#业务需求)
3. [技术栈](#技术栈)
4. [数据库设计](#数据库设计)
5. [架构设计](#架构设计)
6. [核心模块说明](#核心模块说明)
7. [业务流程](#业务流程)
8. [业务思想与设计原则](#业务思想与设计原则)

---

## 一、项目概述

### 1.1 项目定位

**V2-Trade** 是一个**量化交易系统**，专注于加密货币（目前支持OKX交易所）的自动化交易。系统采用**事件驱动**架构，支持信号驱动、指标驱动的多种策略模式。

### 1.2 核心能力

- ✅ **实时行情接入**：通过WebSocket订阅OKX实时K线数据
- ✅ **行情数据存储**：使用QuestDB存储时序K线数据
- ✅ **技术指标计算**：基于ta4j引擎计算技术指标（RSI、MACD等）
- ✅ **信号管理**：接收和管理TradingView信号
- ✅ **策略引擎**：支持信号驱动、指标驱动的策略
- ✅ **多租户支持**：完整的用户权限和资源隔离

### 1.3 系统特点

- **事件驱动**：基于事件驱动的异步架构，提高系统响应能力
- **分层架构**：清晰的模块划分，业务与基础设施解耦
- **可扩展性**：支持多交易所、多指标引擎、多策略类型
- **数据完整性**：完整的数据校准和补全机制

---

## 二、业务需求

### 2.1 用户角色

系统支持**多租户**架构，每个用户独立管理：
- 自己的API密钥（OKX交易所）
- 自己的交易对配置
- 自己的信号配置
- 自己的策略配置

### 2.2 核心业务流程

#### 业务流程1：行情数据采集

1. **订阅配置**：管理员配置需要采集的交易对（`market_subscription_config`表）
2. **实时订阅**：系统通过WebSocket订阅OKX的实时K线数据
3. **数据存储**：K线数据实时写入QuestDB
4. **数据校准**：定时任务检测并补全缺失的K线数据

#### 业务流程2：技术指标计算

1. **指标定义**：系统内置10个技术指标（RSI、MACD、BOLL等）
2. **用户订阅**：用户选择交易对和周期，订阅需要的指标
3. **K线闭合触发**：当一根K线完成时，自动触发指标计算
4. **结果存储**：指标计算结果存储到MySQL，供策略模块使用

#### 业务流程3：信号处理

1. **信号配置**：用户配置TradingView信号名称和对应的交易对
2. **信号接收**：系统通过Webhook接收TradingView信号
3. **信号存储**：信号作为事实记录存储，不进行交易决策
4. **策略消费**：策略模块读取信号，决定是否执行交易

#### 业务流程4：策略执行（规划中）

1. **策略定义**：用户创建策略，指定策略类型（信号驱动/指标驱动）
2. **策略配置**：配置入场条件、出场条件、资金管理等参数
3. **信号订阅**：策略订阅需要的信号源
4. **决策执行**：策略根据信号和指标，生成交易意图
5. **风险控制**：风控模块校验交易意图
6. **订单执行**：通过OKX API执行订单

---

## 三、技术栈

### 3.1 后端技术栈

| 技术 | 版本 | 用途 |
|------|------|------|
| **Java** | 17 | 开发语言 |
| **Spring Boot** | 3.5.7 | 应用框架 |
| **MyBatis-Plus** | 3.5.9 | ORM框架（MySQL操作） |
| **MySQL** | 5.7+ | 关系型数据库（业务数据） |
| **QuestDB** | 最新版 | 时序数据库（K线数据） |
| **Redis** | 最新版 | 缓存 |
| **Log4j2** | - | 日志框架 |
| **Thymeleaf** | - | 模板引擎（前端页面） |
| **OkHttp** | 4.12.0 | WebSocket客户端 |
| **Ta4j** | 0.16 | 技术分析库 |
| **Spring Actuator** | - | 系统监控 |
| **Micrometer Prometheus** | - | Metrics导出 |

### 3.2 数据库

- **MySQL**：存储所有业务数据（用户、配置、信号、策略、指标计算结果）
- **QuestDB**：存储时序K线数据（高性能时序数据库）

### 3.3 架构模式

- **事件驱动架构**：使用Spring事件机制实现模块间解耦
- **分层架构**：
  - **Web层**：Controller提供REST API
  - **Service层**：业务逻辑处理
  - **Repository层**：数据访问抽象
  - **Infrastructure层**：基础设施（WebSocket、QuestDB适配器等）

---

## 四、数据库设计

### 4.1 数据库概览

系统使用**双数据库**架构：
- **MySQL**：业务数据（15+张表）
- **QuestDB**：时序数据（K线表）

### 4.2 MySQL表设计

#### 4.2.1 用户与权限表

**sys_user（系统用户表）**
```sql
- id: 用户ID
- username: 用户名（唯一）
- password: 密码（MD5加密）
- nickname: 昵称
- email: 邮箱
- enabled: 是否启用
- last_login_at: 最后登录时间
- created_at, updated_at: 时间戳
- deleted: 逻辑删除标记
```

**user_api_key（用户API密钥表）**
```sql
- id: 主键
- user_id: 所属用户ID
- exchange: 交易所（OKX）
- api_key: API密钥
- secret_key: 密钥
- passphrase: 口令
- api_key_name: 密钥名称
- status: 状态（启用/禁用）
- created_at, updated_at: 时间戳
```

#### 4.2.2 交易对管理表

**trading_pair（交易对主表）**
```sql
- id: 交易对ID
- symbol: 交易对符号（BTC-USDT）
- base_currency: 基础货币（BTC）
- quote_currency: 计价货币（USDT）
- market_type: 市场类型（SPOT/SWAP/FUTURES）
- enabled: 是否启用
- created_at, updated_at: 时间戳
唯一索引: (symbol, market_type)
```

**exchange_market_pair（交易所交易规则表）**
```sql
- id: 主键
- exchange_code: 交易所代码（OKX）
- trading_pair_id: 交易对ID
- symbol_on_exchange: 交易所交易对符号（BTC-USDT-SWAP）
- status: 交易状态（TRADING/SUSPENDED）
- price_precision: 价格精度
- quantity_precision: 数量精度
- min_order_qty: 最小下单量
- min_order_amount: 最小下单金额
- max_order_qty: 最大下单量
- max_leverage: 最大杠杆（合约）
- raw_payload: 原始JSON数据
- created_at, updated_at: 时间戳
唯一索引: (exchange_code, trading_pair_id)
```

**market_subscription_config（行情订阅配置表）**
```sql
- id: 主键
- trading_pair_id: 交易对ID
- enabled: 是否启用行情采集
- cache_duration_minutes: Redis缓存时长（分钟）
- remark: 备注
- created_at, updated_at: 时间戳
唯一索引: (trading_pair_id)
```

#### 4.2.3 信号模块表

**signal_config（信号配置表）**
```sql
- id: 信号配置ID
- user_id: 用户ID
- api_key_id: API Key ID
- signal_name: 信号名称（TradingView策略名）
- symbol: 交易对符号（冗余，用于匹配）
- trading_pair_id: 交易对ID（系统内部引用）
- enabled: 是否启用
- created_at, updated_at: 时间戳
唯一索引: (signal_name, api_key_id)
```

**signal（信号事实表）**
```sql
- id: 信号ID
- user_id: 用户ID
- api_key_id: API Key ID
- signal_config_id: 信号配置ID
- signal_source: 信号来源（tv/internal/manual）
- signal_name: 信号名称
- symbol: 交易对
- signal_event_type: 信号事件类型（BREAKOUT/CROSS/OVERSOLD/CUSTOM）
- signal_direction_hint: 信号方向提示（LONG/SHORT/NEUTRAL）
- price: 信号参考价格
- quantity: 信号建议数量
- raw_payload: 原始信号内容（JSON）
- received_at: 信号接收时间
- created_at: 入库时间
索引: (user_id, api_key_id), (signal_config_id)
```

#### 4.2.4 指标模块表

**indicator_definition（指标定义表）**
```sql
- id: 主键
- user_id: 所属用户ID（0=系统内置；>0=用户自定义）
- indicator_code: 指标编码（RSI、MACD等）
- indicator_name: 指标名称
- indicator_version: 指标版本（v1）
- category: 分类（TREND/MOMENTUM/VOLATILITY/VOLUME/GENERAL）
- engine: 计算引擎（ta4j/custom）
- param_schema: 参数Schema（JSON）
- return_schema: 返回Schema（JSON）
- min_required_bars: 最小所需bar数量
- supported_timeframes: 支持周期列表（JSON）
- enabled: 是否启用
- created_at, updated_at: 时间戳
唯一索引: (user_id, indicator_code, indicator_version)
```

**indicator_subscription（指标订阅表）**
```sql
- id: 主键
- user_id: 所属用户ID
- trading_pair_id: 交易对ID
- symbol: 交易对符号（冗余快照）
- market_type: 市场类型（冗余快照）
- timeframe: 周期（1m/5m/15m/30m/1h/4h等）
- indicator_code: 指标编码
- indicator_version: 指标版本
- params: 指标参数快照（JSON，如{"period":14}）
- enabled: 是否启用
- created_at, updated_at: 时间戳
唯一索引: (user_id, trading_pair_id, timeframe, indicator_code, indicator_version)
```

**indicator_value（指标值表）**
```sql
- id: 主键
- user_id: 所属用户ID
- trading_pair_id: 交易对ID
- symbol: 交易对符号（冗余快照）
- market_type: 市场类型（冗余快照）
- timeframe: K线周期
- bar_time: K线收盘时间（UTC）
- indicator_code: 指标编码
- indicator_version: 指标版本
- value: 单值指标结果
- extra_values: 多值指标结果（JSON，如BOLL上中下轨）
- data_quality: 数据质量（OK/PARTIAL/INVALID）
- calc_engine: 计算引擎（ta4j/custom）
- calc_fingerprint: 计算指纹（SHA-256，用于冲突检测）
- calc_cost_ms: 计算耗时（毫秒）
- source: 数据源（OKX）
- created_at, updated_at: 时间戳
唯一索引: (user_id, trading_pair_id, timeframe, bar_time, indicator_code, indicator_version)
```

**indicator_calc_log（指标计算日志表）**
```sql
- id: 主键
- user_id: 所属用户ID
- trading_pair_id: 交易对ID
- timeframe: K线周期
- bar_time: K线收盘时间
- indicator_code: 指标编码
- calc_status: 计算状态（SUCCESS/FAILED/CONFLICT）
- calc_fingerprint: 计算指纹
- cost_ms: 计算耗时
- error_msg: 错误信息
- created_at: 创建时间
```

#### 4.2.5 策略模块表

**strategy_definition（策略定义表）**
```sql
- id: 策略ID
- user_id: 所属用户ID
- strategy_name: 策略名称（唯一）
- strategy_type: 策略类型（SIGNAL_DRIVEN/INDICATOR_DRIVEN/HYBRID）
- decision_mode: 决策模式（FOLLOW_SIGNAL/INTENT_DRIVEN）
- enabled: 是否启用
- created_at, updated_at: 时间戳
```

**strategy_param（策略参数表）**
```sql
- id: 参数ID
- user_id: 所属用户ID
- strategy_id: 策略ID
- initial_capital: 策略初始虚拟资金
- base_order_ratio: 单次下单资金占比
- take_profit_ratio: 策略止盈比例
- stop_loss_ratio: 策略止损比例
- entry_condition: 入场条件（JSON结构化表达）
- exit_condition: 出场条件（JSON结构化表达）
- created_at, updated_at: 时间戳
唯一索引: (strategy_id)
```

**strategy_symbol（策略交易对表）**
```sql
- id: 主键
- user_id: 所属用户ID
- strategy_id: 策略ID
- trading_pair_id: 交易对ID
- enabled: 是否启用
- created_at, updated_at: 时间戳
唯一索引: (strategy_id, trading_pair_id)
```

**strategy_signal_subscription（策略信号订阅表）**
```sql
- id: 订阅ID
- user_id: 所属用户ID
- strategy_id: 策略ID
- signal_config_id: 信号配置ID
- consume_mode: 消费模式（LATEST_ONLY等）
- enabled: 是否启用
唯一索引: (strategy_id, signal_config_id)
```

**signal_intent（信号意图表）**
```sql
- id: 意图ID
- user_id: 所属用户ID
- strategy_id: 策略ID
- trading_pair_id: 交易对ID
- signal_id: 信号唯一ID
- intent_direction: 意图方向（BUY/SELL/FLAT/REVERSE）
- intent_status: 意图状态（ACTIVE/CONSUMED/EXPIRED/IGNORED）
- generated_at: 信号产生时间
- received_at: 系统接收时间
- expired_at: 失效时间
- remark: 备注
- created_at, updated_at: 时间戳
```

**strategy_logic_state（策略逻辑状态表）**
```sql
- id: 状态ID
- user_id: 所属用户ID
- strategy_id: 策略ID
- trading_pair_id: 交易对ID
- logic_position_side: 逻辑持仓方向（LONG/SHORT/FLAT）
- logic_position_qty: 逻辑持仓数量
- avg_entry_price: 逻辑平均开仓价
- state_phase: 策略阶段（IDLE/OPEN_PENDING/OPENED/PARTIAL_EXIT/EXIT_PENDING/CLOSED）
- last_signal_intent_id: 最近一次关联的signal_intent
- unrealized_pnl: 未实现盈亏
- realized_pnl: 已实现盈亏
- updated_at, created_at: 时间戳
唯一索引: (strategy_id, trading_pair_id)
```

**strategy_intent_record（策略决策流水表）**
```sql
- id: 决策记录ID
- user_id: 所属用户ID
- strategy_id: 策略ID
- trading_pair_id: 交易对ID
- signal_id: 触发决策的信号ID
- intent_action: 决策意图（OPEN/CLOSE/ADD/REDUCE/REVERSE/HOLD）
- calculated_qty: 策略计算出的下单数量
- decision_reason: 决策原因说明
- created_at: 决策时间
```

#### 4.2.6 行情校准表

**market_calibration_task_config（行情校准任务配置表）**
```sql
- id: 任务配置ID
- trading_pair_id: 交易对ID
- task_type: 任务类型（MISSING_DATA/DATA_VERIFY）
- enabled: 是否启用
- cron_expression: 定时表达式
- 其他配置字段...
- created_at, updated_at: 时间戳
```

**market_calibration_task_log（行情校准执行日志表）**
```sql
- id: 日志ID
- task_config_id: 任务配置ID
- execute_status: 执行状态（SUCCESS/FAILED）
- 执行结果详情...
- created_at: 执行时间
```

### 4.3 QuestDB表设计

**kline_1m（1分钟K线表）**
```sql
- symbol: SYMBOL类型（交易对）
- ts: TIMESTAMP类型（K线时间，分区键）
- open: DOUBLE（开盘价）
- high: DOUBLE（最高价）
- low: DOUBLE（最低价）
- close: DOUBLE（收盘价）
- volume: DOUBLE（成交量）
- exchange_ts: LONG（交易所时间戳）
分区方式: PARTITION BY DAY
```

**kline_5m, kline_15m, kline_30m, kline_1h, kline_4h（多周期K线表）**
```sql
结构与kline_1m相同，用于存储聚合后的多周期K线数据
```

### 4.4 表关系图

```
sys_user (1) ──→ (N) user_api_key
    │
    ├──→ (N) signal_config
    ├──→ (N) signal
    ├──→ (N) indicator_subscription
    ├──→ (N) indicator_value
    └──→ (N) strategy_definition

trading_pair (1) ──→ (N) exchange_market_pair
    │
    ├──→ (N) market_subscription_config
    ├──→ (N) signal_config
    ├──→ (N) indicator_subscription
    ├──→ (N) indicator_value
    └──→ (N) strategy_symbol

signal_config (1) ──→ (N) signal
    │
    └──→ (N) strategy_signal_subscription

strategy_definition (1) ──→ (1) strategy_param
    │
    ├──→ (N) strategy_symbol
    ├──→ (N) strategy_signal_subscription
    ├──→ (N) signal_intent
    ├──→ (N) strategy_logic_state
    └──→ (N) strategy_intent_record
```

---

## 五、架构设计

### 5.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        前端层 (Thymeleaf)                      │
│                  静态页面 + REST API调用                        │
└──────────────────────┬────────────────────────────────────────┘
                       │
┌──────────────────────┴────────────────────────────────────────┐
│                      Web层 (Controller)                         │
│  - SignalController, StrategyController, IndicatorController  │
│  - MarketDataController, MarketCalibrationController          │
└──────────────────────┬────────────────────────────────────────┘
                       │
┌──────────────────────┴────────────────────────────────────────┐
│                    Service层 (业务逻辑)                          │
│  - SignalService, StrategyService, IndicatorService           │
│  - MarketQueryService, MarketCalibrationService               │
└──────────────────────┬────────────────────────────────────────┘
                       │
        ┌──────────────┼──────────────┐
        │              │              │
        ▼              ▼              ▼
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│  Repository  │ │  Repository  │ │  Repository  │
│   (MySQL)    │ │  (QuestDB)   │ │   (Redis)    │
└──────────────┘ └──────────────┘ └──────────────┘
```

### 5.2 模块划分

系统按**业务领域**划分为以下模块：

#### 5.2.1 行情模块（market）

**职责**：
- 实时行情订阅（WebSocket）
- K线数据存储（QuestDB）
- 历史K线查询
- 数据校准和补全

**核心组件**：
- `MarketDataCenter`：行情数据中心，接收并处理K线事件
- `ExchangeWebSocketManager`：WebSocket连接管理
- `QuestDbMarketStorageService`：QuestDB存储服务
- `MarketCalibrationScheduler`：定时校准调度器

#### 5.2.2 指标模块（indicator）

**职责**：
- 技术指标定义和注册
- 指标计算（基于K线闭合事件）
- 指标结果存储和查询

**核心组件**：
- `IndicatorCalculator`：指标计算器（监听K线闭合事件）
- `BarSeriesManager`：Bar系列管理器（内存中维护K线序列）
- `IndicatorEngineRouter`：引擎路由器（ta4j/custom）
- `IndicatorValueRepository`：指标值持久化

#### 5.2.3 信号模块（signal）

**职责**：
- 信号配置管理（白名单）
- 信号接收和存储（Webhook）
- 信号查询（供策略使用）

**核心组件**：
- `SignalConfigService`：信号配置服务
- `SignalService`：信号服务（接收、校验、存储）

#### 5.2.4 策略模块（strategy）

**职责**：
- 策略定义和配置
- 策略运行时管理
- 信号消费和决策生成

**核心组件**：
- `StrategyDefinitionService`：策略定义服务
- `StrategyRuntimeFactory`：策略运行时工厂
- `SignalViewBinder`：信号视图绑定器

#### 5.2.5 K线聚合模块（aggregation）

**职责**：
- 从1分钟K线聚合生成多周期K线（5m、15m、30m、1h、4h）
- 发布K线闭合事件（触发指标计算）

**核心组件**：
- `KlineAggregationEngine`：聚合引擎
- `BarClosedEventPublisher`：K线闭合事件发布器

### 5.3 事件驱动架构

系统采用**事件驱动**架构，核心事件包括：

#### 5.3.1 KlineEvent（K线事件）

**发布时机**：WebSocket接收到新的K线数据
**消费者**：MarketDataCenter（写入QuestDB）

#### 5.3.2 BarClosedEvent（K线闭合事件）

**发布时机**：K线聚合完成或K线周期结束时
**消费者**：
- `BarSeriesManager`：追加Bar到内存Series
- `IndicatorCalculator`：触发指标计算

### 5.4 数据流转

```
┌─────────────────────────────────────────────────────────────┐
│                      数据流转链路                              │
└─────────────────────────────────────────────────────────────┘

1. 行情订阅
   OKX WebSocket → KlineEvent → MarketDataCenter → QuestDB

2. K线聚合
   QuestDB (1m) → AggregationEngine → QuestDB (5m/15m/...) 
   → BarClosedEvent

3. 指标计算
   BarClosedEvent → IndicatorCalculator → 加载历史数据 
   → 计算指标 → 存储到MySQL

4. 信号处理
   TradingView Webhook → SignalService → MySQL (signal表)

5. 策略决策（规划中）
   Signal + Indicator → StrategyRuntime → TradeIntent → Risk → Trade
```

---

## 六、核心模块说明

### 6.1 行情模块（market）

#### 6.1.1 订阅层（subscription/collector）

**ExchangeWebSocketManager**
- 管理WebSocket连接生命周期
- 自动重连机制（指数退避）
- 心跳保持连接

**KlineChannel**
- 解析OKX K线消息
- 转换为`KlineEvent`发布到`MarketEventBus`

**MarketEventBus**
- 事件总线，解耦订阅和处理
- 异步执行消费者，不阻塞WebSocket IO线程

#### 6.1.2 处理层（subscription/processor）

**MarketDataCenter**
- 订阅`MarketEventBus`接收`KlineEvent`
- 去重处理（内存缓存）
- 调用存储服务写入QuestDB

#### 6.1.3 查询层（web/query）

**QuestDbMarketQueryService**
- 提供历史K线查询接口
- 支持时间范围查询、最新K线查询等

#### 6.1.4 校准层（calibration）

**MarketCalibrationScheduler**
- 定时扫描校准任务配置
- 执行缺失数据检测和数据核对
- 记录执行日志

### 6.2 指标模块（indicator）

#### 6.2.1 启动初始化（bootstrap）

**IndicatorBootstrapper**
- 注册内置指标定义（RSI、MACD等）
- 持久化到`indicator_definition`表

**IndicatorBootstrapListener**
- 监听应用启动事件
- 触发`BarSeriesManager.bootstrap()`加载历史数据

#### 6.2.2 计算核心（calculator）

**IndicatorCalculator**
- 监听`BarClosedEvent`
- 异步处理计算任务
- 协调整个计算流程

**流程**：
1. 查询订阅（`indicator_subscription`表）
2. 获取BarSeries
3. 从Registry获取指标定义
4. 从Router获取引擎
5. 执行计算
6. 生成指纹
7. 持久化结果（日志+值）

#### 6.2.3 Bar系列管理（series）

**BarSeriesManager**
- 管理内存中的`BarSeries`（每个pair+timeframe一个）
- 启动时从QuestDB加载历史数据
- 实时追加新的Bar（去重）

**QuestDbKlineReader**
- 从QuestDB读取K线数据
- 转换为`NormalizedBar`（统一时间语义）

#### 6.2.4 计算引擎（engine）

**IndicatorEngine接口**
- 定义统一的计算接口
- 实现：`Ta4jIndicatorEngine`（基于ta4j库）

#### 6.2.5 持久化（repository）

**IndicatorValueRepository**
- 提供指标值的持久化接口
- 实现幂等写入（`insert ignore`）
- 冲突检测

### 6.3 K线聚合模块（aggregation）

**职责**：从1分钟K线聚合生成多周期K线

**核心组件**：
- `KlineAggregationEngine`：聚合引擎
- `AggregationConfig`：聚合配置（订阅需要聚合的交易对和周期）
- `BarClosedEventPublisher`：发布K线闭合事件

**流程**：
1. 从QuestDB读取1分钟K线
2. 按周期聚合（5m、15m、30m、1h、4h）
3. 写入对应的QuestDB表
4. 发布`BarClosedEvent`（触发指标计算）

### 6.4 策略模块（strategy）

**职责**：策略定义、配置和运行时管理

**核心组件**：
- `StrategyDefinitionService`：策略定义服务
- `StrategyRuntimeFactory`：策略运行时工厂
- `SignalViewBinder`：将信号绑定到策略视图

**策略类型**：
- `SIGNAL_DRIVEN`：信号驱动（完全跟随信号）
- `INDICATOR_DRIVEN`：指标驱动（基于技术指标）
- `HYBRID`：混合策略

---

## 七、业务流程

### 7.1 系统启动流程

```
1. Spring Boot应用启动
   ↓
2. IndicatorBootstrapper注册内置指标定义
   ↓
3. IndicatorBootstrapListener触发初始化
   ↓
4. BarSeriesManager.bootstrap()
   - 查询所有启用的指标订阅
   - 从QuestDB加载历史K线数据
   - 构建内存中的BarSeries
   ↓
5. 启动行情订阅（MarketDataCenter）
   - 查询market_subscription_config
   - 建立WebSocket连接
   - 订阅交易对
   ↓
6. 启动K线聚合（如果配置了）
   ↓
7. 系统就绪
```

### 7.2 实时行情处理流程

```
1. OKX WebSocket推送K线数据
   ↓
2. KlineChannel解析消息
   ↓
3. 发布KlineEvent到MarketEventBus
   ↓
4. MarketDataCenter接收事件
   ↓
5. 去重检查（内存缓存）
   ↓
6. 写入QuestDB（kline_1m表）
   ↓
7. 可选：更新Redis缓存
```

### 7.3 指标计算流程

```
1. K线聚合完成或K线周期结束
   ↓
2. 发布BarClosedEvent
   ↓
3. IndicatorCalculator接收事件（异步）
   ↓
4. 查询该交易对+周期的所有订阅
   ↓
5. 对每个订阅：
   a. 获取BarSeries（从内存或QuestDB）
   b. 从Registry获取指标定义
   c. 从Router获取计算引擎
   d. 构造计算请求
   e. 调用引擎计算
   f. 生成计算指纹
   g. 写入计算日志（indicator_calc_log）
   h. 写入指标值（indicator_value，幂等）
   ↓
6. 更新Metrics
```

### 7.4 信号接收流程

```
1. TradingView发送Webhook请求
   ↓
2. SignalController接收请求
   ↓
3. 根据signal_name和symbol查询signal_config
   ↓
4. 验证：
   - signal_config存在且启用
   - 用户权限校验
   ↓
5. SignalService处理：
   - 解析信号内容
   - 构建Signal实体
   - 写入signal表
   ↓
6. 可选：发布SignalReceivedEvent（供策略监听）
```

### 7.5 策略决策流程（规划中）

```
1. 策略运行时监听信号或指标
   ↓
2. 读取策略配置（入场条件、出场条件）
   ↓
3. 决策引擎：
   - 评估入场条件（信号+指标+价格）
   - 如果满足，生成OPEN意图
   - 如果已持仓，评估出场条件
   ↓
4. 生成TradeIntent（交易意图）
   ↓
5. 写入strategy_intent_record
   ↓
6. 更新strategy_logic_state
   ↓
7. 风控模块校验
   ↓
8. 执行交易（OKX API）
```

---

## 八、业务思想与设计原则

### 8.1 业务思想

#### 8.1.1 信号与决策分离

**核心思想**：信号是**事实记录**，不是交易指令。

- **信号模块**只负责接收、存储信号，不进行任何交易决策
- **策略模块**负责读取信号，结合指标和其他因素，决定是否交易
- 这样可以：
  - 支持信号回放和回测
  - 支持一个信号被多个策略消费
  - 支持策略忽略或延迟执行信号

#### 8.1.2 事件驱动架构

**核心思想**：系统各模块通过**事件**解耦，而不是直接调用。

**优势**：
- **解耦**：行情模块不需要知道指标模块的存在
- **扩展性**：新增消费者不需要修改发布者代码
- **异步处理**：避免阻塞关键路径（如WebSocket接收）

**核心事件**：
- `KlineEvent`：新的K线数据
- `BarClosedEvent`：K线闭合（触发指标计算）

#### 8.1.3 幂等性设计

**核心思想**：所有写操作都应该是**幂等**的，支持事件重放。

**实现方式**：
- **唯一索引**：数据库层面防止重复
- **insert ignore**：写入时忽略已存在的记录
- **计算指纹**：相同配置的计算生成相同的指纹，用于冲突检测

**好处**：
- 支持系统重启后的数据恢复
- 支持事件系统的重放机制
- 避免并发导致的数据冲突

#### 8.1.4 数据完整性保障

**核心思想**：通过**校准机制**保证数据完整性。

**实现**：
- **实时订阅**：主要数据来源
- **定时校准**：检测并补全缺失数据
- **数据核对**：检测重复、错序、异常数据

### 8.2 设计原则

#### 8.2.1 单一职责原则

每个模块、每个类都有明确的职责：
- **MarketDataCenter**：只负责接收K线并写入，不包含任何补拉逻辑
- **IndicatorCalculator**：只负责指标计算，不负责K线数据获取
- **SignalService**：只负责信号存储，不进行交易决策

#### 8.2.2 分层架构

清晰的层次划分：
- **Web层**：Controller，处理HTTP请求
- **Service层**：业务逻辑
- **Repository层**：数据访问抽象
- **Infrastructure层**：基础设施（数据库、WebSocket等）

#### 8.2.3 依赖倒置

高层模块不依赖低层模块，都依赖抽象：
- Service依赖Repository接口，不依赖具体实现
- 指标计算依赖`IndicatorEngine`接口，支持多种引擎实现

#### 8.2.4 多租户隔离

所有业务数据都通过`user_id`隔离：
- 用户可以独立管理自己的配置和数据
- 支持后续扩展为企业级SaaS服务

### 8.3 数据设计思想

#### 8.3.1 双数据库架构

**MySQL**（业务数据）：
- 用户、配置、信号、策略等
- 需要事务支持
- 数据量相对较小

**QuestDB**（时序数据）：
- K线数据（高频、大量）
- 需要高性能写入和查询
- 不需要事务

#### 8.3.2 冗余字段设计

为了提高查询性能和可维护性，部分表包含冗余字段：
- `signal`表包含`symbol`字段（用于快速匹配）
- `indicator_value`表包含`symbol`和`market_type`字段（便于排查）

**权衡**：牺牲部分存储空间，换取查询性能和可维护性。

#### 8.3.3 时间语义统一

**系统唯一时间基准**：UTC

- 所有时间戳都使用UTC
- 用户输入的时间字符串直接当作UTC处理
- K线时间对齐到周期起始点

### 8.4 扩展性设计

#### 8.4.1 多交易所支持

当前优先支持OKX，但架构支持扩展：
- `exchange_code`字段预留多交易所
- `ExchangeWebSocketManager`可以扩展支持其他交易所
- `ExchangeMarketPair`表结构支持多交易所

#### 8.4.2 多指标引擎支持

当前使用ta4j，但支持自定义引擎：
- `IndicatorEngine`接口定义统一规范
- `IndicatorEngineRouter`根据指标定义选择引擎
- 可以轻松添加新的引擎实现

#### 8.4.3 多策略类型支持

策略类型可扩展：
- `SIGNAL_DRIVEN`：信号驱动
- `INDICATOR_DRIVEN`：指标驱动
- `HYBRID`：混合策略
- 未来可以添加更多类型

---

## 九、开发规范

### 9.1 代码规范

- **命名规范**：
  - 类名：大驼峰（`UserService`）
  - 方法名/变量名：小驼峰（`getUserInfo`）
  - 常量：全大写加下划线（`USER_STATUS`）

- **注释规范**：
  - 类和方法需要JavaDoc注释
  - 复杂业务逻辑需要注释说明

- **异常处理**：
  - 统一使用`Result<T>`作为返回值
  - 自定义异常继承`BusinessException`
  - 全局异常处理器（`GlobalExceptionHandler`）

### 9.2 数据库规范

- **表名**：下划线命名（`sys_user`）
- **字段名**：下划线命名（`created_at`）
- **主键**：统一命名为`id`，类型`BIGINT`
- **时间字段**：`created_at`、`updated_at`使用`DATETIME(3)`
- **逻辑删除**：使用`deleted`字段，不使用物理删除

### 9.3 Git提交规范

建议使用以下格式：
```
<type>(<scope>): <subject>

<body>

<footer>
```

类型（type）：
- `feat`：新功能
- `fix`：修复bug
- `docs`：文档更新
- `refactor`：重构
- `test`：测试
- `chore`：构建/工具改动

---

## 十、快速开始

### 10.1 环境要求

- JDK 17+
- Maven 3.6+
- MySQL 5.7+
- QuestDB（最新版）
- Redis（可选）

### 10.2 启动步骤

1. **启动MySQL和QuestDB**
2. **执行SQL脚本**：
   - `src/main/resources/sql/init.sql`
   - `src/main/resources/sql/indicator/*.sql`
   - `src/main/resources/sql/strategy.sql`
   - `src/main/resources/sql/questdb_init.sql`
3. **配置application.yml**：
   - 修改数据库连接信息
   - 配置Redis（如使用）
4. **启动应用**：
   ```bash
   mvn spring-boot:run
   ```
5. **访问**：
   - 前端：`http://localhost:8080`
   - API文档：`http://localhost:8080/api/...`
   - Metrics：`http://localhost:8080/actuator/prometheus`

### 10.3 常用操作

#### 创建交易对配置

```sql
INSERT INTO trading_pair (symbol, base_currency, quote_currency, market_type, enabled)
VALUES ('BTC-USDT', 'BTC', 'USDT', 'SWAP', 1);
```

#### 配置行情订阅

```sql
INSERT INTO market_subscription_config (trading_pair_id, enabled)
VALUES (1, 1);
```

#### 订阅指标

```sql
INSERT INTO indicator_subscription 
(user_id, trading_pair_id, symbol, market_type, timeframe, indicator_code, indicator_version, params, enabled)
VALUES 
(1, 1, 'BTC-USDT', 'SWAP', '1h', 'RSI', 'v1', '{"period":14}', 1);
```

---

## 十一、常见问题

### Q1: 为什么使用双数据库？

A: MySQL适合存储业务数据（用户、配置等），需要事务支持；QuestDB是专业的时序数据库，适合存储高频的K线数据，写入和查询性能远超MySQL。

### Q2: 指标计算是实时的吗？

A: 是的。当一根K线完成时，系统会立即触发该K线周期的所有指标计算，异步执行，不阻塞其他流程。

### Q3: 如何添加新的指标？

A: 两种方式：
1. 系统内置：在`BuiltinIndicatorDefinitions`中添加定义，重启后自动注册
2. 用户自定义：通过API或直接插入`indicator_definition`表

### Q4: 信号丢失了怎么办？

A: 信号表使用唯一索引，支持幂等写入。如果信号丢失，可以重新发送Webhook请求，不会产生重复数据。

### Q5: 如何监控系统运行状态？

A: 
- 访问`/actuator/prometheus`查看Metrics
- 查看日志文件（Log4j2配置）
- 查询数据库表（如`indicator_calc_log`、`market_calibration_task_log`）

---

## 十二、后续规划

### 12.1 已完成模块

- ✅ 用户管理
- ✅ 交易对管理
- ✅ 行情订阅和存储
- ✅ 行情校准
- ✅ K线聚合
- ✅ 指标计算
- ✅ 信号管理
- ✅ 策略定义（部分）

### 12.2 待开发模块

- ⏳ 策略运行时（决策引擎）
- ⏳ 风控模块
- ⏳ 交易执行
- ⏳ 回测模块
- ⏳ 统计和报表

### 12.3 技术债务

- ⏳ 多周期K线订阅（当前只支持1分钟）
- ⏳ WebSocket分发功能完善
- ⏳ 性能优化（指标计算并发优化）

---

**文档维护者**：开发团队  
**最后更新**：2026-01-06  
**联系方式**：项目仓库Issues




