下面给出我们量化团队汇总后的 **《指标总体产品重构设计结果（V2：K线订阅不变 + 单表定义 + 运行时缓存 + 结果归档到策略规则体）》**。该设计是在你提出的三点目标基础上落地：**1) K线订阅不变；2) 只保留一张指标定义表；3) 缓存命中保证效率**，同时把“指标结果事实库/自动落库”从产品定位里移除（与现有 V1.2 规范需要明确做版本升级/取舍）。现有规范里曾强调“按周期计算并持久化、指标是事实”，以及禁止根据策略参数计算【】【】——本次重构就是对这部分做**产品级改版**。

---

## Step 1：产品定位与目标（V2 一句话定义）

### 1.1 V2 一句话定义

> **指标模块 V2 是“指标定义注册中心 + 运行时按需评估能力”，以 K线闭合作为输入事实流维护 BarSeries；指标结果不在指标模块落库，而归档在策略大脑的 rules_record（strategy_rules_record）里。**

### 1.2 为什么要改（从 V1.2 到 V2）

* V1.2 的产品价值是“统一计算、统一存储、可回放可解释”【】；并要求“按周期计算并持久化”【】
* 但你们当前的现实是：**指标参数高度自定义**，订阅式自动计算会变成“算出来没人用”的资源黑洞（组合爆炸），所以需要转向 **“谁用谁算 + 缓存复用”**（影响清单已明确这个重构目标）【】

---

## Step 2：范围界定（Must / Must Not）

### 2.1 V2 必须做（Must）

1. **K线订阅不变**：继续接收 BarClosedEvent，维护 BarSeries（输入窗口）。
2. **指标定义管理**：提供“指标定义表”的 CRUD、查询、版本管理。
3. **按需评估（evaluate / batch）**：策略/回测调用统一入口计算指标输出。
4. **缓存命中**：同参同上下文（indicatorCode+version+pair+tf+barTime+params）结果可复用（影响清单给出了缓存键规范）【】
5. **结果归档在策略规则体**：指标模块不做 value 落库；策略大脑把评估结果写入 strategy_rules_record（你新的产品方向）。

### 2.2 V2 严禁做（Must Not）

* 不感知 strategy_id、不决策（保持模块边界思想）【】
* **不做订阅驱动的自动计算与落库**（默认关闭旧链路；影响清单也明确要关闭旧 calculator）【】
* 不做 Tick 级反复更新（仍维持“结果稳定性”原则）【】

---

## Step 3：总体架构（4 层）

### 3.1 输入事实层（保留）

* **BarClosedEvent → BarSeriesManager**：只维护 K线窗口，不触发指标计算（你要求“订阅不变”）。

### 3.2 定义注册层（只保留一张表）

* **indicator_definition 单表**：指标的元信息、参数 schema、返回 schema、实现映射（impl_key）、版本、启停。

### 3.3 运行时评估层（新增核心）

* **IndicatorRuntime / IndicatorEvaluateService**：提供 `evaluate()` / `evaluateBatch()`（影响清单已明确关键方法签名与 batch）【】

### 3.4 缓存层（命中保障效率）

* **IndicatorCacheManager**：缓存键规范、TTL/容量配置、命中率统计（影响清单已有文件路径与职责）【】

---

## Step 4：数据模型（只保留 indicator_definition）

### 4.1 indicator_definition（V2 单表建议字段）

> 你说“用户可自定义入参/返参”，所以 schema 必须是表字段核心。

* `indicator_code`、`version`（版本必须保留，避免升级破坏旧策略；V1.2 也强调版本机制）【】
* `name`、`description`
* `data_source`：BAR / TICK / SIGNAL / MIXED（用于运行时准备 context）
* `impl_key`：硬代码插件映射键（例如 `ta4j:rsi` / `builtin:price_breakout`）
* `param_schema`：用于前端表单渲染 + 后端校验
* `return_schema`：用于输出校验 + 前端展示
* `enabled`
* 时间字段

> 说明：V2 不再依赖 subscription/value/calc_log 作为产品主路径；与历史文档“按周期计算并持久化”【】的定位不同，因此需要把 V2 定义为新版本产品规范（而不是在 V1.2 上打补丁）。

---

## Step 5：接口设计（给前后端/策略统一使用）

### 5.1 定义类接口

* `GET /api/indicator/definitions`：列表/筛选（你们前端指令书的 Definitions 页基于该接口）【】
* `POST /api/indicator/definitions`：创建
* `PUT /api/indicator/definitions/{id}`：更新
* `PATCH /api/indicator/definitions/{id}`：启停

> V2 建议把 Definitions 从“只读”升级为“可编辑”（V1 UI 里是只读）【】，因为你要支持用户自定义 schema。

### 5.2 运行时评估接口（新主链路）

* `POST /api/indicator/evaluate`
* `POST /api/indicator/evaluate/batch`

**核心点：缓存键规范必须按影响清单固定**：`indicatorCode + version + pairId + timeframe + asOfBarTime + hash(params)`【】

---

## Step 6：前端产品形态（从“验证自动计算”转为“配置定义 + 触发评估”）

你们旧 UI 指令书的 5 页，很多是为了验证“订阅→计算→结果/日志”闭环【】【】。V2 建议调整为：

1. **指标定义（Definitions）—核心页**

   * 支持编辑：`data_source / impl_key / param_schema / return_schema / enabled`
   * param_schema 以“schema 编辑器 + 表单预览”呈现

2. **按需评估（Evaluate Playground）—建议新增或并入 Values**

   * 选择：pair/tf/barTime + indicatorCode/version
   * 自动渲染 params 表单
   * 点击 Evaluate（或 Batch Evaluate）
   * 展示：结果 + `source（CACHE/COMPUTED）`（影响清单也提到 values 页适配 source 字段）【】

> 订阅页/日志页在 V2 可降级为“输入事实监控/调试辅助”，不再是核心用户路径。

---

## Step 7：配置与观测（保证高效与可运营）

### 7.1 配置项（必须）

* `indicator.evaluate.cache.enabled / ttl / max-size`（影响清单已给出 yml 示意）【】
* `indicator.evaluate.auto-calculate.enabled=false`（关闭旧自动计算模式；影响清单明确要 Feature Flag）【】

### 7.2 观测指标（建议必做）

* evaluate 耗时、缓存命中率、batch size 分布（影响清单已列 metrics）【】

---

## Step 8：端到端主链路（V2 运行闭环）

1. BarClosedEvent 到达 → BarSeriesManager 更新窗口（订阅不变）
2. 策略大脑触发规则评估 → 调用 `evaluateBatch(ctx, factors[])`
3. IndicatorRuntime：

   * 先按 cacheKey 查缓存
   * miss：读取 BarSeries/必要输入 → 调用 impl_key 对应插件硬代码计算 → 校验 return_schema → 写缓存
4. 策略把每个因子结果（含 fingerprint/paramsHash/source/costMs）写入 `strategy_rules_record`（可解释、可复盘，但复盘维度属于“策略维度”而非“指标事实维度”）

---

## Step 9：验收标准（QA 可直接照跑）

1. **K线订阅仍正常**：BarClosedEvent 频率与窗口更新正确（无额外计算负载）。
2. **定义表可配置**：能创建/编辑一个新指标定义（自定义 param_schema/return_schema）。
3. **插件映射生效**：同一 indicator_code+version 能正确路由到 impl_key 对应硬代码。
4. **缓存命中有效**：同一 `(code,version,pair,tf,barTime,params)` 连续评估，第二次返回 `source=CACHE` 且耗时显著下降（cacheKey 规范按影响清单）【】
5. **策略侧归档**：策略运行后，`strategy_rules_record` 能看到指标输出与 fingerprint，可用于解释当时决策。

