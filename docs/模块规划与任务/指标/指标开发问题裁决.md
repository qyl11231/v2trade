P0-1 事件系统不匹配：BAR_CLOSED vs KlineEvent.isFinal
✅ 裁决：你说得对，必须修，但不必大改

指标模块确实必须只消费 BAR_CLOSED

现有 KlineEvent.isFinal=false 属于“事件语义未建模”，会导致 forming 误算

✅ 最小改动的冻结方案（推荐）

不改 KlineEvent 协议本身，不让指标模块直接订阅 KlineEvent。
在 KlineAggregatorImpl（或聚合器完成处）发布新事件：

BarClosedEvent（只在聚合完成时发布）

指标模块只订阅 BarClosedEvent

这是最干净、最符合单一职责的做法：
聚合器负责“闭合判断”，指标模块负责“闭合后计算”。

P0-2 时间语义不明确：bar_time vs bar_close_time
✅ 裁决：你抓到了最关键风险，但“转换方向”需要统一裁决

你文档里提出了多种推测（openTime/closeTime/NEXT_CLOSE），这会导致实现发散。

我给一个冻结裁决（工程上最稳）：

指标模块内部永远使用 bar_close_time
所有上游来源进入指标前必须归一化
归一化规则按“数据源类型”确定，不在业务代码散落判断

✅ 关于 QuestDB ts 字段语义

你的推测“ts 看起来像分钟对齐，所以可能是 openTime”非常合理。

工业级做法不是靠推测，而是做“可配置 + 可验证”的适配器：

QuestDbTimeAdapter 支持两种模式：

TS_IS_OPEN_TIME → bar_close = ts + duration

TS_IS_CLOSE_TIME → bar_close = ts

默认使用 TS_IS_OPEN_TIME（更符合你日志表现）

启动时增加一个自动验证探针（Probe）：

抽样读取最新 N 条 ts

检查：ts % duration == 0 是否成立

检查：同 symbol 相邻 ts 是否严格递增 duration

输出一条启动日志：QuestDB ts semantics = OPEN_TIME（或 CLOSE_TIME）

若不满足任何规则 → fail fast（阻塞启动），避免错算一整套指标

这样就不需要“待确认”，系统自己判定并落日志。

P0-3 QuestDB 表结构已确认

✅ 通过，无需改动。
但要补充一条：指标模块只读聚合表，不在指标层做聚合（你文档里也提到了）。

P1-4 trading_pair_id 与 symbol 映射
✅ 裁决：必须做，但不必在指标模块做复杂查表

建议拆成独立基础设施服务（你已有 trading_pair 管理）：

TradingPairResolver（缓存 + DB 回源）

指标模块只依赖 resolver，不自己 join 表

并冻结映射规则：

WS/QuestDB 输入都是 symbol

指标系统内部主键用 trading_pair_id

入站：symbol→id

出站：id→symbol（用于查询QuestDB）

P1-5 指标表结构与现有数据库集成

✅ 必须做迁移脚本 + 唯一索引 + 冲突策略。
另外补充一个生产必备字段（你文档没提）：

calc_fingerprint（hash：code+version+params+engine）
用于线上排查“同一个指标为何不同”。

P1-6 ta4j BarSeries 转换

你写的转换没错，但你标注“ta4j bar time 通常是开盘时间”这一点会引起误会。

✅ 冻结裁决

ta4j 的 Bar 时间戳我们统一喂 bar_close_time（内部一致性优先）

如果 ta4j 某些指标默认按 bar end 语义更贴近 TA 解释，且你系统也是 close 才触发，那就一致。

不再引入 openTime/closeTime 双语义，避免混乱。

P2-7 版本管理

✅ 冻结：v1.2.1 指标版本统一写死 "v1"，不做版本管理 UI，不做多版本共存路由。

P2-8 数据质量判断

你提出 0.8 的阈值是“业务感很强”的策略，容易争议。

✅ 冻结裁决（工业级简单可靠）

availableBars >= requiredBars → OK

否则 → PARTIAL

发生异常或 NaN → INVALID

v1.2.1 不引入 0.8 阈值这种“拍脑袋规则”。

P2-9 失败策略

✅ 冻结：

Exception → INVALID + ERROR 日志 + metrics

NaN/Infinity → INVALID + WARN 日志 + metrics

不重试（避免阻塞事件链）

P2-10 Redis 缓存

✅ 冻结：v1.2.1 不启用 Redis（先 MySQL 读写闭环），留接口不实现。