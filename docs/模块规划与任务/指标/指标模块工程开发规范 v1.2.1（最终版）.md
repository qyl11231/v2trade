很好，这一步**就是把整个指标模块“冻结成可执行工程契约”**。
下面是我基于你前面所有裁决、纠偏与生产级要求，整理出的：

> **《指标模块工程开发规范 v1.2.1（最终版）》**

这是一份**可以直接交给开发、不会再反复推翻的规范**。

---

# 指标模块工程开发规范

## Indicator Module Engineering Spec v1.2.1（Final）

---

## 0. 版本声明（Freeze）

* **版本**：v1.2.1（最终版）
* **状态**：冻结（Frozen）
* **适用范围**：

    * 行情派生指标计算
    * 多周期 K 线指标
    * 策略阶段二条件判断
* **不适用范围**：

    * 策略决策逻辑
    * 回测引擎
    * Tick 级实时指标

---

## 1. 模块定义与定位（What & Where）

### 1.1 模块定义（一句话）

> **指标模块是行情系统的派生计算层，
> 以“已闭合 K 线”为唯一输入，
> 产出确定性、可复现、可审计的技术指标事实数据。**

### 1.2 系统位置（强约束）

```text
交易所行情
  ↓
行情接入 / WS
  ↓
K线标准化与聚合（1m / 5m / 15m / 1h / 4h）
  ↓
【指标模块 v1.2.1】
  ↓
策略模块（阶段2：条件判断）
```

### 1.3 单向依赖原则

| 依赖方向        | 是否允许 |
| ----------- | ---- |
| 指标 → 行情     | ✅    |
| 策略 → 指标（只读） | ✅    |
| 指标 → 策略     | ❌    |
| 指标 → 交易执行   | ❌    |

---

## 2. 核心设计原则（不可违背）

### 2.1 三大工程铁律

1. **指标 ≠ 策略**
2. **指标 = 行情派生事实**
3. **同一输入 → 同一输出**

### 2.2 禁止反模式

| 行为               | 后果       |
| ---------------- | -------- |
| 指标感知 strategy_id | 强耦合、不可复现 |
| 策略触发指标计算         | 生命周期混乱   |
| Tick 内反复算指标      | 非确定性     |
| ta4j 类型外泄        | 引擎锁死     |

---

## 3. 时间语义与事件模型（P0）

### 3.1 K线时间语义（冻结）

* `bar_time` **必须表示 K 线收盘时间**
* 含义示例：

    * `10:05:00` → `[10:00:00, 10:05:00)` 区间
* 所有时间 **统一使用 UTC**

### 3.2 周期对齐规则

```text
bar_time % timeframe == 0
```

否则该 bar **非法，不可用于指标计算**。

---

### 3.3 Bar 事件类型

```java
enum BarEventType {
    FORMING_UPDATE,   // 形成中（不允许计算）
    BAR_CLOSED        // 已闭合（唯一合法计算点）
}
```

> **指标模块只消费 BAR_CLOSED 事件**

---

## 4. 指标模块工程分层（结构冻结）

```text
indicator/
├── api/              # 对外只读接口
├── domain/           # 核心领域对象
├── definition/       # 指标定义（元数据）
├── engine/           # 指标计算引擎（可插拔）
│   ├── ta4j/
│   ├── custom/
│   └── IndicatorEngine.java
├── series/           # BarSeries 管理
├── calculator/       # 调度与触发
├── repository/       # 持久化
├── bootstrap/        # 启动恢复
└── observability/    # Metrics / Logs
```

---

## 5. 指标定义规范（Definition Contract）

### 5.1 指标定义接口（冻结）

```java
public interface IndicatorDefinition {

    String code();        // RSI_14
    String version();     // v1
    IndicatorCategory category();

    Set<Timeframe> supportedTimeframes();

    ParameterSpec parameters();
    ReturnSpec returns();

    int minRequiredBars();
}
```

---

### 5.2 参数规范（ParameterSpec）

```java
class ParameterSpec {
    String name;
    ParamType type;          // INT / DECIMAL / ENUM
    boolean required;
    Object defaultValue;
    Range range;
}
```

> ❗禁止使用 Map<String,Object> 作为参数入口

---

### 5.3 返回值规范（ReturnSpec）

```java
class ReturnSpec {
    ReturnType type;         // SINGLE / MULTI
    List<String> keys;       // 如 upper/middle/lower
}
```

---

## 6. 指标引擎抽象（Engine Contract）

### 6.1 引擎接口（冻结）

```java
public interface IndicatorEngine {

    boolean supports(IndicatorDefinition def);

    IndicatorResult calculate(
        IndicatorDefinition def,
        BarSeries series,
        int barIndex
    );
}
```

### 6.2 引擎可替换性

* ta4j = 一个实现
* 自研指标 = 一个实现
* 引擎 **不得暴露内部类型**

---

## 7. BarSeries 管理规范（P0）

### 7.1 数据来源

* 启动时加载 **最近 365 根**
* 数据来源：QuestDB / 行情中心

### 7.2 更新规则

* 只允许 append
* 禁止回写历史
* 每个 `(pair, timeframe)` 独立维护

---

## 8. 指标计算调度（Calculator）

### 8.1 唯一触发路径

```text
BAR_CLOSED
   ↓
BarSeries.append
   ↓
IndicatorCalculator
   ↓
IndicatorEngine.calculate
   ↓
Persist
```

### 8.2 不允许行为

* 不允许策略调用
* 不允许外部强制触发

---

## 9. 指标结果模型（事实对象）

```java
class IndicatorResult {

    String indicatorCode;
    String version;

    BigDecimal value;
    Map<String, BigDecimal> extraValues;

    LocalDateTime barTime;
    DataQuality quality;
}
```

> **结果对象必须不可变**

---

## 10. 指标持久化规范（P0）

### 10.1 表结构（冻结）

```sql
indicator_value (
  trading_pair_id,
  timeframe,
  bar_time,
  indicator_code,
  indicator_version,
  value,
  extra_values,
  data_quality,
  created_at
)
```

### 10.2 幂等规则（严格）

* 唯一键：
  `(pair, timeframe, bar_time, code, version)`
* 行为：

    * 已存在 → ignore
    * 若值不同 → 记录冲突日志 + 告警
* v1.2.1 **禁止覆盖历史值**

---

## 11. 数据质量定义（冻结）

```java
enum DataQuality {
    OK,
    PARTIAL,
    INVALID
}
```

* 数据不足 → PARTIAL
* 异常计算 → INVALID

---

## 12. 启动恢复策略

* 重建 BarSeries
* 不补算历史指标
* 等待下一根 BAR_CLOSED 正常推进

---

## 13. 可观测性要求（P0）

### 13.1 Metrics（必须）

* `indicator.calc.latency.p95`
* `indicator.calc.latency.p99`
* `indicator.persist.latency`
* `indicator.calc.error.count`
* `indicator.quality.partial.count`

### 13.2 Logging

* 仅关键事件：

    * 计算失败
    * 数据冲突
    * 数据不足

---

## 14. 对策略模块的契约（只读）

```java
IndicatorSnapshot getLatest(
    tradingPairId,
    timeframe,
    indicatorCode,
    version
);
```

* 不触发计算
* 不修改状态

---

## 15. Redis / MySQL 使用原则

* **MySQL**：事实存档 / 回放 / 审计
* **Redis**：最新指标快照（可选）
* Redis key 示例：

  ```
  ind:{pair}:{tf}:{code}:{ver}
  ```

---

## 16. 测试与发布约束（P0.5）

* 每个指标必须有：

    * Golden Test
    * 边界测试
* 发布前：

    * 全量回归
    * JMH 基准（热指标）

---

## 17. 明确不在 v1.2.1 范围内

* Tick 指标
* 指标告警
* DSL 公式
* 策略级指标

---

## 18. 最终冻结声明（一句话）

> **指标模块 v1.2.1 是行情系统的派生事实生产线，
> 不参与决策、不感知策略、只对已闭合行情负责。**

---

如果你愿意，下一步我可以直接帮你：

* 拆 **Java 包 + 类清单（给 Cursor）**
* 写 **一个完整 RSI/MACD 的 ta4j + 自研实现示例**
* 或把 **阶段二条件判断模块与本规范对齐**

你现在这份规范，已经是**可以长期维护、不容易返工的级别**了。
