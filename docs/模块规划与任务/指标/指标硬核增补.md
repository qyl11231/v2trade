# 指标模块 v1.2.2（DB接入增强）Cursor 执行清单（硬核版）

> 目标：在不改动既有阶段体系(0~7)的前提下，引入 MySQL 四张表并形成“BAR_CLOSED -> 计算 -> 落库 -> 可查询”闭环。
> 禁止发散：不引入策略逻辑、不做回补计算、不改行情校准模块、不改 QuestDB 表结构。

---

## 全局冻结裁决（必须遵守）

1) 指标计算触发唯一事件：BarClosedEvent（forming bar 不触发）
2) 指标模块内部唯一时间语义：bar_time = bar_close_time（UTC）
3) QuestDB ts 语义默认 OPEN_TIME，但必须有 Probe 自检；无法判定 fail fast
4) 指标模块内部主键使用 trading_pair_id；symbol 通过 TradingPairResolver 做映射
5) MySQL 四表为事实与审计源：definition/subscription/value/calc_log
6) 幂等写入：indicator_value 唯一键冲突 ignore；若检测到冲突值不同 -> 记 FAILED(CONFLICT)

---

# 阶段 0.5（新增）：数据库迁移 + Repository 骨架

## 0.5.1 迁移脚本（Flyway/Liquibase）
**交付物**
- `db/migration/V001__create_indicator_definition.sql`
- `db/migration/V002__create_indicator_subscription.sql`
- `db/migration/V003__create_indicator_value.sql`
- `db/migration/V004__create_indicator_calc_log.sql`

**验收**
- 本地启动后四张表存在
- 字段包含 user_id / created_at（value表含 updated_at）
- 唯一索引、关键索引存在
- 迁移可重复执行无报错

**测试**
- Migration 集成测试（启动容器/测试库执行迁移）

---

## 0.5.2 Repository 接口定义（仅接口 + 最小实现）
**新增包**
- `indicator/repository/`

**接口**
- `IndicatorDefinitionRepository`
  - `void saveSystemDefinitions(List<IndicatorDefinitionDO> defs)`  // user_id=0, ignore on conflict
  - `List<IndicatorDefinitionDO> listEnabled(long userId)`          // userId=0 or tenant

- `IndicatorSubscriptionRepository`
  - `List<IndicatorSubscriptionDO> listEnabledByUser(long userId)`
  - `List<IndicatorSubscriptionDO> listEnabledByPairTf(long userId, long pairId, String timeframe)`
  - `void upsert(IndicatorSubscriptionDO sub)`

- `IndicatorValueRepository`
  - `WriteResult insertIgnore(IndicatorValueDO v)`                  // 返回 inserted/ignored
  - `Optional<IndicatorValueDO> findOneKey(...)`                    // 用于冲突检测（可选优化）

- `IndicatorCalcLogRepository`
  - `void append(IndicatorCalcLogDO log)`                           // append-only

**验收**
- 四个 repository 可被 Spring 注入
- insertIgnore 返回可判断是否插入

**测试**
- Repository CRUD 集成测试（H2不建议；用 MySQL TestContainer 或本地 MySQL）

---

# 阶段 1：BarSeries（历史加载 + 实时 append）接入订阅驱动

## 1.1 TradingPairResolver（如已存在则复用）
**要求**
- `Long symbolToId(String symbol)`
- `String idToSymbol(Long pairId)`
- 必须缓存（Caffeine 或 ConcurrentHashMap）

**验收**
- WS symbol 能映射到 pairId
- QuestDB 查询能从 pairId 得到 symbol

---

## 1.2 QuestDbKlineReader（只读聚合表）
**类**
- `indicator/series/QuestDbKlineReader`

**方法**
- `List<NormalizedBar> loadLatestBars(long pairId, String timeframe, int limit)`

**规则**
- bar_time 必须是 bar_close_time（UTC）
- 使用 TimeAlignmentAdapter 统一归一化

**验收**
- 任意 pair/timeframe 返回升序 bars
- bars 的时间步长严格等于 timeframe duration

**测试**
- 给定固定区间，验证返回条数与时间间隔

---

## 1.3 BarSeriesManager（按订阅建立 Series）
**类**
- `indicator/series/BarSeriesManager`

**方法**
- `void bootstrap(long userId)`  // 读取 subscription，加载各 pair/timeframe 365 bars
- `void onBarClosed(BarClosedEvent e)`  // append & 去重（同bar_time忽略）
- `BarSeriesView getSeries(long userId, long pairId, String timeframe)` // 只读视图

**验收**
- 订阅中出现的 pair/timeframe 才会被加载与维护
- 重放同一 BarClosedEvent 不产生重复 bar

**测试**
- append 去重测试（同bar_time两次 only once）

---

# 阶段 2：Definition/Registry 落库（indicator_definition）

## 2.1 指标注册时写入 definition（user_id=0）
**类**
- `indicator/definition/IndicatorRegistry`
- `indicator/bootstrap/IndicatorBootstrapper`

**流程**
- 系统启动 -> 扫描注册指标 -> 转成 IndicatorDefinitionDO -> repository.saveSystemDefinitions(defs)

**验收**
- `indicator_definition` 表出现系统指标（user_id=0）
- 重启不重复插入、不报错

**测试**
- 启动两次后 definition 数量不变

---

# 阶段 3：Engine（ta4j + custom）不依赖表，但必须符合契约

## 3.1 Ta4jEngine
**类**
- `indicator/engine/ta4j/Ta4jIndicatorEngine`

**方法**
- `IndicatorResult compute(IndicatorComputeRequest req, BarSeriesView series)`

**规则**
- series 的时间戳语义已是 bar_close_time
- 不暴露 ta4j 类型到外层

**验收**
- 相同输入 -> 相同输出（确定性）
- 异常 -> 返回 INVALID + error

---

## 3.2 CustomEngine（至少一个示例）
- 例如 `SMA(period)` 自研版本
- 用于验证引擎可插拔

---

# 阶段 4：Calculator（BAR_CLOSED 触发）+ 订阅路由

## 4.1 IndicatorCalculator（事件 -> 计算任务）
**类**
- `indicator/calculator/IndicatorCalculator`

**方法**
- `void onBarClosed(BarClosedEvent e)`  // handler：只投递任务，不计算
- `void computeForPairTfBar(long userId, long pairId, String timeframe, LocalDateTime barTime)` // worker执行

**路由**
- 从 subscription 查出该 pair/timeframe 需要哪些指标
- 对每个指标调用对应 engine 计算

**验收**
- 每次 BAR_CLOSED 对该 pair/timeframe 只计算订阅指标
- forming 不触发
- handler 不阻塞行情线程（耗时都在 worker）

**测试**
- mock subscription 返回2个指标 -> 只算2个
- handler 执行时间 < 1ms（本地粗测）

---

# 阶段 5：落库闭环（value + calc_log）+ 幂等/冲突

## 5.1 落库写入顺序（冻结）
每个指标计算一次必须写：
1) calc_log（SUCCESS/FAILED/SKIPPED）必写
2) SUCCESS 时写 indicator_value（insert ignore）

> 若 insert ignore 结果为 ignored，则执行冲突检测（可选但推荐）：
- 查出已存在记录，与本次 calc_fingerprint/value 对比
- 不同 -> 写 FAILED(CONFLICT) 日志 + metrics

---

## 5.2 需要实现的写入方法
**类**
- `indicator/repository/impl/IndicatorValueRepositoryImpl`
  - `WriteResult insertIgnore(IndicatorValueDO v)`
- `indicator/repository/impl/IndicatorCalcLogRepositoryImpl`
  - `void append(IndicatorCalcLogDO log)`

**冲突检测实现（推荐最低限）**
- ignored 时：
  - `SELECT value, extra_values, calc_fingerprint FROM indicator_value WHERE unique_key...`
  - 若不同 -> 追加一条 `indicator_calc_log(status=FAILED,error_msg=CONFLICT)`
  - 不覆盖原值

**验收**
- 同一 bar_time 重放不会产生重复 indicator_value
- 冲突时不会覆盖，但能看到 FAILED(CONFLICT) 的 calc_log

**测试**
- 先插入一条 value
- 再插入同 key 不同 value -> value 不变 + 新增 calc_log FAILED(CONFLICT)

---

# 阶段 6：可观测性（metrics + 结构化日志）

## 6.1 指标
- cost_ms P50/P95/P99
- fail_count
- conflict_count
- subscription_enabled_count

## 6.2 日志字段（结构化）
必须包含：
- user_id, trading_pair_id, symbol, timeframe, bar_time
- indicator_code, version, engine, cost_ms, data_quality
- calc_fingerprint
- error_msg（失败时）

**验收**
- 可通过日志定位某次计算、某次冲突
- metrics 可在本地暴露 /actuator/prometheus（如有）

---

# 阶段 7：只读 API（给策略阶段2使用）

## 7.1 API
- `GET /api/indicator/latest?userId=&pairId=&timeframe=&code=`
  - 从 MySQL indicator_value 取最新一条（按 bar_time desc limit 1）

**验收**
- 能查询到刚写入的指标值
- 不触发计算（只读）

---

# 交付验收（最终闭环）

必须能演示：
1) subscription 配置启用某 pair/timeframe + 指标
2) BarClosedEvent 到来
3) 计算被触发（calc_log出现 SUCCESS）
4) indicator_value 出现一条对应记录
5) API 能查询到 latest 指标值
6) 重放事件不重复插入，冲突会记录 FAILED(CONFLICT)

---
