# 指标模块 V2 版本 - 新手程序员入门指南

> **目标读者**：刚接触指标模块的新手程序员  
> **版本**：V2.0  
> **最后更新**：2024-01

---

## 📚 目录

1. [什么是指标模块？](#什么是指标模块)
2. [V1 版本的问题](#v1-版本的问题)
3. [V2 版本的设计理念](#v2-版本的设计理念)
4. [核心概念理解](#核心概念理解)
5. [架构设计](#架构设计)
6. [如何使用](#如何使用)
7. [常见问题解答](#常见问题解答)
8. [学习路径建议](#学习路径建议)

---

## 什么是指标模块？

### 1.1 通俗理解

想象你在做股票交易，你需要判断什么时候买入、什么时候卖出。

**指标（Indicator）** 就像是一个"工具"，帮你分析市场数据，得出一个数值。

**举个例子**：
- **RSI 指标**：告诉你当前是"超买"还是"超卖"（数值 0-100）
- **MACD 指标**：告诉你趋势是向上还是向下
- **移动平均线（SMA）**：告诉你价格的平均水平

### 1.2 在系统中的作用

```
市场数据（K线） → 指标模块 → 指标值 → 策略模块 → 交易决策
```

**指标模块的职责**：
- 接收 K 线数据（开盘价、收盘价、最高价、最低价、成交量）
- 根据指标公式计算指标值
- 把计算结果提供给策略模块使用

---

## V1 版本的问题

### 2.1 原来的设计（V1.2）

原来的系统是这样工作的：

```
K线闭合 → 自动计算所有指标 → 存到数据库 → 策略模块查询
```

**问题在哪里？**

1. **浪费计算资源**
   - 即使没人用某个指标，系统也会计算它
   - 假设有 100 个指标，但策略只用 5 个，另外 95 个都在浪费 CPU

2. **数据库压力大**
   - 每个指标值都要存到数据库
   - 假设 10 个交易对 × 5 个周期 × 100 个指标 = 5000 条/根 K线
   - 一天下来就是几十万条数据

3. **灵活性差**
   - 用户想测试不同的参数（比如 RSI 用 14 天还是 21 天），需要预先配置
   - 临时调整参数很麻烦

### 2.2 打个比方

**V1 就像餐厅**：
- 不管客人点什么，所有菜都先做好
- 客人来了只能吃已经做好的菜
- 想换个口味？抱歉，菜单上没有

**V2 就像点餐制**：
- 客人点什么，厨师做什么
- 同样一道菜，可以做不同的口味
- 想吃啥点啥，灵活方便

---

## V2 版本的设计理念

### 3.1 核心思想

> **"按需计算，缓存复用"**

**两句话理解**：
1. **谁用谁算**：策略需要什么指标，什么时候算
2. **同样的东西算一次**：相同参数的结果缓存起来，下次直接用

### 3.2 三大变化

#### 变化 1：不再自动计算

**V1**：K线一闭合，所有指标自动算
```
K线闭合 → 计算指标1 → 计算指标2 → ... → 计算指标100 → 存数据库
```

**V2**：K线一闭合，只更新数据，不算指标
```
K线闭合 → 只更新K线数据（不做任何计算）
```

#### 变化 2：按需计算

**V1**：指标值存数据库，策略直接查
```java
// V1：从数据库查
indicatorValue = indicatorValueRepository.findLatest(...);
```

**V2**：策略需要时，调用评估接口
```java
// V2：按需计算
result = indicatorEvaluateService.evaluate(
    "RSI", "v1", 
    params, 
    context
);
```

#### 变化 3：单表设计

**V1**：4 张表
- `indicator_definition`（指标定义）
- `indicator_value`（指标值）
- `indicator_subscription`（指标订阅）
- `indicator_calc_log`（计算日志）

**V2**：1 张表
- `indicator_definition`（指标定义）
- 指标值不存数据库，只归档到策略模块的 `strategy_rules_record`

---

## 核心概念理解

### 4.1 指标定义（Indicator Definition）

**什么是指标定义？**

就像"菜谱"，定义了：
- 这道菜叫什么名字？（指标名称）
- 需要什么食材？（参数：比如 RSI 的周期 14）
- 怎么做？（计算公式：由计算引擎实现）
- 做出来是什么样？（返回值：比如 RSI 返回 0-100 的数值）

**代码示例**：
```java
IndicatorDefinition definition = IndicatorDefinition.builder()
    .indicatorCode("RSI")
    .indicatorVersion("v1")
    .indicatorName("相对强弱指标")
    .paramSchema("{\"period\": {\"type\": \"integer\", \"default\": 14}}")  // 参数定义
    .implKey("ta4j:rsi")  // 实现映射键
    .build();
```

### 4.2 评估上下文（Evaluation Context）

**什么是上下文？**

就像做菜时的"环境"：
- 在哪家餐厅做？（交易对：BTC-USDT）
- 什么时候做？（K线时间：2024-01-01 12:00）
- 用什么周期？（时间周期：1小时）

**代码示例**：
```java
EvaluationContext context = EvaluationContext.builder()
    .userId(1L)
    .tradingPairId(1L)      // BTC-USDT
    .timeframe("1h")        // 1小时周期
    .asOfBarTime(LocalDateTime.of(2024, 1, 1, 12, 0))  // K线时间
    .build();
```

### 4.3 评估请求（Evaluation Request）

**什么是评估请求？**

就是"我要计算什么"：
- 算哪个指标？（RSI）
- 用哪个版本？（v1）
- 参数是什么？（period=14）

**代码示例**：
```java
EvaluationRequest request = EvaluationRequest.builder()
    .indicatorCode("RSI")
    .indicatorVersion("v1")
    .params(Map.of("period", 14))  // 参数：周期14天
    .build();
```

### 4.4 评估结果（Evaluation Result）

**什么是评估结果？**

就是"算出来的结果"：
- 值是多少？（value: 65.5）
- 是否有效？（valid: true，数据足够）
- 从哪里来的？（source: CACHE/COMPUTED，缓存还是新算的）
- 花了多长时间？（costMs: 5，5毫秒）

**代码示例**：
```java
IndicatorEvaluateResult result = IndicatorEvaluateResult.builder()
    .valid(true)
    .source("CACHE")  // 来自缓存
    .values(Map.of("value", 65.5))
    .fingerprint("abc123...")  // 计算指纹
    .costMs(1)  // 1毫秒（缓存很快）
    .build();
```

### 4.5 缓存（Cache）

**什么是缓存？**

就像"备用菜"：
- 同样的订单（相同的参数），不需要重新做
- 直接端出之前做好的

**缓存键（Cache Key）**：
```
RSI:v1:1:1h:2024-01-01T12:00:00:period=14
 ↑   ↑  ↑  ↑        ↑               ↑
指标 版本 交易对 周期   K线时间       参数
```

**如果缓存键相同，说明参数完全相同，直接用缓存结果！**

---

## 架构设计

### 5.1 整体架构

```
┌─────────────────────────────────────────────────────┐
│                    API 层                            │
│  IndicatorEvaluateController（评估接口）              │
│  IndicatorDefinitionController（定义管理）            │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                  业务层                              │
│  IndicatorEvaluateService（评估服务，协调者）         │
│    ├── IndicatorParamValidator（参数校验）           │
│    ├── IndicatorCacheManager（缓存管理）             │
│    └── IndicatorEngineRouter（引擎路由）             │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                  数据层                              │
│  IndicatorDefinitionRepository（指标定义）            │
│  BarSeriesManager（K线数据管理）                     │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                  计算引擎                            │
│  Ta4jIndicatorEngine（ta4j库实现）                   │
│  CustomIndicatorEngine（自定义实现）                  │
└─────────────────────────────────────────────────────┘
```

### 5.2 核心组件职责

#### 5.2.1 IndicatorEvaluateService（评估服务）

**职责**：协调整个评估流程（就像一个"项目经理"）

**工作流程**：
```java
public IndicatorEvaluateResult evaluate(...) {
    // 1. 参数校验（找 IndicatorParamValidator）
    paramValidator.validate(...);
    
    // 2. 查缓存（找 IndicatorCacheManager）
    if (缓存命中) {
        return 缓存结果;
    }
    
    // 3. 获取指标定义（找 IndicatorDefinitionRepository）
    IndicatorDefinition def = definitionRepository.find(...);
    
    // 4. 获取K线数据（找 BarSeriesManager）
    BarSeriesView series = barSeriesManager.getSeries(...);
    
    // 5. 路由到计算引擎（找 IndicatorEngineRouter）
    IndicatorEngine engine = engineRouter.getEngine(def);
    
    // 6. 执行计算
    IndicatorResult result = engine.compute(...);
    
    // 7. 写入缓存（找 IndicatorCacheManager）
    cacheManager.put(...);
    
    // 8. 返回结果
    return result;
}
```

**关键点**：
- **只做协调，不做业务逻辑**
- 每个子任务都委托给专门的组件

#### 5.2.2 IndicatorParamValidator（参数校验器）

**职责**：检查参数是否正确

**检查内容**：
- 必填参数是否都有？
- 参数类型对不对？（整数、小数、字符串等）
- 参数范围是否合理？（比如周期不能小于 1）
- 参数值是否在允许的枚举里？

**示例**：
```java
// 用户传入的参数
Map<String, Object> params = Map.of("period", 14);

// 校验器检查
paramValidator.validate("RSI", "v1", params);
// ✅ 通过：period=14 是合理的整数
```

#### 5.2.3 IndicatorCacheManager（缓存管理器）

**职责**：管理缓存（查询、存储）

**工作方式**：
```java
// 生成缓存键
String key = "RSI:v1:1:1h:2024-01-01T12:00:00:period=14";

// 查缓存
Optional<IndicatorEvaluateResult> cached = cacheManager.get(key);
if (cached.isPresent()) {
    return cached.get();  // 缓存命中！
}

// 缓存未命中，计算后存入
cacheManager.put(key, result);
```

**好处**：
- 相同的参数，只算一次
- 下次直接用缓存，速度快（< 1ms）

#### 5.2.4 IndicatorEngineRouter（引擎路由）

**职责**：找到正确的计算引擎

**路由规则**：
```java
// 优先用 impl_key（如：ta4j:rsi）
if (definition.getImplKey() != null) {
    return implKeyMap.get(definition.getImplKey());
}

// 回退到 engine 字段（如：ta4j）
return engineMap.get(definition.getEngine());
```

**支持的引擎**：
- **ta4j**：使用 ta4j 库计算（RSI、MACD、SMA 等）
- **custom**：自定义实现

#### 5.2.5 BarSeriesManager（K线数据管理器）

**职责**：管理 K 线数据（只管理，不算指标）

**工作方式**：
```java
// K线闭合时
public void onBarClosed(BarClosedEvent event) {
    // 1. 接收新K线
    // 2. 追加到内存中的Series
    // 3. 维护最新365根（删除旧的）
    // ❌ 不计算任何指标！
}
```

**关键点**：
- **只维护数据，不触发计算**
- V2 版本的核心变化之一

---

## 如何使用

### 6.1 基本使用流程

#### 步骤 1：定义指标（如果还没有）

```java
// 通过 API 创建指标定义
POST /api/indicator/definitions
{
    "indicatorCode": "RSI",
    "indicatorVersion": "v1",
    "indicatorName": "相对强弱指标",
    "paramSchema": {
        "period": {
            "type": "integer",
            "required": true,
            "default": 14,
            "min": 1,
            "max": 100
        }
    },
    "implKey": "ta4j:rsi"
}
```

#### 步骤 2：调用评估接口

```java
// 方式1：通过 REST API
POST /api/indicator/evaluate
{
    "userId": 1,
    "tradingPairId": 1,
    "timeframe": "1h",
    "asOfBarTime": "2024-01-01T12:00:00",
    "indicatorCode": "RSI",
    "indicatorVersion": "v1",
    "params": {
        "period": 14
    }
}

// 返回
{
    "code": 200,
    "data": {
        "valid": true,
        "source": "COMPUTED",  // 第一次计算
        "values": {
            "value": 65.5
        },
        "fingerprint": "abc123...",
        "costMs": 5
    }
}
```

#### 步骤 3：再次调用（缓存命中）

```java
// 相同参数再次调用
POST /api/indicator/evaluate
{
    "userId": 1,
    "tradingPairId": 1,
    "timeframe": "1h",
    "asOfBarTime": "2024-01-01T12:00:00",  // 相同时间
    "indicatorCode": "RSI",
    "indicatorVersion": "v1",
    "params": {
        "period": 14  // 相同参数
    }
}

// 返回（从缓存获取）
{
    "code": 200,
    "data": {
        "valid": true,
        "source": "CACHE",  // 来自缓存！
        "values": {
            "value": 65.5
        },
        "fingerprint": "abc123...",
        "costMs": 1  // 更快（< 1ms）
    }
}
```

### 6.2 在 Java 代码中使用

```java
@Service
public class MyStrategyService {
    
    @Autowired
    private IndicatorEvaluateService evaluateService;
    
    public void checkRSI() {
        // 1. 构建上下文
        EvaluationContext context = EvaluationContext.builder()
            .userId(1L)
            .tradingPairId(1L)
            .timeframe("1h")
            .asOfBarTime(LocalDateTime.now())
            .build();
        
        // 2. 构建请求
        Map<String, Object> params = Map.of("period", 14);
        
        // 3. 调用评估
        IndicatorEvaluateResult result = evaluateService.evaluate(
            "RSI", "v1", params, context
        );
        
        // 4. 使用结果
        if (result.isValid()) {
            Double rsiValue = (Double) result.getValues().get("value");
            if (rsiValue > 70) {
                System.out.println("RSI超买，考虑卖出");
            } else if (rsiValue < 30) {
                System.out.println("RSI超卖，考虑买入");
            }
        }
    }
}
```

### 6.3 批量评估

```java
// 一次性计算多个指标
EvaluationContext context = ...;

List<EvaluationRequest> requests = Arrays.asList(
    new EvaluationRequest("RSI", "v1", Map.of("period", 14)),
    new EvaluationRequest("MACD", "v1", Map.of("fast", 12, "slow", 26))
);

List<IndicatorEvaluateResult> results = evaluateService.evaluateBatch(
    context, requests
);

// 处理结果
for (int i = 0; i < results.size(); i++) {
    IndicatorEvaluateResult result = results.get(i);
    System.out.println("指标" + i + ": " + result.getValues());
}
```

---

## 常见问题解答

### 7.1 为什么不再自动计算？

**问题**：为什么 V2 不自动计算指标了？

**回答**：
- **节省资源**：大多数指标可能用不到，自动计算是浪费
- **提高灵活性**：用户可以随时调整参数，不需要预先配置
- **降低数据库压力**：不存指标值到数据库，减少存储和查询压力

### 7.2 缓存会不会有数据不一致？

**问题**：缓存会不会导致看到旧数据？

**回答**：
- **缓存键包含 K 线时间**：不同的 K 线时间，缓存键不同
- **缓存有 TTL**：默认 1 小时过期，自动清理
- **关键点**：缓存是性能优化，不是功能依赖

### 7.3 如何添加新指标？

**问题**：我想添加一个新的指标，怎么做？

**回答**：

**方式1：使用已有的引擎（推荐）**
```java
// 如果 ta4j 库已经支持，直接创建定义
POST /api/indicator/definitions
{
    "indicatorCode": "MY_RSI",
    "implKey": "ta4j:rsi",  // 使用 ta4j 的 RSI 实现
    "paramSchema": {...}
}
```

**方式2：自定义实现**
```java
// 1. 实现 IndicatorEngine 接口
@Component("myCustomEngine")
public class MyCustomEngine implements IndicatorEngine {
    @Override
    public IndicatorResult compute(...) {
        // 实现计算逻辑
    }
}

// 2. 创建指标定义，指定 engine="myCustomEngine"
POST /api/indicator/definitions
{
    "indicatorCode": "MY_CUSTOM",
    "engine": "myCustomEngine",
    "paramSchema": {...}
}
```

### 7.4 性能如何？

**问题**：按需计算会不会很慢？

**回答**：
- **缓存命中**：< 1ms（直接从内存读取）
- **缓存未命中**：< 100ms（单指标计算）
- **批量评估**：吞吐提升 > 2倍（多个指标共享数据）

### 7.5 如何调试？

**问题**：如何查看指标计算的过程？

**回答**：

**方法1：查看日志**
```java
// 日志会记录：
// - 缓存命中/未命中
// - 计算耗时
// - 错误信息
```

**方法2：使用前端页面**
```
http://localhost:8080/indicator/evaluate.html
```
- 可以选择指标、参数、交易对
- 实时查看计算结果
- 显示 source 字段（CACHE/COMPUTED）

**方法3：查看 Metrics**
```
http://localhost:8080/actuator/prometheus
```
- `indicator_cache_hits_total`：缓存命中次数
- `indicator_evaluate_cost_ms`：评估耗时

### 7.6 如果缓存失效怎么办？

**问题**：缓存失效会不会导致功能异常？

**回答**：
- **不会**！缓存只是性能优化，不是功能依赖
- 缓存失效时，系统会自动重新计算
- 功能完全正常，只是稍慢一点

---

## 学习路径建议

### 8.1 第一阶段：理解概念（1-2天）

1. **阅读本文档**：理解核心概念
2. **查看代码示例**：运行示例代码
3. **画流程图**：画出评估流程

**学习目标**：
- 理解 V2 的设计理念
- 理解核心组件的作用

### 8.2 第二阶段：动手实践（3-5天）

1. **调用 API**：使用 Postman 或 curl 调用评估接口
2. **阅读代码**：从 `IndicatorEvaluateService` 开始读
3. **修改参数**：尝试不同的参数组合
4. **观察缓存**：查看缓存命中/未命中

**学习目标**：
- 能够独立调用评估接口
- 理解代码执行流程

### 8.3 第三阶段：深入理解（1周）

1. **阅读源码**：深入理解各个组件
2. **添加指标**：尝试添加一个新的指标
3. **性能测试**：编写压测脚本
4. **查看 Metrics**：理解监控指标

**学习目标**：
- 能够扩展指标模块
- 能够排查问题

### 8.4 推荐阅读顺序

1. **本文档**（新手入门指南）✅
2. `指标模块总体设计.md`（架构设计）
3. `指标V2分阶段开发执行计划.md`（开发计划）
4. `指标v2版本重构产品规范.md`（产品规范）

### 8.5 关键代码文件

**核心服务**：
- `IndicatorEvaluateService.java`（评估服务）
- `IndicatorParamValidator.java`（参数校验）
- `IndicatorCacheManager.java`（缓存管理）
- `IndicatorEngineRouter.java`（引擎路由）

**API 接口**：
- `IndicatorEvaluateController.java`（评估接口）
- `IndicatorDefinitionController.java`（定义管理）

**数据模型**：
- `EvaluationContext.java`（评估上下文）
- `EvaluationRequest.java`（评估请求）
- `IndicatorEvaluateResult.java`（评估结果）

---

## 总结

### 核心要点

1. **V2 的核心思想**：按需计算，缓存复用
2. **三大变化**：
   - 不再自动计算
   - 按需评估
   - 单表设计
3. **关键组件**：
   - `IndicatorEvaluateService`：协调者
   - `IndicatorCacheManager`：缓存管理
   - `IndicatorParamValidator`：参数校验
   - `IndicatorEngineRouter`：引擎路由

### 记住三句话

1. **谁用谁算**：策略需要时才计算
2. **同样的只算一次**：相同参数结果缓存
3. **只维护数据**：K线闭合只更新数据，不算指标

### 下一步

- 运行示例代码
- 阅读核心源码
- 尝试添加指标
- 参与项目开发

---

**文档版本**：V2.0  
**最后更新**：2024-01  
**维护者**：qyl

**有问题？欢迎提问！** 🤔

