# 指标模块架构说明（新手入门）

> 本文档帮助新手理解指标模块的整体架构、数据流转和业务流程

## 📚 目录

1. [模块概述](#模块概述)
2. [目录结构](#目录结构)
3. [核心概念](#核心概念)
4. [数据流转](#数据流转)
5. [业务流程详解](#业务流程详解)
6. [关键组件说明](#关键组件说明)
7. [数据库表说明](#数据库表说明)

---

## 模块概述

**指标模块**是一个事件驱动的技术指标计算系统，它的核心职责是：

1. **监听K线闭合事件**：当一根K线（Bar）完成时，触发指标计算
2. **加载历史数据**：从QuestDB加载历史K线数据，构建时间序列
3. **计算技术指标**：根据用户订阅的指标，使用不同引擎（如ta4j）进行计算
4. **持久化结果**：将计算结果存储到MySQL，支持幂等写入和冲突检测
5. **提供查询接口**：为策略模块提供只读API，查询最新指标值

### 关键特性

- ✅ **事件驱动**：基于`BarClosedEvent`触发计算，不轮询
- ✅ **异步处理**：计算过程不阻塞行情线程
- ✅ **幂等写入**：支持事件重放，不会重复写入相同值
- ✅ **可观测性**：集成Metrics和结构化日志
- ✅ **可扩展**：支持多种计算引擎（ta4j、自定义引擎）

---

## 目录结构

```
indicator/
├── api/                          # API层（对外接口）
│   ├── dto/                      # 数据传输对象
│   │   └── IndicatorValueDTO.java    # 指标值响应DTO
│   └── IndicatorController.java      # 只读API控制器（阶段7）
│
├── bootstrap/                    # 启动初始化
│   ├── IndicatorBootstrapListener.java  # 监听应用启动，触发初始化
│   └── IndicatorBootstrapper.java      # 注册内置指标定义（阶段2）
│
├── calculator/                   # 计算核心（阶段4）
│   ├── IndicatorCalculator.java        # 指标计算器（核心）
│   └── IndicatorEngineRouter.java      # 引擎路由器
│
├── config/                       # 配置类
│   └── IndicatorEngineConfig.java      # 引擎自动注册配置
│
├── definition/                   # 指标定义（阶段2）
│   ├── builtin/
│   │   └── BuiltinIndicatorDefinitions.java  # 内置指标定义（RSI、MACD等）
│   ├── impl/
│   │   ├── SimpleIndicatorDefinition.java    # 指标定义实现
│   │   └── SimpleIndicatorRegistry.java      # 内存注册表
│   ├── IndicatorDefinition.java              # 指标定义接口
│   ├── IndicatorRegistry.java                # 注册表接口
│   ├── IndicatorCategory.java                # 指标分类枚举
│   ├── ParameterSpec.java                    # 参数规范
│   └── ReturnSpec.java                       # 返回值规范
│
├── domain/                       # 领域模型（阶段0）
│   ├── event/                               # 领域事件
│   │   ├── BarClosedEvent.java                 # K线闭合事件
│   │   ├── BarClosedEventPublisher.java        # 事件发布器接口
│   │   ├── BarEventType.java                   # 事件类型枚举
│   │   └── impl/
│   │       └── SimpleBarClosedEventPublisher.java  # 事件发布器实现
│   └── model/
│       └── NormalizedBar.java                   # 归一化Bar模型
│
├── engine/                       # 计算引擎（阶段3）
│   ├── custom/
│   │   └── SimpleSmaEngine.java            # 自定义SMA引擎示例
│   ├── ta4j/
│   │   └── Ta4jIndicatorEngine.java        # ta4j引擎实现
│   ├── IndicatorEngine.java                # 引擎接口
│   ├── IndicatorComputeRequest.java        # 计算请求模型
│   └── IndicatorResult.java                # 计算结果模型
│
├── infrastructure/               # 基础设施（阶段0）
│   ├── converter/
│   │   └── AggregatedKLineToBarClosedEventConverter.java  # K线聚合结果转事件
│   ├── resolver/
│   │   ├── impl/
│   │   │   └── DefaultTradingPairResolver.java      # 交易对解析器
│   │   └── TradingPairResolver.java                 # 解析器接口
│   └── time/
│       ├── QuestDbTsSemanticsProbe.java           # QuestDB时间语义探针
│       ├── QuestDbTsSemantics.java                # 时间语义枚举
│       ├── TimeAlignmentAdapter.java              # 时间对齐适配器接口
│       ├── KlineEventAdapter.java                 # K线事件适配器
│       └── QuestDbAdapter.java                    # QuestDB适配器
│
├── observability/                # 可观测性（阶段6）
│   ├── IndicatorMetrics.java                     # Metrics定义
│   └── SubscriptionMetricsUpdater.java           # 订阅Metrics更新器
│
├── persistence/                  # 持久化工具（阶段5）
│   └── CalcFingerprint.java                      # 计算指纹生成器
│
├── repository/                   # 数据访问层（阶段0.5）
│   ├── entity/                                   # 实体类
│   │   ├── IndicatorDefinition.java              # 指标定义实体
│   │   ├── IndicatorSubscription.java            # 指标订阅实体
│   │   ├── IndicatorValue.java                   # 指标值实体
│   │   └── IndicatorCalcLog.java                 # 计算日志实体
│   ├── impl/                                     # Repository实现
│   │   ├── IndicatorDefinitionRepositoryImpl.java
│   │   ├── IndicatorSubscriptionRepositoryImpl.java
│   │   ├── IndicatorValueRepositoryImpl.java
│   │   └── IndicatorCalcLogRepositoryImpl.java
│   ├── mapper/                                   # MyBatis Mapper
│   │   ├── IndicatorDefinitionMapper.java
│   │   ├── IndicatorSubscriptionMapper.java
│   │   ├── IndicatorValueMapper.java
│   │   └── IndicatorCalcLogMapper.java
│   ├── IndicatorDefinitionRepository.java        # Repository接口
│   ├── IndicatorSubscriptionRepository.java
│   ├── IndicatorValueRepository.java
│   └── IndicatorCalcLogRepository.java
│
└── series/                       # Bar系列管理（阶段1）
    ├── BarSeriesManager.java                     # Bar系列管理器（核心）
    ├── BarSeriesView.java                        # Bar系列只读视图接口
    └── QuestDbKlineReader.java                   # QuestDB K线读取器
```

---

## 核心概念

### 1. Bar（K线）

一根K线代表一个时间段内的市场数据，包含：
- `open`：开盘价
- `high`：最高价
- `low`：最低价
- `close`：收盘价
- `volume`：成交量
- `barTime`：K线收盘时间（UTC）

### 2. BarClosedEvent（K线闭合事件）

当一根K线完成时，系统会发布`BarClosedEvent`，包含：
- `symbol`：交易对符号（如"BTC-USDT"）
- `timeframe`：周期（如"1h"、"5m"）
- `bar`：完整的Bar数据
- `barCloseTime`：K线收盘时间（UTC）

**这是整个系统的唯一触发源**，所有指标计算都从这里开始。

### 3. Indicator（指标）

一个技术指标的定义，包含：
- `code`：指标编码（如"RSI"、"MACD"）
- `version`：版本号（如"v1"）
- `parameters`：参数（如RSI的period=14）
- `returnSchema`：返回值结构（单值或多值）

### 4. Subscription（订阅）

用户订阅某个交易对、某个周期、某个指标的计算，例如：
- 用户1订阅了"BTC-USDT"的"1h"周期的"RSI"指标

### 5. Engine（计算引擎）

负责实际计算指标的组件，支持多种引擎：
- **ta4j**：基于ta4j库的引擎，支持大多数标准指标
- **custom**：自定义引擎，可以实现特殊计算逻辑

### 6. MarketSubscriptionConfig（行情订阅配置）

定义哪些交易对需要采集行情数据：
- `trading_pair_id`：交易对ID
- `enabled`：是否启用
- **用途**：指标模块从行情订阅配置获取需要维护K线的交易对列表

### 7. 支持的周期

指标模块**只支持以下5个周期**（不包含1m）：
- `5m`：5分钟
- `15m`：15分钟
- `30m`：30分钟
- `1h`：1小时
- `4h`：4小时

**原因**：
- 1m周期数据量太大，不适合指标计算
- 聚合后的周期更稳定，更适合技术分析
- 所有周期都从QuestDB的聚合表（`kline_5m`、`kline_15m`等）读取

---

## 数据流转

### 整体流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                     启动阶段（Bootstrap）                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
        ┌─────────────────────────────────────┐
        │  1. QuestDbTsSemanticsProbe         │
        │     检测QuestDB时间语义              │
        └─────────────────────────────────────┘
                              │
                              ▼
        ┌─────────────────────────────────────┐
        │  2. IndicatorBootstrapper           │
        │     注册内置指标定义（RSI、MACD等）  │
        │     写入 indicator_definition 表    │
        └─────────────────────────────────────┘
                              │
                              ▼
        ┌─────────────────────────────────────┐
        │  3. IndicatorBootstrapListener      │
        │     触发 BarSeriesManager.bootstrap()│
        │     从行情订阅配置获取交易对          │
        │     为每个交易对的5个周期加载历史数据 │
        │     (5m/15m/30m/1h/4h，不包含1m)    │
        │     构建内存中的BarSeries           │
        └─────────────────────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    │   系统就绪，等待事件  │
                    └─────────┬─────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                  运行时阶段（Event-Driven）                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
        ┌─────────────────────────────────────┐
        │  1. K线聚合完成                     │
        │     AggregationConfig 发布           │
        │     BarClosedEvent                  │
        └─────────────────────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    │                    │
                    ▼                    ▼
        ┌──────────────────┐   ┌──────────────────┐
        │ 2a. BarSeries    │   │ 2b. Indicator    │
        │     Manager      │   │     Calculator   │
        │     维护5份K线    │   │     监听事件      │
        │     (5m/15m/     │   │     过滤周期      │
        │      30m/1h/4h)  │   │     (跳过1m)     │
        │     自动维护365根 │   │     异步处理      │
        └──────────────────┘   └──────────────────┘
                                          │
                                          ▼
                            ┌──────────────────────────┐
                            │  3. 查询订阅             │
                            │     IndicatorSubscription│
                            │     Repository           │
                            │     找出需要计算的指标    │
                            └──────────────────────────┘
                                          │
                                          ▼
                            ┌──────────────────────────┐
                            │  4. 对每个订阅：         │
                            │     - 获取共享的BarSeries│
                            │       (K线数据不区分用户)│
                            │     - 从Registry获取定义 │
                            │     - 从Router获取引擎   │
                            │     - 执行计算           │
                            └──────────────────────────┘
                                          │
                                          ▼
                            ┌──────────────────────────┐
                            │  5. 生成计算指纹         │
                            │     CalcFingerprint      │
                            │     (code:version:params)│
                            └──────────────────────────┘
                                          │
                    ┌─────────────────────┴─────────────────────┐
                    │                                           │
                    ▼                                           ▼
        ┌──────────────────────────┐          ┌──────────────────────────┐
        │  6a. 写入计算日志        │          │  6b. 写入指标值          │
        │      indicator_calc_log  │          │      indicator_value     │
        │      (必写)              │          │      (仅成功时)           │
        │      - 状态：SUCCESS/    │          │      - insert ignore     │
        │        FAILED            │          │      - 冲突检测           │
        │      - 耗时              │          │      - 记录冲突日志       │
        │      - 错误信息          │          │                           │
        └──────────────────────────┘          └──────────────────────────┘
                    │                                           │
                    └─────────────────────┬─────────────────────┘
                                          │
                                          ▼
                            ┌──────────────────────────┐
                            │  7. 更新Metrics          │
                            │     - cost_ms (P50/P95)  │
                            │     - fail_count         │
                            │     - conflict_count     │
                            └──────────────────────────┘
                                          │
                                          ▼
                            ┌──────────────────────────┐
                            │  8. 结构化日志           │
                            │     使用MDC记录所有字段   │
                            └──────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                     查询阶段（Read-Only）                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
        ┌─────────────────────────────────────┐
        │  策略模块调用API                     │
        │  GET /api/indicator/latest          │
        └─────────────────────────────────────┘
                              │
                              ▼
        ┌─────────────────────────────────────┐
        │  IndicatorController                │
        │  查询最新指标值                      │
        └─────────────────────────────────────┘
                              │
                              ▼
        ┌─────────────────────────────────────┐
        │  IndicatorValueRepository           │
        │  findLatest()                       │
        │  (按 bar_time desc limit 1)         │
        └─────────────────────────────────────┘
                              │
                              ▼
        ┌─────────────────────────────────────┐
        │  返回 IndicatorValueDTO             │
        │  给策略模块使用                      │
        └─────────────────────────────────────┘
```

---

## 业务流程详解

### 场景1：系统启动流程

**目标**：初始化系统，加载历史数据

1. **时间语义检测**（`QuestDbTsSemanticsProbe`）
   - 应用启动时，自动检测QuestDB的`ts`字段是开盘时间还是收盘时间
   - 将结果保存在内存中，供后续适配器使用
   - 如果检测失败，系统无法启动（fail fast）

2. **注册内置指标**（`IndicatorBootstrapper`）
   - 读取`BuiltinIndicatorDefinitions`中定义的10个内置指标
   - 注册到内存中的`IndicatorRegistry`
   - 持久化到`indicator_definition`表（`user_id=0`表示系统内置）
   - 如果已存在，自动忽略（去重）

3. **加载历史数据**（`BarSeriesManager.bootstrap()`）
   - **从行情订阅配置获取交易对**：查询`market_subscription_config`表，获取所有启用的交易对
   - **为每个交易对的5个周期加载K线**：对每个交易对，为5个周期（5m、15m、30m、1h、4h）都加载最近365根历史K线
     - 从QuestDB对应的聚合表加载（`kline_5m`、`kline_15m`等，不加载`kline_1m`）
     - 转换为`NormalizedBar`（统一时间语义）
     - 构建内存中的`BarSeries`（按时间排序）
   - **K线数据独立维护**：K线维护与指标订阅解耦，确保基础数据始终可用
   - 订阅`BarClosedEvent`，准备接收实时数据

### 场景2：K线闭合触发计算

**目标**：当一根K线完成时，计算所有订阅的指标

1. **事件发布**（`AggregationConfig`）
   - K线聚合完成后，发布`BarClosedEvent`
   - 事件包含：symbol、timeframe、bar数据、barCloseTime

2. **事件接收**（`BarSeriesManager` + `IndicatorCalculator`）
   - **BarSeriesManager**：接收事件，将Bar追加到对应的内存Series（去重）
     - 自动维护对应周期（5m、15m、30m、1h、4h）的K线数据
     - 如果BarSeries不存在，动态创建（支持运行时添加新交易对）
     - 自动维护最新365根，去除最旧的（防止内存泄漏）
   - **IndicatorCalculator**：接收事件，异步触发计算流程
     - 只处理支持的周期（5m、15m、30m、1h、4h），跳过1m事件

3. **查询订阅**（`IndicatorSubscriptionRepository`）
   - 根据`trading_pair_id`和`timeframe`查询所有启用的订阅
   - 按`user_id`分组（支持多租户）

4. **计算指标**（对每个用户的每个订阅）
   - 获取该订阅的`BarSeries`
   - 从`IndicatorRegistry`获取指标定义（参数、返回值结构等）
   - 从`IndicatorEngineRouter`获取对应的计算引擎
   - 构造`IndicatorComputeRequest`，调用引擎计算
   - 引擎返回`IndicatorResult`（成功/失败、单值/多值）

5. **生成指纹**（`CalcFingerprint`）
   - 将`code:version:params:engine`拼接，计算SHA-256哈希
   - 用于唯一标识一次计算配置（用于冲突检测）

6. **持久化结果**
   - **写入日志**（必写）：
     - 状态：SUCCESS / FAILED
     - 耗时、错误信息等
   - **写入值**（仅成功时）：
     - 使用`insert ignore`，如果已存在相同key则忽略
     - 如果被忽略，执行冲突检测：
       - 查询已存在的记录
       - 比较指纹和值
       - 如果不同，写入FAILED(CONFLICT)日志
       - **不覆盖原值**（保证数据一致性）

7. **记录Metrics和日志**
   - 更新`cost_ms`的Timer（自动计算P50/P95/P99）
   - 更新`fail_count`或`conflict_count`计数器
   - 使用MDC记录结构化日志（所有关键字段）

### 场景3：策略模块查询指标

**目标**：策略模块需要最新的指标值进行决策

1. **API调用**
   ```
   GET /api/indicator/latest?userId=1&pairId=1&timeframe=1h&code=RSI&version=v1
   ```

2. **查询数据库**
   - `IndicatorValueRepository.findLatest()`
   - SQL：`SELECT * FROM indicator_value WHERE ... ORDER BY bar_time DESC LIMIT 1`

3. **返回结果**
   - 转换为`IndicatorValueDTO`
   - 封装为`Result<IndicatorValueDTO>`
   - 如果不存在，返回`null`（不报错）

**关键点**：
- ✅ **只读操作**：不会触发计算
- ✅ **查询已计算好的值**：从MySQL读取
- ✅ **最新值**：按`bar_time desc`排序，取第一条

---

## 关键组件说明

### 1. IndicatorCalculator（核心计算器）

**职责**：
- 监听`BarClosedEvent`
- 异步处理计算任务（不阻塞事件线程）
- 协调整个计算流程

**关键方法**：
```java
@Async("indicatorCalculatorExecutor")
public void onBarClosed(BarClosedEvent event) {
    // 1. 查询订阅
    // 2. 对每个订阅调用 computeForPairTfBar()
}

private void computeForPairTfBar(...) {
    // 1. 获取BarSeries
    // 2. 查询该用户的订阅指标
    // 3. 对每个指标调用 computeIndicator()
}

private void computeIndicator(...) {
    // 1. 执行计算
    // 2. 生成指纹
    // 3. 写入日志和值
    // 4. 记录Metrics和日志
}
```

### 2. BarSeriesManager（Bar系列管理器）

**职责**：
- 管理内存中的`BarSeries`（每个pair+timeframe一个）
- 启动时从QuestDB加载历史数据
- 实时追加新的Bar（去重）

**关键方法**：
```java
public void bootstrap() {
    // 启动时：从行情订阅配置获取交易对
    // 为每个交易对的5个周期（5m、15m、30m、1h、4h）都加载历史数据
    // K线维护独立于指标订阅
}

public void onBarClosed(BarClosedEvent event) {
    // 实时：追加Bar到对应的Series
    // 自动维护最新365根，去除最旧的
    // 支持动态创建BarSeries（新交易对）
}

public BarSeriesView getSeries(long pairId, String timeframe) {
    // 获取只读视图（K线数据是共享的，不区分用户）
}
```

### 3. IndicatorEngine（计算引擎接口）

**职责**：
- 定义统一的计算接口
- 支持多种实现（ta4j、custom）

**关键方法**：
```java
IndicatorResult compute(IndicatorComputeRequest request);
```

**实现**：
- `Ta4jIndicatorEngine`：基于ta4j库，支持标准指标
- `SimpleSmaEngine`：自定义SMA实现示例

### 4. IndicatorValueRepository（指标值仓库）

**职责**：
- 提供指标值的持久化接口
- 实现幂等写入（`insert ignore`）
- 冲突检测

**关键方法**：
```java
WriteResult insertIgnore(IndicatorValue value);
Optional<IndicatorValue> findLatest(...);  // 阶段7新增
Optional<IndicatorValue> findOneKey(...);  // 冲突检测用
```

### 5. IndicatorRegistry（指标注册表）

**职责**：
- 内存中管理所有指标定义
- 启动时从数据库加载
- 提供查询接口

**关键方法**：
```java
void register(IndicatorDefinition definition);
Optional<IndicatorDefinition> get(String code, String version);
```

---

## 数据库表说明

### 1. indicator_definition（指标定义表）

**作用**：存储指标的定义信息

**关键字段**：
- `user_id`：0表示系统内置，其他表示用户自定义
- `indicator_code`：指标编码（如"RSI"）
- `indicator_version`：版本号（如"v1"）
- `parameters`：参数JSON（如`{"period": 14}`）
- `return_schema`：返回值结构JSON

**唯一索引**：`(user_id, indicator_code, indicator_version)`

### 2. indicator_subscription（指标订阅表）

**作用**：存储用户订阅的指标配置

**关键字段**：
- `user_id`：用户ID
- `trading_pair_id`：交易对ID
- `timeframe`：周期
- `indicator_code`：指标编码
- `indicator_version`：版本号
- `parameters`：参数JSON（覆盖默认参数）
- `enabled`：是否启用

**唯一索引**：`(user_id, trading_pair_id, timeframe, indicator_code, indicator_version)`

### 3. indicator_value（指标值表）

**作用**：存储计算好的指标值

**关键字段**：
- `user_id`：用户ID
- `trading_pair_id`：交易对ID
- `timeframe`：周期
- `bar_time`：K线收盘时间（UTC）
- `indicator_code`：指标编码
- `indicator_version`：版本号
- `value`：单值指标结果
- `extra_values`：多值指标结果（JSON）
- `data_quality`：数据质量（OK/WARN/ERROR）
- `calc_engine`：计算引擎（ta4j/custom）
- `calc_cost_ms`：计算耗时（毫秒）

**唯一索引**：`(user_id, trading_pair_id, timeframe, bar_time, indicator_code, indicator_version)`

**幂等性**：使用`insert ignore`，相同key不会重复插入

### 4. indicator_calc_log（计算日志表）

**作用**：记录每次计算的详细日志（审计用）

**关键字段**：
- `user_id`：用户ID
- `trading_pair_id`：交易对ID
- `timeframe`：周期
- `bar_time`：K线收盘时间
- `indicator_code`：指标编码
- `calc_status`：计算状态（SUCCESS/FAILED/CONFLICT）
- `calc_fingerprint`：计算指纹（SHA-256）
- `cost_ms`：计算耗时
- `error_msg`：错误信息

**特点**：
- **追加写入**：不会更新，只追加
- **完整记录**：无论成功失败都记录

---

## 关键设计决策

### 1. 为什么使用事件驱动？

- ✅ **解耦**：指标模块不依赖K线聚合的具体实现
- ✅ **实时性**：K线一完成就触发计算，无需轮询
- ✅ **可扩展**：未来可以监听其他事件源

### 2. 为什么使用异步处理？

- ✅ **性能**：计算耗时，不阻塞事件线程
- ✅ **隔离**：使用独立线程池，不影响其他业务
- ✅ **可监控**：可以单独监控计算线程池的状态

### 3. 为什么需要幂等写入？

- ✅ **事件重放**：支持事件系统的重放机制
- ✅ **数据一致性**：避免并发导致的数据冲突
- ✅ **故障恢复**：系统重启后不会重复计算

### 4. 为什么需要计算指纹？

- ✅ **冲突检测**：识别相同key但不同计算参数的情况
- ✅ **审计追踪**：记录每次计算的具体配置
- ✅ **调试支持**：快速定位问题

### 5. 为什么分离日志和值？

- ✅ **审计需求**：所有计算都要记录日志（包括失败）
- ✅ **性能优化**：值表可以定期清理旧数据，日志表保留更久
- ✅ **查询优化**：值表有唯一索引，查询更快

---

## 常见问题

### Q1: 如果事件丢失了怎么办？

A: 指标值使用唯一索引，即使事件重放也不会重复写入。日志会记录所有计算尝试，可以通过日志恢复。

### Q2: 如何添加新的指标？

A: 两种方式：
1. **系统内置**：在`BuiltinIndicatorDefinitions`中添加定义，重启后自动注册
2. **用户自定义**：通过API或直接插入`indicator_definition`表（`user_id`不为0）

### Q3: 如何添加新的计算引擎？

A: 
1. 实现`IndicatorEngine`接口
2. 添加`@Component`注解，指定`engineName`
3. `IndicatorEngineConfig`会自动注册到路由器

### Q4: 内存中的BarSeries会无限增长吗？

A: **不会**。系统会自动维护：
- 启动时加载最近365根K线
- 实时追加新K线时，自动去除最旧的，保持最新365根
- 每个交易对的5个周期各自维护365根
- 如果交易对数量很多，可以配置减少保留数量或使用LRU缓存策略

### Q6: 为什么K线数据不按用户区分？

A: **K线数据是市场数据，对所有用户相同**。同一交易对同一周期的K线，无论哪个用户查看，都应该是一样的。这样可以：
- 节省内存：避免重复存储相同的K线数据
- 提高效率：所有用户共享同一份数据
- 简化维护：只需维护一份数据源

### Q7: 指标模块支持哪些周期？

A: **只支持5个聚合周期**：5m、15m、30m、1h、4h。不支持1m，因为：
- 1m数据量太大，不适合指标计算
- 聚合后的周期更稳定，更适合技术分析
- 所有周期都从QuestDB的聚合表读取

### Q5: 如何监控指标计算性能？

A: 
1. **Metrics**：访问`/actuator/prometheus`查看`calc_cost_ms`的P50/P95/P99
2. **日志**：所有计算都记录结构化日志，包含`cost_ms`
3. **数据库**：`indicator_calc_log`表记录所有计算的耗时

---

## 下一步学习建议

1. **阅读代码**：按照上述流程，从`BarClosedEvent`开始跟踪代码
2. **运行测试**：执行各个阶段的验收测试，理解每个组件的作用
3. **调试实践**：设置断点，观察事件触发后的完整流程
4. **扩展练习**：
   - 添加一个新的内置指标
   - 实现一个自定义计算引擎
   - 修改查询API，支持批量查询

---

## 代码示例

### 示例1：添加一个新的内置指标

```java
// 在 BuiltinIndicatorDefinitions.java 中添加
public static IndicatorDefinition createCustomIndicator() {
    return SimpleIndicatorDefinition.builder()
            .code("MY_INDICATOR")
            .version("v1")
            .name("我的自定义指标")
            .category(IndicatorCategory.TREND)
            .parameters(List.of(
                    ParameterSpec.builder()
                            .name("period")
                            .type("integer")
                            .required(true)
                            .defaultValue("20")
                            .build()
            ))
            .returnSpec(ReturnSpec.builder()
                    .type("SINGLE_VALUE")
                    .valueType("decimal")
                    .build())
            .build();
}
```

### 示例2：实现一个自定义计算引擎

```java
@Component("myCustomEngine")
public class MyCustomEngine implements IndicatorEngine {
    
    @Override
    public String getEngineName() {
        return "myCustomEngine";
    }
    
    @Override
    public IndicatorResult compute(IndicatorComputeRequest request) {
        // 1. 获取参数
        Map<String, String> params = request.getParameters();
        int period = Integer.parseInt(params.getOrDefault("period", "20"));
        
        // 2. 获取BarSeries
        List<NormalizedBar> bars = request.getBarSeries().getBars();
        
        // 3. 执行计算逻辑
        // ... 你的计算代码 ...
        
        // 4. 返回结果
        return IndicatorResult.success(
                BigDecimal.valueOf(resultValue),
                "OK"
        );
    }
}
```

### 示例3：手动触发计算（测试用）

```java
@Autowired
private IndicatorCalculator calculator;

@Autowired
private BarClosedEventPublisher eventPublisher;

public void testCalculation() {
    // 创建测试事件
    NormalizedBar bar = NormalizedBar.builder()
            .symbol("BTC-USDT")
            .timeframe("1h")
            .barTime(LocalDateTime.now())
            .open(BigDecimal.valueOf(50000))
            .high(BigDecimal.valueOf(51000))
            .low(BigDecimal.valueOf(49000))
            .close(BigDecimal.valueOf(50500))
            .volume(BigDecimal.valueOf(100))
            .build();
    
    BarClosedEvent event = new BarClosedEvent(
            1L,  // tradingPairId
            "BTC-USDT",
            "1h",
            bar,
            bar.getBarTime()
    );
    
    // 发布事件（会自动触发计算）
    eventPublisher.publish(event);
}
```

### 示例4：查询指标值的完整流程

```java
// 1. 通过Repository查询
@Autowired
private IndicatorValueRepository valueRepository;

public IndicatorValueDTO getLatestRSI(long userId, long pairId) {
    Optional<IndicatorValue> valueOpt = valueRepository.findLatest(
            userId, pairId, "1h", "RSI", "v1"
    );
    
    if (valueOpt.isEmpty()) {
        return null;
    }
    
    return IndicatorValueDTO.fromEntity(valueOpt.get());
}

// 2. 通过API查询（HTTP调用）
// GET /api/indicator/latest?userId=1&pairId=1&timeframe=1h&code=RSI&version=v1

// 3. 通过MyBatis直接查询
@Autowired
private IndicatorValueMapper mapper;

public IndicatorValue queryByCustomCondition() {
    return mapper.selectOne(
            new LambdaQueryWrapper<IndicatorValue>()
                    .eq(IndicatorValue::getUserId, 1)
                    .eq(IndicatorValue::getIndicatorCode, "RSI")
                    .ge(IndicatorValue::getBarTime, LocalDateTime.now().minusDays(7))
                    .orderByDesc(IndicatorValue::getBarTime)
                    .last("LIMIT 1")
    );
}
```

### 示例5：监控指标计算性能

```java
// 1. 查询Prometheus Metrics
// 访问: http://localhost:8080/actuator/prometheus
// 查找: calc_cost_ms_seconds{...} - 计算耗时
//       calc_failures_total{...} - 失败次数

// 2. 查询计算日志
@Autowired
private IndicatorCalcLogRepository logRepository;

public List<IndicatorCalcLog> getFailedCalculations(long userId) {
    return logRepository.queryRecentFailures(userId, 100);
}

// 3. 查询指标值统计
public Map<String, Long> getIndicatorStats(long userId) {
    // 统计每个指标的最新值数量
    // ...
}
```

---

## 调试技巧

### 1. 启用调试日志

在`application.yml`中：
```yaml
logging:
  level:
    com.qyl.v2trade.indicator: DEBUG
```

### 2. 查看事件发布

在`IndicatorCalculator.onBarClosed()`方法设置断点，观察事件接收。

### 3. 查看计算流程

在`IndicatorCalculator.computeIndicator()`方法设置断点，观察：
- 订阅查询结果
- 引擎计算结果
- 持久化写入结果

### 4. 检查数据库状态

```sql
-- 查看订阅
SELECT * FROM indicator_subscription WHERE enabled = 1;

-- 查看最新计算的指标值
SELECT * FROM indicator_value 
ORDER BY created_at DESC LIMIT 10;

-- 查看失败的计算
SELECT * FROM indicator_calc_log 
WHERE calc_status = 'FAILED' 
ORDER BY created_at DESC LIMIT 10;

-- 查看冲突日志
SELECT * FROM indicator_calc_log 
WHERE calc_status = 'FAILED' AND error_msg LIKE '%CONFLICT%';
```

---

**文档版本**：v1.0  
**最后更新**：2024年  
**维护者**：qyl

