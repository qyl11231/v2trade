# 指标模块工程开发规范 v1.2.2（DB 接入增强 · 最终版）

> 本版本在 v1.2.1 基础上增补 **MySQL 落库四张表** 的工程约束与验收标准。
> v1.2.1 中的时间语义、事件模型、分层架构全部保持不变。
>
> 新增对象：indicator_definition / indicator_subscription / indicator_value / indicator_calc_log

---

## 0. 版本变更摘要（Change Log）

### 新增
- MySQL 指标模块四张表作为指标系统事实与审计来源：
  - `indicator_definition`：指标元数据与参数/返回Schema
  - `indicator_subscription`：指标计算范围订阅配置
  - `indicator_value`：指标事实表（每根bar闭合后的计算结果）
  - `indicator_calc_log`：指标计算运行日志（审计与性能）

### 冻结
- 时间语义仍为：**bar_close_time（UTC）**
- 指标计算触发点仍为：**BarClosedEvent（唯一合法触发点）**
- 指标模块职责边界不变：指标模块不包含策略逻辑、不负责资金/风控/下单

---

## 1. 模块职责边界（强化）

### 1.1 指标模块负责
1) 基于 BarClosedEvent 与 QuestDB 历史K线构建 BarSeries
2) 计算订阅指标，并将结果写入 MySQL
3) 提供只读查询接口给策略阶段2使用
4) 提供审计与性能可观测性（calc_log + metrics）

### 1.2 指标模块不负责（禁止）
- ❌ 决策（入场/出场逻辑属于策略模块）
- ❌ 聚合（聚合由行情中心完成，指标模块只读聚合表）
- ❌ 补拉与校准（由行情校准模块负责）
- ❌ 资金、风控、下单

---

## 2. 数据源与存储（P0）

### 2.1 数据源（只读）
- QuestDB：K线数据（kline_1m, kline_{period}）
- 行情事件：BarClosedEvent（来自行情中心聚合器）

### 2.2 存储（写入）
- MySQL：指标事实与审计（四张表）
- Redis：v1.2.2 仍保持可选，不作为事实源

### 2.3 事实源定义（Source of Truth）
- 指标结果事实源：`indicator_value`（MySQL）
- 指标计算审计事实源：`indicator_calc_log`（MySQL）
- 指标定义事实源：`indicator_definition`
- 指标订阅事实源：`indicator_subscription`

---

## 3. 时间语义与事件模型（P0，继承 v1.2.1）

### 3.1 时间语义（冻结）
- 指标模块内部统一使用 `bar_time = bar_close_time`（UTC）
- 所有输入必须经过 TimeAlignmentAdapter 归一化
- **禁止** 在指标计算/存储/查询中出现多语义混用

### 3.2 事件模型（冻结）
- 指标计算 **唯一触发点**：`BarClosedEvent`
- forming bar 事件禁止触发指标计算

---

## 4. 数据模型与写入规则（新增 P0）

### 4.1 indicator_definition 写入规则
- 系统内置指标：`user_id = 0`
- 唯一键：`(user_id, indicator_code, indicator_version)`
- 冲突策略：**IGNORE（不覆盖）**
- 版本策略：v1.2.2 固定 `indicator_version = "v1"`

### 4.2 indicator_subscription 写入规则
- 唯一键：`(user_id, trading_pair_id, timeframe, indicator_code, indicator_version)`
- 冲突策略：UPSERT（更新 params/enabled）
- 订阅生效规则：enabled=1 才会被计算

### 4.3 indicator_value 写入规则（核心）
- 唯一键：`(user_id, trading_pair_id, timeframe, bar_time, indicator_code, indicator_version)`
- 幂等策略：**INSERT IGNORE**
- 冲突处理（必须）：
  - 若检测到“相同唯一键但结果不同”（同bar_time算出不同值）：
    - 不覆盖原值
    - 写 `indicator_calc_log` 一条 FAILED（error=CONFLICT）
    - 输出 ERROR 日志（包含 calc_fingerprint 与差异）

### 4.4 indicator_calc_log 写入规则
- 只允许追加写入（Append Only）
- 不允许更新历史日志
- 每次计算必须写一条：
  - SUCCESS / FAILED / SKIPPED

---

## 5. 数据质量（DataQuality）规则（P0，冻结）

- OK：availableBars >= requiredBars
- PARTIAL：availableBars < requiredBars（但仍允许写入结果为NULL或写入extra标记）
- INVALID：异常 / NaN / Infinity / 计算失败

> v1.2.2 不引入“0.8阈值”类经验规则，避免争议。

---

## 6. 性能与可靠性约束（P0）

### 6.1 不允许阻塞行情主线程
- 指标计算必须异步执行（线程池/队列）
- BarClosedEvent handler 只负责投递任务，不执行重计算

### 6.2 批量写入建议（可选）
- v1.2.2 可先单条 insert
- 若 TPS 上升，再引入批量写（batch insert）
- 任何批量写仍需保持幂等与冲突检测能力

### 6.3 可恢复性
- 服务重启后允许：
  - 重新加载 BarSeries（QuestDB 365根）
  - 等待新的 BarClosedEvent 继续推进
- v1.2.2 不要求“重启补算历史指标”（后续版本可做）

---

## 7. 可观测性（P0）

### 7.1 必须的 metrics（最小集）
- indicator_calc_cost_ms_p50/p95/p99
- indicator_calc_fail_count
- indicator_value_write_conflict_count
- subscription_enabled_count

### 7.2 必须的日志字段（结构化）
- user_id, trading_pair_id, symbol, timeframe, bar_time
- indicator_code, version, engine, cost_ms, data_quality
- calc_fingerprint
- error_msg（失败时）

---

## 8. 分阶段任务与验收（更新）

### 阶段 0（你已完成）
- 工程骨架、接口、时间语义契约、事件契约

### 阶段 1（新增验收）
- BarSeries 历史加载 + 实时 append（bar_close_time 语义正确）
- 订阅配置可读取（indicator_subscription enabled=1）

### 阶段 2（新增验收）
- 系统启动写入 indicator_definition（user_id=0）
- 可枚举所有指标元数据并用于订阅

### 阶段 5（新增验收）
- 每根 BAR_CLOSED：
  - 至少写一条 calc_log
  - 若成功写 indicator_value（幂等）
- 冲突不覆盖，必须记录 FAILED(CONFLICT)

---

## 9. 验收 Checklist（交付用）

- [ ] 四张表迁移脚本可执行、可回滚
- [ ] indicator_definition 可写入并可查询
- [ ] indicator_subscription 生效配置可驱动计算
- [ ] indicator_value 幂等写入有效
- [ ] 冲突检测与告警生效
- [ ] calc_log 追加写入完整覆盖（success/failed）
- [ ] 事件触发只来自 BarClosedEvent
- [ ] 所有 bar_time 为 UTC bar_close_time
- [ ] 主链路不阻塞行情线程（压测验证）

---

## 10. 冻结声明

> 自 v1.2.2 起：
> - MySQL 四张表为指标模块正式组成部分
> - 任何实现必须遵循幂等/冲突审计/时间语义统一
> - 不允许在策略模块内重复实现指标持久化逻辑
