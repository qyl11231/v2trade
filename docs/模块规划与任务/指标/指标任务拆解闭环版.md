阶段 0：P0 问题闭环（必须先完成）
任务 0.1：新增事件 BarClosedEvent

做什么

定义 BarEventType

定义 BarClosedEvent(tradingPairId, symbol, timeframe, barCloseTime, ohlcv, sourceCount, eventTime)

验收

聚合器每根闭合 bar 只发布一次

forming 更新不发布

任务 0.2：实现 QuestDbTsSemanticsProbe（启动探针）

做什么

抽样读 kline_1m 或某个周期表最新 N 条

校验：递增间隔、对齐性

输出日志并设置运行配置：TS_IS_OPEN_TIME / TS_IS_CLOSE_TIME

无法判定 → 抛异常阻止启动

验收

启动日志明确打印 ts 语义判定

故意造乱序数据能 fail fast

任务 0.3：实现 TimeAlignmentAdapter（两来源）

做什么

KlineEventAdapter：closeTime → bar_close_time

QuestDbAdapter：按 probe 判定转换 ts → bar_close_time

验收

同一条 K 线从 WS 与 QuestDB 进入后 bar_close_time 一致

阶段 1：BarSeries 管理（历史+实时闭环）
任务 1.1：QuestDbKlineReader

做什么

从 kline_{period} 读取最新 365 根

输出 NormalizedBar（bar_time 已归一化）

验收

任意 pair/timeframe 加载后，bars 数量正确、时间升序、步长正确

任务 1.2：BarSeriesManager

做什么

维护内存 BarSeries（pair+timeframe）

启动加载历史 + 实时追加闭合 bar

重复 bar（相同 bar_close_time）应忽略

验收

系统运行 30 分钟，Series 长度持续增长且无重复时间戳

重启后可恢复继续增长

阶段 2：Definition & Registry
任务 2.1：IndicatorRegistry（含参数/返回 Schema 校验）

验收

registry 能列出所有指标元数据

重复 code/version 启动失败

阶段 3：Engine（ta4j + custom）
任务 3.1：Ta4jEngine
任务 3.2：CustomEngine（示例指标）

验收

同一输入 bars，多次计算结果一致

引擎不外泄 ta4j 类型

阶段 4：Calculator（BAR_CLOSED 触发）
任务 4.1：IndicatorCalculator on BarClosedEvent

验收

每根闭合 bar 触发一次计算

forming 不触发

阶段 5：Repository（MySQL）
任务 5.1：indicator_value 表迁移脚本
任务 5.2：幂等写入 + 冲突告警

验收

重放同一 bar 不重复插入

刻意写不同值会产生日志告警但不覆盖

阶段 6：Observability

验收

Prometheus 指标存在（耗时、错误、PARTIAL）

关键日志可检索

阶段 7：API（只读给策略阶段二）

验收

提供 getLatest 查询返回最新指标

策略只读调用不触发计算