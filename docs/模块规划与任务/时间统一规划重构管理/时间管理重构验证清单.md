# 时间管理重构验证清单

> **文档目标**：列出所有需要重新验证的功能模块，确保重构后的时间处理逻辑正确无误。
> 
> **重构完成日期**：2026-01-11  
> **负责人**：量化团队

---

## ✅ 重构完成项目清单

### Phase 1: 核心模型升级 ✅
- [x] `KlineEvent`: 所有时间字段改为 `Instant` 类型
- [x] `NormalizedKline`: 时间字段改为 `Instant`，并提供兼容性方法
- [x] `BarSnapshot`: `barCloseTime` 和 `eventTime` 改为 `Instant`
- [x] `KlineResponse`: `timestamp` 改为 `Instant`，`timeString` 改为 `time`

### Phase 2: TimeUtil 工具类 ✅
- [x] 创建 `TimeUtil.java` 工具类
- [x] 提供 `fromEpochMilli()` / `toEpochMilli()` 转换方法
- [x] 提供 `formatAsShanghaiString()` / `formatAsUtcString()` 格式化方法
- [x] 提供 `alignToMinuteStart()` 对齐方法
- [x] 保留 `UtcTimeConverter` 作为兼容层（标记为 @Deprecated）

### Phase 3: 根除硬编码时区偏移 ✅
- [x] `HistoricalKlineFetcherImpl`: 移除 `+60000*60*8` 硬编码
- [x] `KlineTimeCalculator`: 移除 `-60000*60*8` 硬编码
- [x] `KlineAggregatorImpl`: 移除 `-8*60*60*1000` 硬编码

### Phase 4: 关键服务重构 ✅
- [x] `KlineChannel`: 使用 `Instant` 和 `TimeUtil`
- [x] `QuestDbMarketStorageService`: 使用 `Instant` 写入数据库
- [x] `OkxMarketIngestor`: 修复 `event.openTime()` 的使用
- [x] `MarketDataCenter`: 修复 `event.openTime()` 的使用
- [x] `KlineAggregatorImpl`: 修复 `event.openTime()` / `event.closeTime()` 的使用

### Phase 5: API层重构 ✅（部分）
- [x] `MarketDataController`: 使用 `TimeUtil.formatAsShanghaiString()` 进行时区转换
- [ ] `HistoricalKlineFetcherImpl`: 需要确保 API 调用时正确转换 `Instant` -> `long`

---

## ⚠️ 需要重新验证的功能模块

### 1. 实时行情数据流（P0 - 最高优先级）

**验证目标**：确保从 OKX WebSocket 到 QuestDB 的完整数据流时间戳正确。

**验证步骤**：
1. 启动应用，订阅一个交易对（如 BTC-USDT-SWAP）
2. 观察日志中 K 线事件的时间戳，检查是否同时显示 UTC 和 CST 时间
3. 查询 QuestDB `kline_1m` 表，验证 `ts` 字段是否为正确的 UTC 开盘时间
4. 验证 `exchange_ts` 字段是否与 OKX 返回的时间戳一致

**关键文件**：
- `KlineChannel.java`: 解析 OKX WebSocket 消息
- `QuestDbMarketStorageService.java`: 写入 QuestDB

**验证指标**：
- [ ] K 线时间戳对齐到分钟起始点（秒和毫秒为 0）
- [ ] QuestDB 中的 `ts` 字段为 UTC 时间
- [ ] 日志中的时间戳同时显示 UTC 和 CST，格式清晰

---

### 2. K 线聚合功能（P0 - 最高优先级）

**验证目标**：确保从 1m K 线聚合生成 5m/15m/30m/1h/4h K 线的时间戳正确。

**验证步骤**：
1. 确保有足够的 1m K 线数据（至少 5 分钟）
2. 观察聚合日志，检查窗口开始和结束时间
3. 查询聚合后的 K 线表（如 `kline_5m`），验证 `ts` 字段
4. 验证聚合结果的 `source_count` 字段是否正确

**关键文件**：
- `KlineAggregatorImpl.java`: K 线聚合逻辑
- `AggregationBucket.java`: 聚合窗口管理

**验证指标**：
- [ ] 5m K 线的 `ts` 对齐到 5 分钟倍数（如 10:00, 10:05, 10:10）
- [ ] 聚合窗口的时间计算正确（无硬编码时区偏移）
- [ ] 窗口完整性判断逻辑正确

---

### 3. 历史数据拉取功能（P0 - 最高优先级）

**验证目标**：确保从 OKX API 拉取历史数据的时间参数正确。

**验证步骤**：
1. 手动触发一次历史数据校准
2. 观察日志中 OKX API 请求的 `before` 和 `after` 参数
3. 使用在线时间戳转换工具验证参数是否为正确的 UTC 时间戳
4. 验证拉取的数据时间戳是否与期望时间戳一致

**关键文件**：
- `HistoricalKlineFetcherImpl.java`: 历史数据拉取
- `KlineTimeCalculator.java`: 时间戳计算

**验证指标**：
- [ ] OKX API 请求参数无硬编码时区偏移
- [ ] 请求的 `before` 和 `after` 参数为正确的 UTC 时间戳（毫秒）
- [ ] 拉取的数据时间戳与期望时间戳一致

---

### 4. API 查询功能（P1 - 高优先级）

**验证目标**：确保前端 API 返回的时间字符串为正确的上海时区。

**验证步骤**：
1. 调用 `/api/market/kline` 接口，传入时间范围
2. 检查返回的 JSON 中 `time` 字段是否为上海时区格式（如 "2026-01-11 10:00:00"）
3. 验证 `timestamp` 字段（epoch millis）转换为上海时区后是否与 `time` 字段一致

**关键文件**：
- `MarketDataController.java`: API 控制器
- `MarketQueryService.java`: 查询服务

**验证指标**：
- [ ] API 返回的 `time` 字段为上海时区（UTC+8）
- [ ] `timestamp` 字段为 UTC 时间戳（epoch millis）
- [ ] 时间格式统一为 "yyyy-MM-dd HH:mm:ss"

---

### 5. 指标计算模块（P1 - 高优先级）

**验证目标**：确保指标计算使用的时间戳正确。

**验证步骤**：
1. 确保有完整的聚合 K 线数据
2. 观察指标计算日志，检查 `bar_time` 字段
3. 验证指标计算结果的时间戳是否与 K 线收盘时间一致

**关键文件**：
- `AggregatedKLineToBarClosedEventConverter.java`: K 线转事件
- `BarSnapshot.java`: 指标计算上下文

**验证指标**：
- [ ] `BarSnapshot.barCloseTime` 为正确的 UTC `Instant`
- [ ] 指标计算结果的时间戳正确

---

### 6. 数据校准功能（P1 - 高优先级）

**验证目标**：确保数据校准任务的时间计算正确。

**验证步骤**：
1. 运行数据校准任务
2. 观察日志中的时间范围计算
3. 验证缺失检测的时间戳是否正确

**关键文件**：
- `DataVerifyExecutor.java`: 数据验证执行器
- `HistoricalKlineFetcherImpl.java`: 历史数据拉取

**验证指标**：
- [ ] 时间范围计算无硬编码时区偏移
- [ ] 缺失检测的时间戳正确

---

## 🔍 编译与单元测试

### 编译验证
```bash
mvn clean compile
```
- [ ] 编译通过，无编译错误
- [ ] 所有类型转换正确（`Instant` <-> `long`）
- [ ] 所有 `@Deprecated` 标记的方法已迁移

### 单元测试
```bash
mvn test
```
- [ ] 所有现有单元测试通过
- [ ] 时间相关的测试用例验证正确

---

## 📋 代码审查检查项

### 1. 硬编码时区偏移检查
- [ ] 全局搜索 `60000*60*8` 或 `8*60*60*1000`，确认已全部移除
- [ ] 全局搜索 `+8` 或 `-8`（在时间计算上下文中），确认已全部移除

### 2. 类型使用检查
- [ ] 所有时间字段使用 `Instant` 类型（内部模型）
- [ ] 数据库交互使用 `Timestamp.from(Instant)` 或直接使用 `Instant`
- [ ] API 边界使用 `TimeUtil` 进行时区转换

### 3. 工具类使用检查
- [ ] 所有时区转换都通过 `TimeUtil` 完成
- [ ] 不再直接使用 `ZoneId.of("Asia/Shanghai")` 等（除 `TimeUtil` 内部）
- [ ] 不再直接使用 `Instant.ofEpochMilli()` 等（除 `TimeUtil` 内部）

---

## 🚨 已知问题与后续工作

### 待修复的编译错误
1. **AggregationBucket.java** (第141行)
   - 问题：`event.closeTime()` 返回 `Instant`，需要转换为 `long`
   - 状态：✅ 已修复

2. **其他使用 `event.openTime()` / `event.closeTime()` 的地方**
   - 需要全面检查并修复所有调用点
   - 状态：⚠️ 部分修复，需要完整验证

### 兼容性问题
1. **NormalizedKline 的兼容性方法**
   - 提供了 `getTimestamp()` / `setTimestamp()` 兼容旧代码
   - 建议：逐步迁移到 `getTimestampInstant()` / `setTimestampInstant()`

2. **UtcTimeConverter 已标记为 @Deprecated**
   - 建议：在完全迁移后删除此类

---

## 📝 测试用例建议

### 单元测试用例
1. **TimeUtil 工具类测试**
   - `testFromEpochMilli()`: 测试时间戳转 Instant
   - `testFormatAsShanghaiString()`: 测试格式化
   - `testAlignToMinuteStart()`: 测试对齐

2. **KlineEvent 测试**
   - `testCreateKlineEventWithInstant()`: 测试创建事件
   - `testKlineEventConversion()`: 测试转换

3. **时间计算测试**
   - `testHistoricalKlineFetcher()`: 测试历史数据拉取时间参数
   - `testKlineAggregator()`: 测试聚合时间窗口

### 集成测试用例
1. **端到端数据流测试**
   - 从 WebSocket 接收 -> 存储 -> 查询的完整流程
   - 验证时间戳在整个流程中保持一致

2. **API 测试**
   - 测试 API 返回的时间格式
   - 验证时区转换正确

---

## ✅ 验收标准

重构完成后，必须满足以下所有条件：

- [ ] **代码层面**：项目中不再存在任何 `+8` 或 `-8` 小时的硬编码时区换算
- [ ] **模型层面**：所有核心领域模型（Event, Entity, DTO）均使用 `java.time.Instant` 作为唯一的内部时间表示
- [ ] **数据层面**：QuestDB 和 MySQL 中存储的所有时间戳字段，其物理值均为 UTC 时间
- [ ] **功能层面**：实时行情入库、历史数据拉取、API 查询功能均正常，且时间戳准确无误
- [ ] **日志层面**：日志中打印的时间戳清晰地标明了 UTC 和 CST（上海时间），便于问题排查
- [ ] **测试层面**：所有单元测试和集成测试通过，无遗留 P0/P1 级别缺陷

---

## 📞 联系与支持

如有问题，请通过以下方式联系：
- 项目协作平台
- 团队技术群

---

**最后更新**：2026-01-11  
**维护人**：量化团队架构组
