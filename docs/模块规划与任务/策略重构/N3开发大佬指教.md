好，这个问题问得**非常到位**。
我不再给你“设计方案”，而是站在**已经陪你们一起走完 N1 / N2、现在正要落 N3 的量化系统团队**角度，给你一份**开发过程中的“硬指教清单”**——这是那种**提前说清楚，能少踩 80% 坑**的内容。

我会按 **阶段 / 角色 / 易炸点** 来说，全部都是**实战级提醒**。

---

# 一、先给结论（给你一句总纲）

> **N3 阶段，最容易把系统写“死”的不是策略逻辑，而是：
> 串行没守住、状态乱写库、事件线程被阻塞、恢复语义模糊。**

下面所有指教，都是围绕这四件事。

---

# 二、对【后端开发】的硬指教（最重要）

## 指教 1：**任何时候都不要在 Runtime 里直接用公共线程池**

### 为什么

* N2 的 PRICE / BAR 是高频
* 一旦 Runtime 用 `@Async` 或 `commonExecutor`
  👉 **多个 instance 的事件会交叉执行**
* 后果：

    * phase 被覆盖
    * avg_entry_price 出现“回跳”
    * bug 永远复现不了

### 正确做法（必须）

* 所有 `StrategyRuntime.onTrigger()`
  👉 **只能通过 `StripedSerialExecutor.execute(instanceId, ...)` 进入**
* 且 **Runtime 内部不得再开新线程**

> 这是 N3 的第一生命线。

---

## 指教 2：**N3 不要“顺手”写 pnl 字段**

你们表里有：

```sql
unrealized_pnl
realized_pnl
```

### 真实风险

* N3 没有：

    * 执行回执
    * 成交均价
    * 手续费
* 任何 pnl 都是“看起来像对，其实一定错”

### 指教

* N3 阶段：

    * **pnl 字段只读、不写**
    * 如果非要写，统一写 `NULL`
* 等 N7（执行回执）之后再碰

> 不然你们后面会陷入“UI 显示的盈亏到底准不准”的无底洞。

---

## 指教 3：**状态写库要“抠门”到变态**

你们的表设计是：

```sql
updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
```

### 意味着什么

* 只要 UPDATE 一次，`updated_at` 就会变
* PRICE 高频 = 高频 UPDATE = DB IO 地狱

### 强制规则（必须写进代码）

只有以下字段变化，才允许 UPDATE：

* `logic_position_side`
* `logic_position_qty`
* `avg_entry_price`
* `state_phase`

**否则：不写库。**

### 实操建议

* Runtime 里缓存一份 `lastPersistedState`
* 用四元组 `(phase, side, qty, avg)` 做 equals
* 不变 → return

> 这条守住，N3 才扛得住 N2 的事件量。

---

## 指教 4：**不要把 `strategy_logic_state` 当“事件日志”**

### 错误示范

* 每个 BAR / PRICE 都 update state
* 想“记录发生过什么”

### 正确认知

* `strategy_logic_state` 是：

  > **“当前快照”**
* 不是：

  > **“发生过的历史”**

历史要么：

* 打日志
* 要么 N5 写 `rules_record`

> 状态表 = 只有一行是真的，其它都是幻觉。

---

## 指教 5：**不要在 Runtime 里查 DB**

### 为什么

* Runtime 是事件执行路径
* DB IO = 不可控延迟
* 串行队列一堵，整个 instance 停摆

### 指教

* Runtime 只能：

    * 用内存快照
    * 调用 `stateRepo.persistIfChanged()`
* **不允许**：

    * 查 strategy_instance
    * 查 signal_config
    * 查 trading_pair

这些都应该：

* 启动时注入
* 或由 Manager 层准备好

---

# 三、对【架构/系统设计】的指教

## 指教 6：**把“串行”当作系统级 invariant，而不是实现细节**

### 实战建议

* 在 Runtime 日志里打印：

    * `instanceId`
    * `stripeId`
    * `sequenceNumber`
* QA 可以通过日志证明：

  > 同一 instance 的事件永远在同一 stripe、同一序列

### 为什么重要

* 这是你们以后敢不敢上实盘的信心来源

---

## 指教 7：**恢复语义要“相信 DB，不相信内存”**

### 正确姿势

* 重启：

    * 一切 runtime 内存对象重建
    * **唯一可信的是 `strategy_logic_state`**
* 即便你觉得某些字段“奇怪”，也不要在 N3 擅自纠正

> N3 的任务是“恢复”，不是“修正历史”。

---

## 指教 8：**不要在 N3 偷偷推进 phase**

你们的 phase 很丰富：

```text
IDLE
OPEN_PENDING
OPENED
PARTIAL_EXIT
EXIT_PENDING
ADD_PENDING
CLOSED
```

### 指教

* N3：

    * 只“承接已有 phase”
    * 不从 IDLE → OPEN_PENDING
    * 不从 OPENED → EXIT_PENDING
* 否则：

    * N6（Intent）语义会被你们提前破坏

---

# 四、对【测试 / QA】的指教（经常被忽略）

## 指教 9：**一定要写“并发 + 重启”测试**

### 必测用例（至少 4 个）

1. 同一 instance 并发 PRICE 1000 条
2. PRICE + SIGNAL 同时到达
3. 处理过程中 kill 服务 → 重启
4. 重启后继续打事件

### 验收标准

* phase / qty 不乱
* 不抛异常
* runtime 数量不重复、不泄漏

---

## 指教 10：**日志就是 N3 的“真 UI”**

### 建议日志级别

* `INFO`：runtime_event（有限量）
* `DEBUG`：state_before/state_after（可开关）
* `WARN`：队列满 / 丢事件

### QA 怎么用

* 不看 DB
* 不看 UI
* **只看日志就能判断系统是否健康**

---

# 五、对【产品/项目管理】的指教（你拍板用）

## 指教 11：**N3 不要追求“看到策略动作”**

产品常见误区：

> “N3 能不能顺便展示一下买卖？”

### 坚决反对

* 那是 N6/N7 的事
* N3 的 KPI 只有三个：

    1. 不乱
    2. 不丢
    3. 可恢复

---

## 指教 12：**N3 做慢一点，比返工快一万倍**

如果 N3：

* 串行没守住
* 状态写乱了

那 N4/N5/N6 的所有复杂度都会：
👉 **指数级放大**

---

# 六、最后的“红线清单”（建议贴在群里）

**N3 阶段 6 条红线**

1. ❌ Runtime 不得用公共线程池
2. ❌ 不得在 Runtime 查 DB
3. ❌ 不得高频 update `strategy_logic_state`
4. ❌ 不得擅自推进 phase
5. ❌ 不得写 pnl
6. ❌ 不得破坏 instance 串行

守住这 6 条，
你们这套策略系统 **结构上已经是专业量化系统级别**。

