下面我把 **N3 再改一版**：更“落地”、更像你能直接丢给开发拆 Jira 的版本；同时严格承接你们 **N2 已完成的 Trigger/Routing/Dedup/Async/打印链路**（不推翻），并把 N3 的“重启可恢复 + 串行执行”做成硬交付。

---

## Step 0：量化团队内部对齐 + 和产品的边界确认（N3 冻结）

### 0.1 团队分工（对开发可执行）

* **架构/事件工程师**：runtime 生命周期、串行模型（Striped/Per-instance）、反压与丢弃策略、重启恢复方案
* **后端 Java**：RuntimeManager、Runtime、StateMachine、StateRepo、监控 API
* **SRE**：线程池/队列参数、指标埋点、压测脚本与 GC/队列水位监控
* **QA**：串行性/乱序/重复事件/重启恢复/高频压测用例

### 0.2 和产品最终裁决（N3 做什么/不做什么）

✅ N3 做：

1. **策略实例 Runtime 常驻**（enabled 实例自动装载）
2. **同一 instance 事件严格串行**
3. **状态持久化 + 重启恢复**（至少 phase/仓位/关键时间）
4. N2 的事件路由结果 **真正驱动 runtime**（不只是打印）

❌ N3 不做：

* 不做 runtime_rules 解析/规则结算（N4 才做）
* 不写 rules_record / intent_record（N5/N6）
* 不接真实下单/回执

> 结论：**N3 = “活着 + 记忆 + 有序”，不负责“思考/下单”。**

---

## Step 1：N3 目标与输出（写进研发任务书）

### 1.1 目标（冻结）

> 系统启动后，所有 enabled 的 `strategy_instance` 都在内存中对应一个 `StrategyRuntime`；任何事件到达后，能被路由到 runtime 并**串行处理**；runtime 的状态在 DB 可恢复，重启不丢。

### 1.2 N3 输出清单（验收依据）

* `StrategyRuntimeManager`：启动装载、管理 runtime、对外 dispatch
* `StrategyRuntime`：每实例一个、串行执行、更新快照、驱动状态机
* `StrategyStateMachine`：最小状态机 + 明确迁移入口
* `StrategyStateRepository`：状态写入/读取 + 节流
* 运行态查询 API（前端可不做 UI，但接口必须有）：实例运行态列表/详情

---

## Step 2：总体链路（把 N2 串到 N3）

你们 N2 已经是：

`Ingress -> Dedup(30s) -> Router(instanceIds) -> Async -> Print` 

N3 改造成：

`Ingress -> Dedup -> Router(instanceIds) -> RuntimeDispatch -> PerInstanceSerial -> (UpdateSnapshot + StateMachine + PersistIfChanged + PrintRuntime)`

关键点：**N2 的“路由到 instanceId”必须成为 N3 的唯一入口**（所有后续都以 instanceId 为路由主键）。

---

## Step 3：Runtime 架构（更可落地的类/包/职责）

### 3.1 建议包结构（可直接建目录）

```text
com.qyl.v2trade.business.strategy.runtime
├── manager
│   └── StrategyRuntimeManager
├── runtime
│   └── StrategyRuntime
├── dispatch
│   ├── RuntimeDispatcher
│   └── StripedSerialExecutor
├── state
│   ├── StrategyPhase
│   ├── StrategyState
│   ├── StrategyStateMachine
│   └── StrategyStateRepository
├── snapshot
│   ├── LatestPriceSnapshot
│   ├── LatestBarSnapshot
│   └── LatestSignalSnapshot
└── api
    └── StrategyRuntimeController
```

### 3.2 三个“必须硬约束”（写进代码注释 + 单测）

1. **同一 `strategy_instance_id` 事件处理严格串行**
2. **重复事件幂等（N2 Dedup + N3 二次保护可选）**
3. **状态持久化“只在变化时写”，不能每个 tick 都写**

---

## Step 4：串行执行模型（N3 成败点）

### 4.1 推荐方案：Striped Serial Executor（强烈建议）

* 用 instanceId 做 hash，映射到 N 个 stripe（N=CPU 核心数或 2x 核心数）
* 每个 stripe 是单线程队列执行
* **同一 instanceId 永远落到同一个 stripe** ⇒ 串行天然成立
* 比 “每个 instance 一个线程” 更省资源

**任务拆解**

* 实现 `StripedSerialExecutor#execute(instanceId, runnable)`
* metrics：每个 stripe 队列长度、拒绝次数、平均耗时

### 4.2 背压策略（N3 必须做最小版）

* 队列满：

  * PRICE：可丢（warn + 计数）
  * BAR_CLOSE/SIGNAL：尽量不丢（或走高优先级队列）

> N2 已要求“事件不阻塞上游线程”，N3 必须继承这条铁律。

---

## Step 5：StrategyRuntime（每实例一个“活体”）

### 5.1 Runtime 必备字段（建议最小集）

* `instanceId / userId / tradingPairId / signalConfigId / strategySymbol`
* `StrategyStateMachine stateMachine`
* `Latest*Snapshot`（只保存最新）
* `lastProcessedEventKey`（可选：N3 二次幂等）
* `lastEventTimeUtc`

### 5.2 Runtime 处理逻辑（N3 只干 4 件事）

1. 校验/忽略过旧事件（可选：asOfTime 比 lastEventTime 早太多直接丢）
2. 更新快照（price/bar/signal）
3. 调用 `stateMachine.onTrigger(trigger)`（N3 只更新时间/phase 最小迁移）
4. `stateRepo.persistIfChanged(...)`（有变化才写）
5. 打印 runtime 日志（可 grep）

---

## Step 6：状态机（N3 最小但要“可扩展”）

### 6.1 StrategyPhase（冻结 v0）

* `IDLE`：等待
* `OPENED`：持仓（N3 不会主动进入，但必须能恢复/展示）
* `OPEN_PENDING / EXIT_PENDING`：N6/N7 扩展位（N3 只作为可恢复状态显示）

### 6.2 StrategyState（持久化字段冻结）

* `phase`
* `positionQty`
* `avgEntryPrice`
* `lastEventTimeUtc`
* `updatedAt`

### 6.3 迁移规则（N3 不做决策，但允许“被恢复”）

* N3 不会生成 OPEN/CLOSE
* 但如果 DB 恢复到 `OPENED`，runtime 必须接受并继续维护 `lastEventTimeUtc`

---

## Step 7：状态持久化与恢复（两套实现方案，给你可选但不阻塞推进）

### 方案 A（推荐）根据表 `strategy_logic_state`（最干净）




## Step 8：运行态 API（N3 必须给排障入口）

> UI 可以后置，但 API 要先有。

### 8.1 接口清单（建议）

* `GET /api/strategy/runtime/instances`
  返回：所有 enabled 实例的 runtime 状态摘要（phase、lastEventTime、队列水位可选）
* `GET /api/strategy/runtime/instance/{id}`
  返回：单实例详情（state + latest snapshots）

### 8.2 典型返回字段

* `instanceId, userId, phase, positionQty, avgEntryPrice, lastEventTimeUtc`
* `latestPrice.price/asOf`
* `latestBar.tf/closeTime`
* `latestSignal.signalId/asOf`

---

## Step 9：打印规范（从 N2 “路由打印”升级到 N3 “runtime 打印”）

N2 已冻结的打印字段（triggerType/eventKey/asOf/pairId/instanceId/userId）保留，并新增：

* `phase`
* `stripeId`（可选，用于证明串行落在哪个 stripe）

示例：

```text
STRATEGY_RUNTIME {"instanceId":9001,"phase":"IDLE","stripe":3,"type":"BAR_CLOSE","eventKey":"BAR:12:1m:...","asOf":"...","pairId":12,"tf":"1m"}
```

---

## Step 10：DoD 验收（Given/When/Then 可直接写测试）

### 10.1 启动装载

* Given：DB 有 10 个 enabled 实例
* When：服务启动
* Then：RuntimeManager 内存 runtime 数量=10；接口可查到 10 条

### 10.2 串行性证明

* Given：同一 instance 连续发送 1000 个 PRICE（并发）
* When：运行 10s
* Then：日志中该 instance 的处理序号严格递增；无交错（可用 sequenceId）

### 10.3 重启恢复

* Given：instance 的 state.phase=OPENED，qty>0
* When：重启服务
* Then：runtime 查询接口显示 OPENED 且 qty/avg 不变

### 10.4 背压不崩

* Given：PRICE 2000 msg/s，队列上限 10w
* When：压测 60s
* Then：不 OOM、不 FullGC；PRICE 丢弃有计数；BAR_CLOSE/SIGNAL 仍能被处理

---

## 总结（这版 N3 的变化点）

1. **把 N3 交付从“写几个类”升级为“可运行、可恢复、可观测”的硬闭环**
2. 串行执行明确落在 **StripedSerialExecutor**，避免 per-instance thread 的资源灾难
3. 状态持久化给了 **推荐 A（独立 state 表）/备选 B（instance JSON）**，并明确 B 会与 N1 的 history/version 机制冲突风险
4. 给了可直接落地的 **API + DoD 用例**，方便你们 QA/压测验收




N3 补充点

明白了——你们 **`strategy_logic_state` 这张“防失忆”表已经存在**，而且字段比我上一版假设的更完整（含 `logic_position_side / qty / phase / pnl` 等）。那 N3 就不讨论“要不要建表”，而是**严格按你们现有表结构，把 N3 的任务重新对齐：N1/N2 已做什么、N3 该补什么、怎么落地、怎么验收**。

---

## Step 1：先对齐现状（基于 N1 / N2 已完成）

### 1.1 N1 已完成（管理闭环）

* 已有 `strategy_definition / strategy_instance` 的 CRUD、启停、历史版本（`strategy_instance_history`）等。
* 关键点：后续运行时路由主键是 `strategy_instance_id`（N1 文档也强调了）。

### 1.2 N2 已完成（事件接入与路由）

按你们 N2 的定义，已经做到：

* 统一输入：`StrategyTrigger`（BAR_CLOSE / PRICE / SIGNAL）+ eventKey 规范
* Router：能把 trigger 映射到 `strategy_instance_id` 列表
* Dedup：30s TTL 去重（避免刷屏/重复处理）
* 异步：不阻塞上游线程
* 打印：route_print（事件→实例）链路可追踪

> 所以 N3 的工作不是“再做一遍路由”，而是：**把 N2 的 instanceId 分发真正接入“实例运行时 + 状态恢复 + 串行处理”。**

---

## Step 2：你们现有 `strategy_logic_state` 表对 N3 的意义（关键裁决）

你们表结构非常适合作为 N3 的“唯一真相来源（Source of Truth）”：

* **重启恢复**：读取 `strategy_instance_id` 对应的最新快照即可恢复 runtime
* **运行态可观测**：可直接用它对外展示 phase/side/qty/avg
* **N3 不决策**也完全 OK：N3 只需要维护 *lastEventTime/phase 的最小变化*，甚至 phase 不变也能工作

但要注意两件事（N3 必须明确）：

1. **N3 不要写 pnl**（`unrealized_pnl/realized_pnl`）

    * 没有结算引擎/执行回执前，pnl 写了也不可信
2. **N3 的写库必须节流**

    * PRICE 高频写 `updated_at` 会把 DB 打爆
    * 所以 N3 采用“只在关键字段变化时写”（详见 Step 6）

---

## Step 3：N3 阶段目标（按你们表字段“重新冻结”）

> **N3 目标：让每个 enabled 的 strategy_instance 在内存中有一个 runtime，并能：串行处理事件、更新快照、必要时持久化到 `strategy_logic_state`，并在重启后恢复。**

N3 交付物（按你们表设计）：

* `StrategyStateRepository`：直接读写 `strategy_logic_state`
* `StrategyRuntimeManager`：启动加载 enabled 实例 + state，生成 runtime
* `StrategyRuntime`：串行消费 trigger，维护“最新快照”并驱动最小状态机
* `RuntimeQuery API`：能查到每个实例的 `state_phase / logic_position_side / qty / avg_entry_price / updated_at`

---

## Step 4：N3 的核心工程任务拆解（能直接开工）

### 4.1 新增 Entity/Mapper（状态表接入）

**任务**

* 新建实体 `StrategyLogicState`（映射你给的字段）
* 新建 `StrategyLogicStateMapper`

    * `selectByInstanceId(userId, instanceId)` 或直接按 instanceId（看你们权限设计）
    * `upsert`：按 `(user_id, strategy_instance_id)` 或 `(strategy_instance_id)` 唯一（见 Step 5）

**注意**

* 你们表里没有显式唯一键，但业务上必须唯一：**一个 instance 只能有一条当前快照**
  → N3 强烈建议补：`UNIQUE(strategy_instance_id)`（或 `(user_id, strategy_instance_id)`）

### 4.2 RuntimeManager（启动装载 + runtime registry）

**任务**

* 启动时：`strategyInstanceMapper.selectAllEnabled()`（N2 里也提到了这个方法方向）

* 对每个 instance：

    1. `state = stateRepo.loadOrInit(instance)`
    2. `runtime = new StrategyRuntime(instance, state, stripedExecutor, stateRepo)`
    3. register 到 `ConcurrentHashMap<Long, StrategyRuntime>`

* 对外提供：

    * `dispatch(instanceId, trigger)`：被 N2 Router 调用
    * `getRuntime(instanceId)`：给 API 查询用

### 4.3 串行执行（必须）

**任务**

* 实现 `StripedSerialExecutor`（N 个 stripe 单线程队列）
* `execute(instanceId, runnable)`：instanceId hash 决定 stripe
* 记录每个 stripe：

    * 队列长度
    * 拒绝次数（队列满）

**背压最小策略（N3 必须有）**

* PRICE 队列满：丢弃并 warn（计数）
* BAR_CLOSE/SIGNAL：尽量不丢（可走单独 stripe 或单独队列）

### 4.4 StrategyRuntime（事件处理只做“快照 + 最小状态维护 + 受控写库”）

**任务**

* `onTrigger(trigger)`：进入 `stripedExecutor.execute(instanceId, ...)`
* `handle(trigger)`：

    1. 更新内存快照（latestPrice/latestBar/latestSignal）
    2. 更新 `lastEventTime`（内存）
    3. 调用最小 stateMachine（N3 不生成 intent）
    4. 调用 `stateRepo.persistIfChanged(...)`
    5. 打印 runtime 日志（带 phase/side/qty）

---

## Step 5：严格对齐你们表字段：状态机最小模型怎么映射

你们表中核心状态字段是：

* `logic_position_side`：LONG/SHORT/FLAT
* `logic_position_qty`
* `avg_entry_price`
* `state_phase`：IDLE / OPEN_PENDING / OPENED / PARTIAL_EXIT / EXIT_PENDING / ADD_PENDING / CLOSED ...
* `updated_at`

### N3 的最小策略（非常重要）

N3 不做决策，所以：

* **不主动改变** `logic_position_side/qty/avg_entry_price`（除非你们希望 N3 支持“外部注入状态”）
* **不主动推进 phase 到 OPEN_PENDING/EXIT_PENDING**（这是 N6/N7 的事）

N3 需要做到的最小一致性是：

* 如果 DB 里是 `OPENED/LONG/qty>0`：runtime 重启后仍展示为 OPENED，并能继续接收事件
* 如果 DB 里是 `IDLE/FLAT/qty=0`：runtime 正常运行

> 换句话说：**N3 的 state_machine 主要职责是“承接恢复态 + 维护 lastEventTime + 为 N4/N6 预留迁移入口”。**

---

## Step 6：按你们表重新定义“持久化策略”（解决高频写库炸裂）

你们 `updated_at` 有 ON UPDATE，这意味着**只要 UPDATE，就会刷新时间**。PRICE 高频会把 DB 写爆。

### 6.1 N3 写库“触发条件”（冻结）

只有以下情况才允许写 `strategy_logic_state`：

1. **首次初始化**：该 instance 没有 state 行 → INSERT
2. **phase / side / qty / avg_entry_price 发生变化** → UPDATE
3. （可选）lastEventTime 需要持久化：你们表里没 `last_event_time` 字段

    * 那 N3 就**不写 lastEventTime**到 DB，只在内存维护；重启后用 `updated_at` 作为近似观测即可

### 6.2 “变化检测”怎么做

* runtime 内存保存一份 `lastPersistedSnapshotHash`
* 或直接对比（phase/side/qty/avg）四元组
* 未变化：**不更新 DB**（避免 updated_at 乱跳）

> 这样 N3 才扛得住 N2 的 PRICE 高频输入。

---

## Step 7：恢复流程（按你们表字段写死）

### 7.1 loadOrInit(instance)

* 先按 `strategy_instance_id` 查 state
* 查不到：

    * INSERT 一行初始态：

        * `logic_position_side = FLAT`
        * `logic_position_qty = 0`
        * `state_phase = IDLE`
        * `avg_entry_price = null`
        * 其他：`user_id/strategy_id/trading_pair_id/strategy_symbol` 从 instance 填

### 7.2 恢复后的 runtime 行为

* runtime 启动后直接使用 DB 的 phase/side/qty/avg
* N3 事件来时只更新快照与观测，不乱改“仓位状态字段”

---

## Step 8：N3 必须补的 API（结合这张表最有价值）

即使你不做 UI，N3 也必须有排障入口：

1. `GET /api/strategy/runtime/state/list`

    * 返回 enabled 实例列表 + `state_phase/side/qty/avg/updated_at`
2. `GET /api/strategy/runtime/state/{instanceId}`

    * 返回该 instance 的 state + runtime 内存快照摘要（latestPrice/latestBar/latestSignal）

---

## Step 9：验收标准（Given/When/Then，结合你们表）

### 9.1 初始化插入

* Given：某 instance 没有 `strategy_logic_state` 记录
* When：服务启动
* Then：自动插入一条 IDLE/FLAT/0 的记录

### 9.2 重启恢复

* Given：DB 中某 instance 为 `OPENED/LONG/qty>0`
* When：服务重启
* Then：API 查询仍是 OPENED/LONG/qty>0（runtime 恢复成功）

### 9.3 串行性

* Given：同一 instance 并发打入 1000 个 PRICE
* When：运行 10s
* Then：runtime 日志处理顺序不交错（可通过 stripeId + 递增序号证明）

### 9.4 不写爆 DB

* Given：PRICE 2000 msg/s
* When：压测 60s
* Then：`strategy_logic_state` 的 UPDATE 次数远小于事件数（仅在变化时写）

---

## 总结（这版 N3 相比上一版“真正对齐你们现有表”的变化）

1. **不再讨论建表**：直接以你们现有 `strategy_logic_state` 为唯一状态快照表
2. **明确 N3 不写 pnl、不做决策**：只做恢复、串行、快照、受控持久化
3. **把“写库节流”写死为硬规则**：避免 PRICE 高频把 `updated_at` 刷爆
4. **N3 的 stateMachine 最小化**：承接已有 phase/side/qty/avg，给 N4/N6 预留扩展点
