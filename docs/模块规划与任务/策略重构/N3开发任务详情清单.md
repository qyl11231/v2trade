# N3 阶段：策略运行时容器与状态恢复开发任务清单

> **核心目标**：让每个 enabled 的 `strategy_instance` 在内存中有一个 runtime，并能：串行处理事件、更新快照、必要时持久化到 `strategy_logic_state`，并在重启后恢复。

---

## 一、目标与边界（必须冻结）

### 1.1 N3 核心目标

1. **策略实例 Runtime 常驻**（enabled 实例自动装载）
2. **同一 instance 事件严格串行**
3. **状态持久化 + 重启恢复**（至少 phase/仓位/关键时间）
4. N2 的事件路由结果**真正驱动 runtime**（不只是打印）

### 1.2 N3 不做的事情（硬边界）

- ❌ 不做 runtime_rules 解析/规则结算（N4 才做）
- ❌ 不写 rules_record / intent_record（N5/N6）
- ❌ 不接真实下单/回执（N7）
- ❌ **不写 pnl 字段**（`unrealized_pnl/realized_pnl`，等 N7 执行回执）
- ❌ **不主动推进 phase**（IDLE → OPEN_PENDING 等，N6 才做）
- ❌ **不在 Runtime 里查 DB**（所有数据启动时注入）
- ❌ **不高频 update state 表**（只在关键字段变化时写）

### 1.3 输入依赖

- ✅ N1 已完成：`strategy_instance` 表可查，`enabled` 状态可用
- ✅ N2 已完成：事件路由到 `instanceId` 列表，异步分发，统一打印
- ✅ 现有表：`strategy_logic_state` 表已存在

---

## 二、包结构与核心类（必须按此实现）

```
com.qyl.v2trade.business.strategy.runtime
├── manager
│   └── StrategyRuntimeManager         # Runtime 管理器（启动装载 + dispatch）
├── runtime
│   └── StrategyRuntime                # 策略运行时（每实例一个）
├── dispatch
│   ├── RuntimeDispatcher              # Runtime 分发器（连接 N2 与 N3）
│   └── StripedSerialExecutor          # 串行执行器（按 instanceId 哈希分片）
├── state
│   ├── StrategyPhase                  # 状态阶段枚举
│   ├── StrategyState                  # 状态实体（内存模型）
│   ├── StrategyStateMachine           # 状态机（最小迁移，N3 不做决策）
│   └── StrategyStateRepository        # 状态持久化（读写 strategy_logic_state 表）
├── snapshot
│   ├── LatestPriceSnapshot            # 最新价格快照
│   ├── LatestBarSnapshot              # 最新K线快照
│   └── LatestSignalSnapshot           # 最新信号快照
└── api
    └── StrategyRuntimeController      # 运行态查询 API
```

---

## 三、详细任务拆解

### Task 1：状态实体与 Mapper（优先级：P0）

#### 1.1 创建 StrategyLogicState 实体

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/model/entity/StrategyLogicState.java`

**字段映射**（按现有表结构）：

```java
public class StrategyLogicState {
    private Long id;
    private Long userId;
    private Long strategyId;
    private Long strategyInstanceId;      // 主路由键
    private Long tradingPairId;
    private String strategySymbol;
    
    // 核心状态字段（必须）
    private String logicPositionSide;     // LONG/SHORT/FLAT
    private BigDecimal logicPositionQty;  // 逻辑持仓数量
    private BigDecimal avgEntryPrice;     // 平均开仓价
    private String statePhase;            // IDLE/OPEN_PENDING/OPENED/EXIT_PENDING/CLOSED...
    
    // 盈亏字段（N3 不写，只读）
    private BigDecimal unrealizedPnl;     // N3 阶段不写
    private BigDecimal realizedPnl;       // N3 阶段不写
    
    private LocalDateTime updatedAt;
    private LocalDateTime createdAt;
}
```

**验收标准**：
- [ ] 实体字段与表结构完全对应
- [ ] 使用 MyBatis-Plus 注解（@TableName, @TableId 等）

#### 1.2 创建 StrategyLogicStateMapper

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/mapper/StrategyLogicStateMapper.java`

**必需方法**：

```java
@Mapper
public interface StrategyLogicStateMapper extends BaseMapper<StrategyLogicState> {
    /**
     * 根据实例ID查询状态（用于恢复）
     */
    StrategyLogicState selectByInstanceId(@Param("instanceId") Long instanceId);
    
    /**
     * 批量查询所有实例的状态（用于启动装载）
     */
    List<StrategyLogicState> selectByInstanceIds(@Param("instanceIds") List<Long> instanceIds);
    
    /**
     * 插入或更新状态（UPSERT，按 instanceId 唯一）
     * 注意：需要 ON DUPLICATE KEY UPDATE 或先查后更新
     */
    int upsertState(StrategyLogicState state);
}
```

**XML 映射**（如果使用 MyBatis）：

**文件路径**：`src/main/resources/mapper/StrategyLogicStateMapper.xml`

**验收标准**：
- [ ] 查询方法正确映射
- [ ] upsert 方法正确实现（避免并发插入冲突）
- [ ] 建议数据库添加唯一约束：`UNIQUE(strategy_instance_id)`

---

### Task 2：状态阶段与状态模型（优先级：P0）

#### 2.1 创建 StrategyPhase 枚举

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/state/StrategyPhase.java`

```java
public enum StrategyPhase {
    /**
     * 空闲状态（等待）
     */
    IDLE,
    
    /**
     * 已决策待开仓（N6 阶段）
     */
    OPEN_PENDING,
    
    /**
     * 已开仓（持仓中）
     */
    OPENED,
    
    /**
     * 部分减仓（N6/N7 阶段）
     */
    PARTIAL_EXIT,
    
    /**
     * 已决策待平仓（N6 阶段）
     */
    EXIT_PENDING,
    
    /**
     * 部分加仓（N6/N7 阶段）
     */
    ADD_PENDING,
    
    /**
     * 已平仓（N7 阶段）
     */
    CLOSED;
}
```

**验收标准**：
- [ ] 枚举值与数据库 `state_phase` 字段完全对应
- [ ] 提供 `fromString(String)` 和 `toString()` 方法

#### 2.2 创建 StrategyState 内存模型

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/state/StrategyState.java`

```java
public class StrategyState {
    private StrategyPhase phase;
    private String positionSide;      // LONG/SHORT/FLAT
    private BigDecimal positionQty;
    private BigDecimal avgEntryPrice;
    
    // N3 新增字段（内存维护，不持久化）
    private Instant lastEventTimeUtc;  // 最后处理事件时间
    
    // 用于变化检测（避免频繁写库）
    private String persistedStateHash; // (phase, side, qty, avg) 的哈希值
    
    // Getters and Setters...
    
    /**
     * 计算状态哈希（用于判断是否需要持久化）
     */
    public String computeStateHash() {
        return DigestUtils.md5Hex(
            phase + "|" + positionSide + "|" + positionQty + "|" + avgEntryPrice
        );
    }
    
    /**
     * 判断状态是否发生变化（需要持久化）
     */
    public boolean hasChanged() {
        return !Objects.equals(computeStateHash(), persistedStateHash);
    }
}
```

**验收标准**：
- [ ] 包含所有核心状态字段
- [ ] 实现变化检测逻辑
- [ ] 提供便捷的状态比较方法

---

### Task 3：快照模型（优先级：P0）

#### 3.1 创建 LatestPriceSnapshot

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/snapshot/LatestPriceSnapshot.java`

```java
public class LatestPriceSnapshot {
    private BigDecimal price;
    private Instant asOfTimeUtc;
    private String source;  // 行情来源（如 OKX）
    
    // 线程安全的更新方法
    public synchronized void update(BigDecimal newPrice, Instant newTime, String source) {
        if (newTime != null && (asOfTimeUtc == null || !newTime.isBefore(asOfTimeUtc))) {
            this.price = newPrice;
            this.asOfTimeUtc = newTime;
            this.source = source;
        }
    }
}
```

#### 3.2 创建 LatestBarSnapshot

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/snapshot/LatestBarSnapshot.java`

```java
public class LatestBarSnapshot {
    private String timeframe;        // 1m, 5m, 1h 等
    private BigDecimal open;
    private BigDecimal high;
    private BigDecimal low;
    private BigDecimal close;
    private BigDecimal volume;
    private Instant barCloseTimeUtc; // K线闭合时间
    
    // 线程安全的更新方法
    public synchronized void update(String tf, BigDecimal open, BigDecimal high, 
                                   BigDecimal low, BigDecimal close, BigDecimal volume, 
                                   Instant closeTime) {
        if (closeTime != null && (barCloseTimeUtc == null || !closeTime.isBefore(barCloseTimeUtc))) {
            // 只更新相同 timeframe 或更新的数据
            if (this.timeframe == null || this.timeframe.equals(tf)) {
                this.timeframe = tf;
                this.open = open;
                this.high = high;
                this.low = low;
                this.close = close;
                this.volume = volume;
                this.barCloseTimeUtc = closeTime;
            }
        }
    }
}
```

#### 3.3 创建 LatestSignalSnapshot

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/snapshot/LatestSignalSnapshot.java`

```java
public class LatestSignalSnapshot {
    private Long signalConfigId;
    private String signalId;
    private String signalDirectionHint;  // LONG/SHORT/NEUTRAL
    private BigDecimal price;
    private Instant receivedTimeUtc;
    
    // 线程安全的更新方法
    public synchronized void update(Long configId, String sigId, String direction, 
                                   BigDecimal price, Instant receivedTime) {
        if (receivedTime != null && (receivedTimeUtc == null || !receivedTime.isBefore(receivedTimeUtc))) {
            this.signalConfigId = configId;
            this.signalId = sigId;
            this.signalDirectionHint = direction;
            this.price = price;
            this.receivedTimeUtc = receivedTime;
        }
    }
}
```

**验收标准**：
- [ ] 所有快照类线程安全（使用 synchronized 或 volatile）
- [ ] 只保存最新数据（按时间戳判断）
- [ ] 提供便捷的更新方法

---

### Task 4：串行执行器（优先级：P0 - 生命线）

#### 4.1 创建 StripedSerialExecutor

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/dispatch/StripedSerialExecutor.java`

**核心要求**：

```java
@Component
public class StripedSerialExecutor {
    
    // Stripe 数量 = CPU 核心数或 2x 核心数
    private final int stripeCount;
    
    // 每个 stripe 是单线程队列执行器
    private final ExecutorService[] stripes;
    
    // 队列满拒绝策略
    private final RejectedExecutionHandler rejectionHandler;
    
    // Metrics（用于监控）
    private final AtomicLong[] stripeQueueSizes;
    private final AtomicLong[] stripeRejectedCounts;
    
    public StripedSerialExecutor() {
        this.stripeCount = Runtime.getRuntime().availableProcessors() * 2;
        this.stripes = new ExecutorService[stripeCount];
        
        // 初始化每个 stripe
        for (int i = 0; i < stripeCount; i++) {
            final int stripeId = i;
            stripes[i] = new ThreadPoolExecutor(
                1, 1,  // 单线程
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(10_000),  // 队列上限
                r -> new Thread(r, "strategy-runtime-stripe-" + stripeId),
                new ThreadPoolExecutor.CallerRunsPolicy()  // 队列满时由调用线程执行
            );
        }
    }
    
    /**
     * 执行任务（根据 instanceId 哈希到对应的 stripe）
     * 
     * 【核心保证】：同一 instanceId 永远落到同一个 stripe → 串行天然成立
     */
    public void execute(Long instanceId, Runnable task) {
        int stripeId = (int) (instanceId % stripeCount);
        
        try {
            stripes[stripeId].submit(() -> {
                try {
                    stripeQueueSizes[stripeId].incrementAndGet();
                    task.run();
                } finally {
                    stripeQueueSizes[stripeId].decrementAndGet();
                }
            });
        } catch (RejectedExecutionException e) {
            stripeRejectedCounts[stripeId].incrementAndGet();
            // PRICE 可丢弃，BAR_CLOSE/SIGNAL 需要特殊处理
            handleRejection(instanceId, task, e);
        }
    }
    
    private void handleRejection(Long instanceId, Runnable task, RejectedExecutionException e) {
        // TODO: 根据事件类型决定是否丢弃（N3 最小实现：PRICE 丢弃，其他重试）
        log.warn("Stripe 队列满，任务被拒绝: instanceId={}, stripeId={}", instanceId, getStripeId(instanceId), e);
    }
    
    private int getStripeId(Long instanceId) {
        return (int) (instanceId % stripeCount);
    }
    
    // Metrics 方法
    public int getStripeQueueSize(int stripeId) {
        return stripeQueueSizes[stripeId].intValue();
    }
    
    public long getStripeRejectedCount(int stripeId) {
        return stripeRejectedCounts[stripeId].get();
    }
}
```

**验收标准**：
- [ ] 同一 instanceId 永远落到同一个 stripe（通过 hash 验证）
- [ ] 每个 stripe 是单线程执行（日志可证明）
- [ ] 队列满时有拒绝策略（PRICE 可丢，其他尽量不丢）
- [ ] 提供 Metrics 监控方法

---

### Task 5：状态持久化仓库（优先级：P0）

#### 5.1 创建 StrategyStateRepository

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/state/StrategyStateRepository.java`

**核心要求**：

```java
@Component
public class StrategyStateRepository {
    
    @Autowired
    private StrategyLogicStateMapper stateMapper;
    
    /**
     * 加载或初始化状态（用于启动恢复）
     * 
     * @param instance 策略实例
     * @return 状态对象（内存模型）
     */
    public StrategyState loadOrInit(StrategyInstance instance) {
        // 1. 先查 DB
        StrategyLogicState dbState = stateMapper.selectByInstanceId(instance.getId());
        
        if (dbState == null) {
            // 2. 如果没有，插入初始状态
            StrategyLogicState initState = createInitialState(instance);
            stateMapper.insert(initState);
            dbState = initState;
        }
        
        // 3. 转换为内存模型
        StrategyState state = convertToState(dbState);
        state.setPersistedStateHash(state.computeStateHash());
        
        return state;
    }
    
    /**
     * 持久化状态（只在变化时写）
     * 
     * 【硬约束】：只有以下字段变化才写库：
     * - logic_position_side
     * - logic_position_qty
     * - avg_entry_price
     * - state_phase
     * 
     * 否则：不写库（避免 updated_at 乱跳）
     */
    public void persistIfChanged(StrategyInstance instance, StrategyState state) {
        // 1. 判断是否有变化
        if (!state.hasChanged()) {
            return;  // 无变化，不写库
        }
        
        // 2. 转换为 DB 模型
        StrategyLogicState dbState = convertToDbState(instance, state);
        
        // 3. UPSERT（按 instanceId 唯一）
        stateMapper.upsertState(dbState);
        
        // 4. 更新内存的 persistedStateHash
        state.setPersistedStateHash(state.computeStateHash());
        
        log.debug("状态已持久化: instanceId={}, phase={}, side={}, qty={}", 
            instance.getId(), state.getPhase(), state.getPositionSide(), state.getPositionQty());
    }
    
    private StrategyLogicState createInitialState(StrategyInstance instance) {
        StrategyLogicState state = new StrategyLogicState();
        state.setUserId(instance.getUserId());
        state.setStrategyId(instance.getStrategyId());
        state.setStrategyInstanceId(instance.getId());
        state.setTradingPairId(instance.getTradingPairId());
        state.setStrategySymbol(instance.getStrategySymbol());
        state.setLogicPositionSide("FLAT");
        state.setLogicPositionQty(BigDecimal.ZERO);
        state.setAvgEntryPrice(null);
        state.setStatePhase("IDLE");
        state.setUnrealizedPnl(null);  // N3 不写
        state.setRealizedPnl(null);    // N3 不写
        return state;
    }
    
    private StrategyState convertToState(StrategyLogicState dbState) {
        StrategyState state = new StrategyState();
        state.setPhase(StrategyPhase.fromString(dbState.getStatePhase()));
        state.setPositionSide(dbState.getLogicPositionSide());
        state.setPositionQty(dbState.getLogicPositionQty());
        state.setAvgEntryPrice(dbState.getAvgEntryPrice());
        return state;
    }
    
    private StrategyLogicState convertToDbState(StrategyInstance instance, StrategyState state) {
        StrategyLogicState dbState = new StrategyLogicState();
        dbState.setUserId(instance.getUserId());
        dbState.setStrategyId(instance.getStrategyId());
        dbState.setStrategyInstanceId(instance.getId());
        dbState.setTradingPairId(instance.getTradingPairId());
        dbState.setStrategySymbol(instance.getStrategySymbol());
        dbState.setLogicPositionSide(state.getPositionSide());
        dbState.setLogicPositionQty(state.getPositionQty());
        dbState.setAvgEntryPrice(state.getAvgEntryPrice());
        dbState.setStatePhase(state.getPhase().toString());
        // N3 不写 pnl
        dbState.setUnrealizedPnl(null);
        dbState.setRealizedPnl(null);
        return dbState;
    }
}
```

**验收标准**：
- [ ] 启动时能正确加载已有状态（恢复）
- [ ] 没有状态时自动初始化（INSERT）
- [ ] 只有在关键字段变化时才写库（变化检测）
- [ ] UPSERT 方法能正确处理并发插入

---

### Task 6：状态机（优先级：P1 - 最小实现）

#### 6.1 创建 StrategyStateMachine

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/state/StrategyStateMachine.java`

**核心要求**：

```java
public class StrategyStateMachine {
    
    private StrategyState currentState;
    
    public StrategyStateMachine(StrategyState initialState) {
        this.currentState = initialState;
    }
    
    /**
     * 处理触发事件（N3 最小实现：只更新 lastEventTime，不推进 phase）
     * 
     * 【硬约束】：N3 不主动推进 phase（IDLE → OPEN_PENDING 等，N6 才做）
     */
    public void onTrigger(StrategyTrigger trigger) {
        // N3 阶段只做最小维护：
        // 1. 更新最后事件时间
        currentState.setLastEventTimeUtc(trigger.getAsOfTimeUtc());
        
        // 2. N3 不做 phase 迁移（留给 N6/N7）
        // 如果 DB 恢复的状态是 OPENED，就保持 OPENED
        
        log.debug("状态机处理事件: instanceId={}, phase={}, eventType={}", 
            trigger.getInstanceId(), currentState.getPhase(), trigger.getTriggerType());
    }
    
    /**
     * 获取当前状态（只读）
     */
    public StrategyState getCurrentState() {
        return currentState;
    }
    
    /**
     * 设置状态（用于外部注入，如 N6/N7 阶段）
     * 注意：此方法 N3 阶段不使用，为后续扩展预留
     */
    public void setState(StrategyPhase phase, String side, BigDecimal qty, BigDecimal avg) {
        // TODO: N6/N7 阶段实现
        throw new UnsupportedOperationException("N3 阶段不支持状态迁移");
    }
}
```

**验收标准**：
- [ ] N3 阶段不主动推进 phase
- [ ] 能正确更新 lastEventTime
- [ ] 为后续扩展预留接口

---

### Task 7：策略运行时（优先级：P0）

#### 7.1 创建 StrategyRuntime

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/runtime/StrategyRuntime.java`

**核心要求**：

```java
public class StrategyRuntime {
    
    // 实例基本信息（启动时注入，不查 DB）
    private final Long instanceId;
    private final Long userId;
    private final Long strategyId;        // 策略ID（必须保存，用于持久化）
    private final Long tradingPairId;
    private final Long signalConfigId;
    private final String strategySymbol;
    
    // 状态机
    private final StrategyStateMachine stateMachine;
    
    // 快照（只保存最新）
    private final LatestPriceSnapshot latestPrice;
    private final LatestBarSnapshot latestBar;
    private final LatestSignalSnapshot latestSignal;
    
    // 依赖注入（不查 DB）
    private final StrategyStateRepository stateRepo;
    private final StripedSerialExecutor executor;
    
    // 处理序号（用于证明串行）
    private final AtomicLong sequenceNumber = new AtomicLong(0);
    
    public StrategyRuntime(StrategyInstance instance, StrategyState initialState,
                          StrategyStateRepository stateRepo, StripedSerialExecutor executor) {
        this.instanceId = instance.getId();
        this.userId = instance.getUserId();
        this.strategyId = instance.getStrategyId();  // 必须保存，用于持久化状态
        this.tradingPairId = instance.getTradingPairId();
        this.signalConfigId = instance.getSignalConfigId();
        this.strategySymbol = instance.getStrategySymbol();
        
        this.stateMachine = new StrategyStateMachine(initialState);
        this.latestPrice = new LatestPriceSnapshot();
        this.latestBar = new LatestBarSnapshot();
        this.latestSignal = new LatestSignalSnapshot();
        
        this.stateRepo = stateRepo;
        this.executor = executor;
    }
    
    /**
     * 处理触发事件（入口方法，由 RuntimeDispatcher 调用）
     * 
     * 【核心保证】：通过 StripedSerialExecutor 保证串行
     */
    public void onTrigger(StrategyTrigger trigger) {
        executor.execute(instanceId, () -> {
            handle(trigger);
        });
    }
    
    /**
     * 实际处理逻辑（在串行执行器中运行）
     * 
     * 【硬约束】：
     * 1. 不查 DB
     * 2. 不抛异常（所有异常捕获并记录）
     * 3. 只在状态变化时写库
     */
    private void handle(StrategyTrigger trigger) {
        long seq = sequenceNumber.incrementAndGet();
        int stripeId = (int) (instanceId % executor.getStripeCount());
        
        try {
            // 1. 校验事件时间（可选：忽略过旧事件）
            StrategyState currentState = stateMachine.getCurrentState();
            if (shouldIgnore(trigger, currentState)) {
                log.debug("忽略过旧事件: instanceId={}, eventKey={}", instanceId, trigger.getEventKey());
                return;
            }
            
            // 2. 更新快照
            updateSnapshots(trigger);
            
            // 3. 更新状态机（N3 只更新 lastEventTime）
            stateMachine.onTrigger(trigger);
            
            // 4. 持久化状态（只在变化时写）
            currentState = stateMachine.getCurrentState();
            stateRepo.persistIfChanged(createInstanceProxy(), currentState);
            
            // 5. 打印 runtime 日志
            logRuntimeEvent(trigger, seq, stripeId, currentState);
            
        } catch (Exception e) {
            log.error("处理事件失败: instanceId={}, eventKey={}, seq={}", 
                instanceId, trigger.getEventKey(), seq, e);
            // 不抛异常，避免影响其他事件处理
        }
    }
    
    private boolean shouldIgnore(StrategyTrigger trigger, StrategyState state) {
        // 可选：如果事件时间比 lastEventTime 早太多（如 1 小时），忽略
        if (state.getLastEventTimeUtc() != null) {
            Duration diff = Duration.between(trigger.getAsOfTimeUtc(), state.getLastEventTimeUtc());
            if (diff.toMinutes() > 60) {
                return true;
            }
        }
        return false;
    }
    
    private void updateSnapshots(StrategyTrigger trigger) {
        switch (trigger.getTriggerType()) {
            case PRICE:
                if (trigger.getPrice() != null) {
                    latestPrice.update(trigger.getPrice(), trigger.getAsOfTimeUtc(), "N2_ROUTER");
                }
                break;
            case BAR_CLOSE:
                // 从 trigger 中提取 K 线数据（需要扩展 StrategyTrigger 或从 snapshot 获取）
                // TODO: 如何获取 K 线 OHLC 数据？
                latestBar.update(trigger.getTimeframe(), null, null, null, null, null, trigger.getAsOfTimeUtc());
                break;
            case SIGNAL:
                if (trigger.getSignalInfo() != null) {
                    Signal signal = trigger.getSignalInfo();
                    latestSignal.update(
                        trigger.getSignalConfigId(),
                        trigger.getSignalId(),
                        signal.getSignalDirectionHint(),
                        signal.getPrice(),
                        trigger.getAsOfTimeUtc()
                    );
                }
                break;
        }
    }
    
    private void logRuntimeEvent(StrategyTrigger trigger, long seq, int stripeId, StrategyState state) {
        // 使用专门的 logger
        Logger logger = LoggerFactory.getLogger("STRATEGY_RUNTIME");
        
        Map<String, Object> logData = new HashMap<>();
        logData.put("instanceId", instanceId);
        logData.put("userId", userId);
        logData.put("phase", state.getPhase().toString());
        logData.put("stripe", stripeId);
        logData.put("seq", seq);
        logData.put("type", trigger.getTriggerType().name());
        logData.put("eventKey", trigger.getEventKey());
        logData.put("asOf", trigger.getAsOfTimeUtc().toString());
        logData.put("pairId", tradingPairId);
        
        // 可选字段
        if (trigger.getTimeframe() != null) {
            logData.put("tf", trigger.getTimeframe());
        }
        
        // 状态摘要
        logData.put("side", state.getPositionSide());
        logData.put("qty", state.getPositionQty());
        if (state.getAvgEntryPrice() != null) {
            logData.put("avgEntry", state.getAvgEntryPrice().toString());
        }
        
        String json = objectMapper.writeValueAsString(logData);
        logger.info("runtime_event {}", json);
    }
    
    // Getters
    public Long getInstanceId() { return instanceId; }
    public StrategyState getState() { return stateMachine.getCurrentState(); }
    public LatestPriceSnapshot getLatestPrice() { return latestPrice; }
    public LatestBarSnapshot getLatestBar() { return latestBar; }
    public LatestSignalSnapshot getLatestSignal() { return latestSignal; }
    
    // 创建实例代理（用于持久化，避免持有完整 instance 对象）
    private StrategyInstance createInstanceProxy() {
        // 创建轻量代理对象，只包含持久化所需的字段
        // 避免持有完整的 StrategyInstance 对象（减少内存占用）
        StrategyInstance instance = new StrategyInstance();
        instance.setId(instanceId);
        instance.setUserId(userId);
        instance.setStrategyId(strategyId);  // 使用保存的 strategyId
        instance.setTradingPairId(tradingPairId);
        instance.setSignalConfigId(signalConfigId);
        instance.setStrategySymbol(strategySymbol);
        return instance;
    }
}
```

**验收标准**：
- [ ] 所有事件处理都通过 StripedSerialExecutor（串行保证）
- [ ] 不查 DB（所有数据启动时注入）
- [ ] 不抛异常（所有异常捕获）
- [ ] 只在状态变化时写库（变化检测）
- [ ] 日志包含 phase/stripe/seq 等关键信息

---

### Task 8：Runtime 管理器（优先级：P0）

#### 8.1 创建 StrategyRuntimeManager

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/manager/StrategyRuntimeManager.java`

**核心要求**：

```java
@Component
public class StrategyRuntimeManager {
    
    @Autowired
    private StrategyInstanceMapper instanceMapper;
    
    @Autowired
    private StrategyStateRepository stateRepo;
    
    @Autowired
    private StripedSerialExecutor executor;
    
    // Runtime 注册表（key = instanceId）
    private final ConcurrentHashMap<Long, StrategyRuntime> runtimes = new ConcurrentHashMap<>();
    
    @PostConstruct
    public void initialize() {
        log.info("开始初始化 StrategyRuntimeManager...");
        
        // 1. 加载所有启用的实例
        List<StrategyInstance> enabledInstances = instanceMapper.selectAllEnabled();
        log.info("发现 {} 个启用的策略实例", enabledInstances.size());
        
        // 2. 为每个实例创建 runtime
        for (StrategyInstance instance : enabledInstances) {
            try {
                createRuntime(instance);
            } catch (Exception e) {
                log.error("创建 runtime 失败: instanceId={}", instance.getId(), e);
            }
        }
        
        log.info("StrategyRuntimeManager 初始化完成: runtimeCount={}", runtimes.size());
    }
    
    /**
     * 创建 Runtime（用于启动装载或动态添加）
     */
    private void createRuntime(StrategyInstance instance) {
        // 1. 加载或初始化状态
        StrategyState initialState = stateRepo.loadOrInit(instance);
        
        // 2. 创建 runtime
        StrategyRuntime runtime = new StrategyRuntime(instance, initialState, stateRepo, executor);
        
        // 3. 注册
        StrategyRuntime existing = runtimes.putIfAbsent(instance.getId(), runtime);
        if (existing != null) {
            log.warn("Runtime 已存在: instanceId={}", instance.getId());
        } else {
            log.info("Runtime 已创建: instanceId={}, phase={}", 
                instance.getId(), initialState.getPhase());
        }
    }
    
    /**
     * 分发事件到对应的 Runtime（由 RuntimeDispatcher 调用）
     * 
     * @param instanceId 实例ID
     * @param trigger 触发事件
     */
    public void dispatch(Long instanceId, StrategyTrigger trigger) {
        StrategyRuntime runtime = runtimes.get(instanceId);
        if (runtime == null) {
            log.warn("Runtime 不存在，跳过事件: instanceId={}, eventKey={}", 
                instanceId, trigger.getEventKey());
            return;
        }
        
        runtime.onTrigger(trigger);
    }
    
    /**
     * 获取 Runtime（用于查询 API）
     */
    public StrategyRuntime getRuntime(Long instanceId) {
        return runtimes.get(instanceId);
    }
    
    /**
     * 获取所有 Runtime（用于查询 API）
     */
    public List<StrategyRuntime> getAllRuntimes() {
        return new ArrayList<>(runtimes.values());
    }
    
    @PreDestroy
    public void shutdown() {
        log.info("StrategyRuntimeManager 正在关闭...");
        runtimes.clear();
    }
}
```

**验收标准**：
- [ ] 启动时自动加载所有 enabled 实例
- [ ] 为每个实例创建 runtime 并恢复状态
- [ ] 提供 dispatch 方法供 N2 调用
- [ ] 提供查询方法供 API 使用

---

### Task 9：Runtime 分发器（连接 N2 与 N3，优先级：P0）

#### 9.1 修改 TriggerDispatcher（连接 N2 到 N3）

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/dispatcher/TriggerDispatcher.java`

**修改点**：在 `processTrigger` 方法中，不再直接打印日志，而是分发到 RuntimeManager

```java
@Component
public class TriggerDispatcher {
    
    // ... 原有字段 ...
    
    @Autowired
    private StrategyRuntimeManager runtimeManager;  // 新增
    
    private void processTrigger(StrategyTrigger trigger) {
        try {
            // 路由到实例
            List<Long> instanceIds = router.route(trigger);
            
            if (instanceIds.isEmpty()) {
                logger.debug("事件未路由到任何实例: eventKey={}", trigger.getEventKey());
                return;
            }
            
            // 【N3 改动】：不再打印日志，而是分发到 RuntimeManager
            for (Long instanceId : instanceIds) {
                runtimeManager.dispatch(instanceId, trigger);
            }
            
        } catch (Exception e) {
            logger.error("处理事件失败: eventKey={}", trigger.getEventKey(), e);
        }
    }
}
```

**验收标准**：
- [ ] N2 的路由结果正确分发到 N3 Runtime
- [ ] 保持异步特性（不阻塞上游线程）

---

### Task 10：运行态查询 API（优先级：P1）

#### 10.1 创建 StrategyRuntimeController

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/runtime/api/StrategyRuntimeController.java`

**必需接口**：

```java
@RestController
@RequestMapping("/api/strategy/runtime")
public class StrategyRuntimeController {
    
    @Autowired
    private StrategyRuntimeManager runtimeManager;
    
    /**
     * 查询所有实例的运行态列表
     */
    @GetMapping("/state/list")
    public Result<List<StrategyRuntimeVO>> listStates() {
        List<StrategyRuntime> runtimes = runtimeManager.getAllRuntimes();
        List<StrategyRuntimeVO> vos = runtimes.stream()
            .map(this::convertToVO)
            .collect(Collectors.toList());
        return Result.success(vos);
    }
    
    /**
     * 查询单个实例的运行态详情
     */
    @GetMapping("/state/{instanceId}")
    public Result<StrategyRuntimeDetailVO> getState(@PathVariable Long instanceId) {
        StrategyRuntime runtime = runtimeManager.getRuntime(instanceId);
        if (runtime == null) {
            return Result.error(404, "Runtime 不存在");
        }
        return Result.success(convertToDetailVO(runtime));
    }
    
    // 转换方法...
}
```

**VO 类**：

```java
public class StrategyRuntimeVO {
    private Long instanceId;
    private Long userId;
    private String strategySymbol;
    private String phase;
    private String positionSide;
    private BigDecimal positionQty;
    private BigDecimal avgEntryPrice;
    private Instant lastEventTimeUtc;
}
```

**验收标准**：
- [ ] 能查询所有实例的运行态
- [ ] 能查询单个实例的详情（包含快照）
- [ ] 返回数据与 DB 状态一致

---

## 四、N3 阶段 6 条红线（必须严格遵守）

### 红线 1：Runtime 不得用公共线程池

- ❌ 禁止：使用 `@Async` 或公共 `ExecutorService`
- ✅ 正确：只能通过 `StripedSerialExecutor.execute(instanceId, ...)` 进入

### 红线 2：不得在 Runtime 查 DB

- ❌ 禁止：在 `StrategyRuntime.handle()` 中查询任何表
- ✅ 正确：所有数据启动时注入（通过 Manager）

### 红线 3：不得高频 update `strategy_logic_state`

- ❌ 禁止：每个 PRICE 事件都 update
- ✅ 正确：只有在 `(phase, side, qty, avg)` 变化时才写库

### 红线 4：不得擅自推进 phase

- ❌ 禁止：N3 阶段从 IDLE → OPEN_PENDING
- ✅ 正确：只"承接已有 phase"，不主动迁移

### 红线 5：不得写 pnl

- ❌ 禁止：写入 `unrealized_pnl` 或 `realized_pnl`
- ✅ 正确：N3 阶段这两个字段统一写 `NULL`

### 红线 6：不得破坏 instance 串行

- ❌ 禁止：同一 instance 的事件并行处理
- ✅ 正确：通过 `StripedSerialExecutor` 保证串行

---

## 五、验收标准（DoD）

### 5.1 启动装载验收

**Given**：DB 有 10 个 enabled 实例，其中 3 个有 `strategy_logic_state` 记录

**When**：服务启动

**Then**：
- [ ] RuntimeManager 内存 runtime 数量 = 10
- [ ] 有 state 记录的 3 个实例正确恢复状态（phase/side/qty/avg）
- [ ] 没有 state 记录的 7 个实例自动初始化（IDLE/FLAT/0）
- [ ] API `/api/strategy/runtime/state/list` 返回 10 条记录

### 5.2 串行性证明验收

**Given**：同一 instance 并发发送 1000 个 PRICE 事件

**When**：运行 10 秒

**Then**：
- [ ] 日志中该 instance 的 `seq` 严格递增（1, 2, 3, ...）
- [ ] 所有事件都在同一个 `stripe` 中处理
- [ ] 无事件交错（可通过日志验证）

### 5.3 重启恢复验收

**Given**：
- DB 中某 instance 的 state 为 `OPENED/LONG/qty=1.0/avg=45000.0`
- 服务运行中处理了一些事件

**When**：重启服务

**Then**：
- [ ] API 查询仍显示 `OPENED/LONG/qty=1.0/avg=45000.0`
- [ ] Runtime 能继续接收新事件
- [ ] 状态不变（N3 不做决策）

### 5.4 写库节流验收

**Given**：PRICE 事件 2000 msg/s，持续 60 秒

**When**：压测

**Then**：
- [ ] `strategy_logic_state` 的 UPDATE 次数远小于事件数（< 100 次）
- [ ] DB 压力不增加（监控 `updated_at` 变化频率）
- [ ] 系统不 OOM、不 Full GC

### 5.5 快照更新验收

**Given**：
- 发送 PRICE 事件（price=45000）
- 发送 BAR_CLOSE 事件（timeframe=5m）
- 发送 SIGNAL 事件（signalId=test-001）

**When**：查询 API `/api/strategy/runtime/state/{instanceId}`

**Then**：
- [ ] `latestPrice.price = 45000`
- [ ] `latestBar.timeframe = 5m`
- [ ] `latestSignal.signalId = test-001`

---

## 六、开发顺序建议

1. **Task 1-2**：状态实体、Mapper、状态模型（基础数据层）
2. **Task 3**：快照模型（简单，可并行）
3. **Task 4**：串行执行器（**生命线，必须先做**）
4. **Task 5**：状态持久化仓库（恢复与持久化）
5. **Task 6**：状态机（最小实现，简单）
6. **Task 7**：策略运行时（核心逻辑）
7. **Task 8**：Runtime 管理器（启动装载）
8. **Task 9**：修改 N2 的 TriggerDispatcher（连接）
9. **Task 10**：查询 API（最后做）

---

## 七、关键注意事项

### 7.1 数据库约束

建议添加唯一约束（如果还没有）：

```sql
ALTER TABLE strategy_logic_state 
ADD UNIQUE KEY uk_instance (strategy_instance_id);
```

### 7.2 日志配置

确保 `log4j2.xml` 中配置了 `STRATEGY_RUNTIME` logger：

```xml
<Logger name="STRATEGY_RUNTIME" level="INFO" additivity="false">
    <AppenderRef ref="Console"/>
    <AppenderRef ref="File"/>
</Logger>
```

### 7.3 监控指标

建议暴露以下 Metrics（使用 Micrometer）：

- `strategy_runtime_count`：Runtime 数量
- `strategy_runtime_stripe_queue_size{stripe}`：每个 stripe 的队列长度
- `strategy_runtime_stripe_rejected_total{stripe}`：每个 stripe 的拒绝次数
- `strategy_runtime_state_write_total`：状态写库次数（用于验证节流）

---

## 八、总结

N3 阶段的交付本质：**"活着 + 记忆 + 有序"**

- ✅ 活着：每个 enabled 实例都有 runtime
- ✅ 记忆：状态可持久化、可恢复
- ✅ 有序：同一 instance 严格串行

**N3 不做决策、不写 intent、不接真实下单**。守住 6 条红线，N3 才能成为后续 N4/N5/N6/N7 的坚实基础。

---

**文档版本**：v1.0  
**最后更新**：2024-01-XX  
**负责人**：开发团队

