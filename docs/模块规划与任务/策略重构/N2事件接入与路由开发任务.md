# N2 阶段：事件接入与路由开发任务

> **核心目标**：接入并打印三类事件（BarClosedEvent、PriceTickEvent、SignalReceivedEvent），且能定位到受影响的 strategy_instance，做到正确路由、幂等去重、异步消费、可压测。

---

## 1. 目标与边界

### 1.1 核心目标

1. **事件接入**：三类事件能进入系统
   - `BarClosedEvent`（K 线闭合）
   - `PriceTickEvent`（价格更新/最新价）
   - `SignalReceivedEvent`（外部信号到达）

2. **正确路由**：事件能映射到对应的 `strategy_instance_id`
   - BAR_CLOSE：`tradingPairId + timeframe` → enabled instances
   - PRICE：`tradingPairId` → enabled instances
   - SIGNAL：`signalConfigId` → enabled instances

3. **幂等去重**：30 秒内相同 `eventKey` 只处理一次

4. **异步消费**：事件处理不阻塞行情/聚合线程

5. **统一打印**：可 grep、可审计、可压测的日志格式

### 1.2 输入依赖

- ✅ N1 已完成：`strategy_instance` 表可查，`enabled` 状态可用
- ✅ `trading_pair` 表已存在
- ✅ `signal_config` 表已存在

### 1.3 输出交付

- ✅ 事件进入系统 → 路由到实例 → 打印日志
- ✅ 重复事件不刷屏（30s TTL 去重）
- ✅ 事件处理不阻塞上游线程（异步）
- ✅ 可压测（路由索引缓存）

### 1.4 边界裁决

- ✅ **N2 只做"接入与打印"**，不做决策、不写 `rules_record`、不写 `intent_record`
- ✅ 不做规则结算、状态机推进（这些属于 N3/N5/N6）
- ✅ 不做 UI（最多加"测试触发器"入口可选）

---

## 2. 技术架构设计

### 2.1 整体流程

```
外部事件源
    ↓
Adapter (轻量转换)
    ↓
TriggerIngress (统一入口)
    ↓
Deduplicator (30s TTL 去重)
    ↓
EventRouter (路由到 instanceIds)
    ↓
异步队列 (BlockingQueue + ThreadPool)
    ↓
统一打印 (JSON 单行日志)
```

### 2.2 核心组件

1. **StrategyTrigger**：统一事件模型
2. **TriggerIngress**：事件接入接口
3. **Adapter**：三类事件适配器（BarClosed、PriceTick、SignalReceived）
4. **TriggerDeduplicator**：幂等去重器
5. **EventRouter**：路由引擎（含索引缓存）
6. **TriggerDispatcher**：异步分发器
7. **TriggerLogger**：统一日志打印

---

## 3. 详细任务拆解

### 3.1 后端任务

#### Task 1：定义统一事件模型（StrategyTrigger）

**包路径**
```
com.qyl.v2trade.business.strategy.runtime.trigger
```

**核心类**

1. **TriggerType 枚举**
```java
package com.qyl.v2trade.business.strategy.runtime.trigger;

public enum TriggerType {
    BAR_CLOSE,  // K 线闭合
    PRICE,      // 价格更新
    SIGNAL      // 外部信号
}
```

2. **StrategyTrigger 类**
```java
package com.qyl.v2trade.business.strategy.runtime.trigger;

import java.math.BigDecimal;
import java.time.Instant;

public class StrategyTrigger {
    private TriggerType triggerType;
    private String eventKey;              // 幂等键，必须全局可复现
    private Instant asOfTimeUtc;          // 统一 UTC 语义
    
    // BAR_CLOSE / PRICE 必填
    private Long tradingPairId;
    private String strategySymbol;        // 用于打印/排障，可选
    
    // BAR_CLOSE 必填
    private String timeframe;             // 如 "5m", "1h"
    
    // SIGNAL 必填
    private Long signalConfigId;
    private String signalId;              // 强烈建议提供，用于幂等与追踪
    
    // PRICE 必填；SIGNAL 可带
    private BigDecimal price;
    
    // SIGNAL 详细信息
    private Signal signalInfo;
    
    // Getters and Setters...
}
```

3. **eventKey 生成规范（必须冻结）**

```java
public class EventKeyBuilder {
    /**
     * BAR_CLOSE: BAR:{pairId}:{timeframe}:{barCloseEpochMillis}
     */
    public static String buildBarCloseKey(Long pairId, String timeframe, long barCloseEpochMillis) {
        return String.format("BAR:%d:%s:%d", pairId, timeframe, barCloseEpochMillis);
    }
    
    /**
     * PRICE: PRICE:{pairId}:{priceEpochMillis or seq}
     * 若没有 seq，用毫秒时间；高频时会更"稀疏去重"，可接受（N2 只打印）
     */
    public static String buildPriceKey(Long pairId, long priceEpochMillis) {
        return String.format("PRICE:%d:%d", pairId, priceEpochMillis);
    }
    
    /**
     * SIGNAL: SIGNAL:{signalConfigId}:{signalId}
     * signalId 必须唯一；没有则退化为 hash(payload)
     */
    public static String buildSignalKey(Long signalConfigId, String signalId) {
        return String.format("SIGNAL:%d:%s", signalConfigId, signalId);
    }
}
```

**验收标准**
- [ ] TriggerType 枚举定义完整
- [ ] StrategyTrigger 类字段完整，包含所有必要字段
- [ ] eventKey 生成方法符合规范，可复现
- [ ] 单测覆盖三种 eventKey 生成场景

---

#### Task 2：事件接入层（Adapter / Ingress）

**包路径**
```
com.qyl.v2trade.business.strategy.runtime.ingress
```

**核心接口**

```java
package com.qyl.v2trade.business.strategy.runtime.ingress;

import com.qyl.v2trade.business.strategy.runtime.trigger.StrategyTrigger;

public interface TriggerIngress {
    /**
     * 接收事件（轻量转换，不查库、不路由、不重逻辑）
     */
    void accept(StrategyTrigger trigger);
}
```

**三类 Adapter（实际接入实现）**

> **重要说明**：由于价格和K线都是订阅的，信号是通过 Webhook 接收的，需要将这些现有的事件源接入到 N2 事件系统中。

#### 1. **BarClosedIngressAdapter（从 K 线聚合器接入）**

**接入方式**：订阅 `KlineAggregatorImpl` 的 `aggregationCallback`

```java
package com.qyl.v2trade.business.strategy.runtime.ingress;

import com.qyl.v2trade.business.strategy.runtime.trigger.StrategyTrigger;
import com.qyl.v2trade.business.strategy.runtime.trigger.TriggerType;
import com.qyl.v2trade.business.strategy.runtime.trigger.EventKeyBuilder;
import com.qyl.v2trade.market.aggregation.event.AggregatedKLine;
import com.qyl.v2trade.business.system.service.TradingPairService;
import com.qyl.v2trade.business.system.model.entity.TradingPair;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.time.Instant;

@Slf4j
@Component
public class BarClosedIngressAdapter {
    
    @Autowired
    private TriggerIngress triggerIngress;
    
    @Autowired(required = false)
    private TradingPairService tradingPairService;
    
    @Autowired(required = false)
    private com.qyl.v2trade.market.aggregation.core.KlineAggregator klineAggregator;
    
    /**
     * 初始化：订阅 K 线聚合器的回调
     */
    @PostConstruct
    public void init() {
        if (klineAggregator != null) {
            // 设置聚合完成回调，当 K 线窗口闭合时触发
            klineAggregator.setAggregationCallback(this::onBarClosed);
            log.info("BarClosedIngressAdapter 已订阅 K 线聚合器回调");
        } else {
            log.warn("KlineAggregator 未找到，BarClosedIngressAdapter 无法接入");
        }
    }
    
    /**
     * 从 K 线聚合器接收 bar close 事件
     * @param aggregatedKLine 聚合完成的 K 线
     */
    private void onBarClosed(AggregatedKLine aggregatedKLine) {
        try {
            // 1. 根据 symbol 查找 tradingPairId
            Long tradingPairId = getTradingPairId(aggregatedKLine.symbol());
            if (tradingPairId == null) {
                log.warn("无法找到交易对ID，跳过事件: symbol={}", aggregatedKLine.symbol());
                return;
            }
            
            // 2. 计算 K 线闭合时间（timestamp 是窗口起始时间，闭合时间是窗口结束时间）
            // 根据 period 计算窗口时长
            long windowDurationMs = calculateWindowDurationMs(aggregatedKLine.period());
            long barCloseTimeMillis = aggregatedKLine.timestamp() + windowDurationMs;
            Instant barCloseTimeUtc = Instant.ofEpochMilli(barCloseTimeMillis);
            
            // 3. 生成 eventKey
            String eventKey = EventKeyBuilder.buildBarCloseKey(
                tradingPairId, 
                aggregatedKLine.period(), 
                barCloseTimeMillis
            );
            
            // 4. 构建 StrategyTrigger
            StrategyTrigger trigger = new StrategyTrigger();
            trigger.setTriggerType(TriggerType.BAR_CLOSE);
            trigger.setEventKey(eventKey);
            trigger.setAsOfTimeUtc(barCloseTimeUtc);
            trigger.setTradingPairId(tradingPairId);
            trigger.setStrategySymbol(aggregatedKLine.symbol());
            trigger.setTimeframe(aggregatedKLine.period());
            
            // 5. 发送到事件系统
            triggerIngress.accept(trigger);
            
        } catch (Exception e) {
            log.error("处理 K 线闭合事件失败: symbol={}, period={}, timestamp={}", 
                aggregatedKLine.symbol(), aggregatedKLine.period(), aggregatedKLine.timestamp(), e);
        }
    }
    
    /**
     * 根据 symbol 获取 tradingPairId
     */
    private Long getTradingPairId(String symbol) {
        if (tradingPairService == null) {
            return null;
        }
        try {
            // 先尝试 SWAP，再尝试 SPOT
            TradingPair pair = tradingPairService.getBySymbolAndMarketType(symbol, "SWAP");
            if (pair == null) {
                pair = tradingPairService.getBySymbolAndMarketType(symbol, "SPOT");
            }
            return pair != null ? pair.getId() : null;
        } catch (Exception e) {
            log.warn("获取 tradingPairId 失败: symbol={}", symbol, e);
            return null;
        }
    }
    
    /**
     * 计算窗口时长（毫秒）
     */
    private long calculateWindowDurationMs(String period) {
        return switch (period) {
            case "1m" -> 60_000L;
            case "5m" -> 300_000L;
            case "15m" -> 900_000L;
            case "30m" -> 1_800_000L;
            case "1h" -> 3_600_000L;
            case "4h" -> 14_400_000L;
            case "1d" -> 86_400_000L;
            default -> {
                log.warn("未知周期，使用默认1分钟: period={}", period);
                yield 60_000L;
            }
        };
    }
}
```

#### 2. **PriceTickIngressAdapter（从价格订阅接入）**

**接入方式**：订阅 `PriceEventBus` 的价格事件

```java
package com.qyl.v2trade.business.strategy.runtime.ingress;

import com.qyl.v2trade.business.strategy.runtime.trigger.StrategyTrigger;
import com.qyl.v2trade.business.strategy.runtime.trigger.TriggerType;
import com.qyl.v2trade.business.strategy.runtime.trigger.EventKeyBuilder;
import com.qyl.v2trade.market.subscription.collector.eventbus.PriceEventBus;
import com.qyl.v2trade.market.model.event.PriceTick;
import com.qyl.v2trade.business.system.service.TradingPairService;
import com.qyl.v2trade.business.system.model.entity.TradingPair;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.time.Instant;

@Slf4j
@Component
public class PriceTickIngressAdapter {
    
    @Autowired
    private TriggerIngress triggerIngress;
    
    @Autowired(required = false)
    private PriceEventBus priceEventBus;
    
    @Autowired(required = false)
    private TradingPairService tradingPairService;
    
    /**
     * 初始化：订阅价格事件总线
     */
    @PostConstruct
    public void init() {
        if (priceEventBus != null) {
            // 订阅价格事件
            priceEventBus.subscribe(this::onPriceTick);
            log.info("PriceTickIngressAdapter 已订阅价格事件总线");
        } else {
            log.warn("PriceEventBus 未找到，PriceTickIngressAdapter 无法接入");
        }
    }
    
    /**
     * 从价格事件总线接收价格事件
     * @param tick 价格 Tick 事件
     */
    private void onPriceTick(PriceTick tick) {
        try {
            // 1. 根据 symbol 查找 tradingPairId
            Long tradingPairId = getTradingPairId(tick.symbol());
            if (tradingPairId == null) {
                log.debug("无法找到交易对ID，跳过价格事件: symbol={}", tick.symbol());
                return;
            }
            
            // 2. 转换时间戳为 Instant
            Instant priceTimeUtc = Instant.ofEpochMilli(tick.timestamp());
            
            // 3. 生成 eventKey
            String eventKey = EventKeyBuilder.buildPriceKey(
                tradingPairId, 
                tick.timestamp()
            );
            
            // 4. 构建 StrategyTrigger
            StrategyTrigger trigger = new StrategyTrigger();
            trigger.setTriggerType(TriggerType.PRICE);
            trigger.setEventKey(eventKey);
            trigger.setAsOfTimeUtc(priceTimeUtc);
            trigger.setTradingPairId(tradingPairId);
            trigger.setStrategySymbol(tick.symbol());
            trigger.setPrice(tick.price());
            
            // 5. 发送到事件系统
            triggerIngress.accept(trigger);
            
        } catch (Exception e) {
            log.error("处理价格事件失败: symbol={}, price={}, timestamp={}", 
                tick.symbol(), tick.price(), tick.timestamp(), e);
        }
    }
    
    /**
     * 根据 symbol 获取 tradingPairId
     */
    private Long getTradingPairId(String symbol) {
        if (tradingPairService == null) {
            return null;
        }
        try {
            // 先尝试 SWAP，再尝试 SPOT
            TradingPair pair = tradingPairService.getBySymbolAndMarketType(symbol, "SWAP");
            if (pair == null) {
                pair = tradingPairService.getBySymbolAndMarketType(symbol, "SPOT");
            }
            return pair != null ? pair.getId() : null;
        } catch (Exception e) {
            log.warn("获取 tradingPairId 失败: symbol={}", symbol, e);
            return null;
        }
    }
}
```

#### 3. **SignalReceivedIngressAdapter（从信号 Webhook 接入）**

**接入方式**：在 `SignalService.ingestSignal` 成功后触发

```java
package com.qyl.v2trade.business.strategy.runtime.ingress;

import com.qyl.v2trade.business.strategy.runtime.trigger.StrategyTrigger;
import com.qyl.v2trade.business.strategy.runtime.trigger.TriggerType;
import com.qyl.v2trade.business.strategy.runtime.trigger.EventKeyBuilder;
import com.qyl.v2trade.business.signal.model.entity.Signal;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.time.Instant;

@Slf4j
@Component
public class SignalReceivedIngressAdapter {
    
    @Autowired
    private TriggerIngress triggerIngress;
    
    /**
     * 从信号模块接收信号事件
     * 
     * 注意：这个方法由 SignalService.ingestSignal 在信号入库成功后调用
     * 
     * @param signal 已入库的信号实体
     */
    public void onSignalReceived(Signal signal) {
        try {
            // 1. 获取必要字段
            Long signalConfigId = signal.getSignalConfigId();
            if (signalConfigId == null) {
                log.warn("信号缺少 signalConfigId，跳过事件: signalId={}", signal.getId());
                return;
            }
            
            // 2. 生成 signalId（优先使用 signal.id，如果没有则使用其他唯一标识）
            String signalId = String.valueOf(signal.getId());
            if (signal.getSignalId() != null && !signal.getSignalId().isEmpty()) {
                signalId = signal.getSignalId();
            }
            
            // 3. 生成 eventKey
            String eventKey = EventKeyBuilder.buildSignalKey(signalConfigId, signalId);
            
            // 4. 获取接收时间（UTC）
            Instant receivedTimeUtc = signal.getReceivedAt() != null 
                ? signal.getReceivedAt().toInstant() 
                : Instant.now();
            
            // 5. 构建 StrategyTrigger
            StrategyTrigger trigger = new StrategyTrigger();
            trigger.setTriggerType(TriggerType.SIGNAL);
            trigger.setEventKey(eventKey);
            trigger.setAsOfTimeUtc(receivedTimeUtc);
            trigger.setSignalConfigId(signalConfigId);
            trigger.setSignalId(signalId);
            trigger.setSignalInfo(signal);
            
            // 如果有价格信息
            if (signal.getPrice() != null) {
                trigger.setPrice(signal.getPrice());
            }
            
            // 6. 发送到事件系统
            triggerIngress.accept(trigger);
            
        } catch (Exception e) {
            log.error("处理信号事件失败: signalId={}, signalConfigId={}", 
                signal.getId(), signal.getSignalConfigId(), e);
        }
    }
}
```

**修改 SignalService 实现类**：在 `ingestSignal` 成功后调用 Adapter

在 `SignalServiceImpl.ingestSignal()` 方法的最后，信号入库成功后添加：

```java
@Autowired(required = false)
private SignalReceivedIngressAdapter signalReceivedAdapter;

// 在 ingestSignal 方法中，信号保存成功后：
if (signalReceivedAdapter != null) {
    try {
        signalReceivedAdapter.onSignalReceived(signal);
    } catch (Exception e) {
        log.error("发送信号事件到策略系统失败，但不影响信号入库: signalId={}", signal.getId(), e);
        // 不抛出异常，确保信号入库不受影响
    }
}
```

**硬要求**
- ✅ Adapter 里只做"轻量转换"，不能查库、不能路由、不能重逻辑（避免阻塞上游线程）
- ⚠️ **注意**：由于需要根据 symbol 查找 tradingPairId，这个查询是必要的，但应该：
  - 使用缓存（TradingPairService 内部应该有缓存）
  - 如果找不到 tradingPairId，记录警告并跳过事件（不抛异常，避免影响上游）

**接入点说明**

1. **BarClosedIngressAdapter**：
   - 接入点：`KlineAggregatorImpl.setAggregationCallback()`
   - 触发时机：K 线聚合窗口完成时（`handleWindowComplete`）
   - 需要配置：在 Spring 配置中确保 `KlineAggregatorImpl` 的 Bean 存在

2. **PriceTickIngressAdapter**：
   - 接入点：`PriceEventBus.subscribe()`
   - 触发时机：WebSocket 收到价格更新时
   - 需要配置：确保 `PriceEventBus` 的 Bean 存在

3. **SignalReceivedIngressAdapter**：
   - 接入点：`SignalService.ingestSignal()` 成功后
   - 触发时机：信号 Webhook 接收并入库成功后
   - 需要修改：在 `SignalServiceImpl.ingestSignal()` 中调用 Adapter

**验收标准**
- [ ] 三类 Adapter 都能正确构建 StrategyTrigger
- [ ] eventKey 生成正确且可复现
- [ ] K 线闭合事件能正确接入（验证聚合回调）
- [ ] 价格事件能正确接入（验证事件总线订阅）
- [ ] 信号事件能正确接入（验证 Webhook 后调用）
- [ ] 单测覆盖三类事件转换场景
- [ ] 找不到 tradingPairId 时能优雅降级（记录警告，不抛异常）

---

#### Task 3：幂等去重（Deduplicator）

**包路径**
```
com.qyl.v2trade.business.strategy.runtime.dedup
```

**核心接口**

```java
package com.qyl.v2trade.business.strategy.runtime.dedup;

public interface TriggerDeduplicator {
    /**
     * 判断是否应该处理该事件
     * @param eventKey 事件键
     * @return true 表示应该处理，false 表示重复事件应跳过
     */
    boolean shouldProcess(String eventKey);
}
```

**实现类（使用 Caffeine）**

```java
package com.qyl.v2trade.business.strategy.runtime.dedup;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;

@Component
public class CaffeineTriggerDeduplicator implements TriggerDeduplicator {
    
    private final Cache<String, Boolean> dedupCache;
    
    public CaffeineTriggerDeduplicator() {
        this.dedupCache = Caffeine.newBuilder()
            .expireAfterWrite(30, TimeUnit.SECONDS)
            .maximumSize(100_000)  // 防止内存无限增长
            .build();
    }
    
    @Override
    public boolean shouldProcess(String eventKey) {
        // 如果已存在，返回 false（跳过）
        if (dedupCache.getIfPresent(eventKey) != null) {
            return false;
        }
        
        // 第一次遇到，标记并返回 true
        dedupCache.put(eventKey, true);
        return true;
    }
}
```

**验收标准**
- [ ] 30 秒内相同 eventKey 返回 false
- [ ] 超过 30 秒后相同 eventKey 返回 true
- [ ] 单测覆盖 TTL 过期场景
- [ ] 压测验证内存不会无限增长

---

#### Task 4：路由层（EventRouter）

**包路径**
```
com.qyl.v2trade.business.strategy.runtime.router
```

**核心接口**

```java
package com.qyl.v2trade.business.strategy.runtime.router;

import com.qyl.v2trade.business.strategy.runtime.trigger.StrategyTrigger;
import java.util.List;

public interface EventRouter {
    /**
     * 路由事件到对应的 strategy_instance_id 列表
     * @param trigger 事件
     * @return 受影响的实例ID列表（只返回 enabled 的实例）
     */
    List<Long> route(StrategyTrigger trigger);
    
    /**
     * 根据 instanceId 获取 userId（从缓存获取，不查库）
     * 用于 TriggerLogger，避免 per-instance 查库导致 DB 热点
     * 
     * @param instanceId 实例ID
     * @return 用户ID，如果缓存中不存在则返回 null
     */
    Long getUserIdByInstanceId(Long instanceId);
}
```

**实现类（含索引缓存）**

```java
package com.qyl.v2trade.business.strategy.runtime.router;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.qyl.v2trade.business.strategy.mapper.StrategyInstanceMapper;
import com.qyl.v2trade.business.strategy.model.entity.StrategyInstance;
import com.qyl.v2trade.business.strategy.runtime.trigger.StrategyTrigger;
import com.qyl.v2trade.business.strategy.runtime.trigger.TriggerType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Component
public class CachedEventRouter implements EventRouter {
    
    private static final Logger logger = LoggerFactory.getLogger(CachedEventRouter.class);
    
    @Autowired
    private StrategyInstanceMapper instanceMapper;
    
    // 索引缓存：tradingPairId -> List<instanceId>
    private Cache<Long, List<Long>> pairIndexCache;
    
    // 索引缓存：signalConfigId -> List<instanceId>
    private Cache<Long, List<Long>> signalIndexCache;
    
    public CachedEventRouter() {
        // TTL 30~60s 自动刷新（不依赖 UI/事件联动）
        this.pairIndexCache = Caffeine.newBuilder()
            .expireAfterWrite(60, TimeUnit.SECONDS)
            .maximumSize(10_000)
            .build();
        
        this.signalIndexCache = Caffeine.newBuilder()
            .expireAfterWrite(60, TimeUnit.SECONDS)
            .maximumSize(10_000)
            .build();
    }
    
    @PostConstruct
    public void warmup() {
        // 启动时预热索引
        refreshAllIndexes();
        logger.info("EventRouter 索引预热完成");
    }
    
    @Override
    public List<Long> route(StrategyTrigger trigger) {
        TriggerType type = trigger.getTriggerType();
        
        switch (type) {
            case BAR_CLOSE:
            case PRICE:
                return routeByTradingPair(trigger.getTradingPairId());
                
            case SIGNAL:
                return routeBySignalConfig(trigger.getSignalConfigId());
                
            default:
                logger.warn("未知的触发类型: {}", type);
                return List.of();
        }
    }
    
    private List<Long> routeByTradingPair(Long tradingPairId) {
        if (tradingPairId == null) {
            return List.of();
        }
        
        return pairIndexCache.get(tradingPairId, key -> {
            List<StrategyInstance> instances = instanceMapper.selectEnabledByTradingPairId(key);
            return instances.stream()
                .map(StrategyInstance::getId)
                .collect(Collectors.toList());
        });
    }
    
    private List<Long> routeBySignalConfig(Long signalConfigId) {
        if (signalConfigId == null) {
            return List.of();
        }
        
        return signalIndexCache.get(signalConfigId, key -> {
            List<StrategyInstance> instances = instanceMapper.selectEnabledBySignalConfigId(key);
            return instances.stream()
                .map(StrategyInstance::getId)
                .collect(Collectors.toList());
        });
    }
    
    /**
     * 刷新所有索引（可用于手动触发或定时刷新）
     */
    public void refreshAllIndexes() {
        List<StrategyInstance> allEnabled = instanceMapper.selectAllEnabled();
        
        // 按 tradingPairId 分组
        Map<Long, List<Long>> pairMap = allEnabled.stream()
            .collect(Collectors.groupingBy(
                StrategyInstance::getTradingPairId,
                Collectors.mapping(StrategyInstance::getId, Collectors.toList())
            ));
        pairMap.forEach((pairId, instanceIds) -> {
            pairIndexCache.put(pairId, instanceIds);
        });
        
        // 按 signalConfigId 分组（注意：signalConfigId 可能为 null，需要处理）
        Map<Long, List<Long>> signalMap = allEnabled.stream()
            .filter(inst -> inst.getSignalConfigId() != null && inst.getSignalConfigId() > 0)
            .collect(Collectors.groupingBy(
                StrategyInstance::getSignalConfigId,
                Collectors.mapping(StrategyInstance::getId, Collectors.toList())
            ));
        signalMap.forEach((signalId, instanceIds) -> {
            signalIndexCache.put(signalId, instanceIds);
        });
        
        // 同时构建 instanceId -> userId 缓存（用于 TriggerLogger，避免查库）
        allEnabled.forEach(inst -> {
            instanceUserIdCache.put(inst.getId(), inst.getUserId());
        });
        
        logger.debug("索引刷新完成: pairIndex={}, signalIndex={}, instanceUserCache={}", 
            pairMap.size(), signalMap.size(), instanceUserIdCache.estimatedSize());
    }
}
```

**Mapper 扩展方法**

在 `StrategyInstanceMapper` 中新增：

```java
package com.qyl.v2trade.business.strategy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.qyl.v2trade.business.strategy.model.entity.StrategyInstance;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;

@Mapper
public interface StrategyInstanceMapper extends BaseMapper<StrategyInstance> {
    
    /**
     * 根据交易对ID查询启用的实例
     */
    List<StrategyInstance> selectEnabledByTradingPairId(@Param("tradingPairId") Long tradingPairId);
    
    /**
     * 根据信号配置ID查询启用的实例
     */
    List<StrategyInstance> selectEnabledBySignalConfigId(@Param("signalConfigId") Long signalConfigId);
    
    /**
     * 查询所有启用的实例（用于启动预热索引）
     */
    List<StrategyInstance> selectAllEnabled();
}
```

**Mapper XML（MyBatis）**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.qyl.v2trade.business.strategy.mapper.StrategyInstanceMapper">
    
    <select id="selectEnabledByTradingPairId" resultType="com.qyl.v2trade.business.strategy.model.entity.StrategyInstance">
        SELECT id, user_id, trading_pair_id, signal_config_id, strategy_symbol, enabled
        FROM strategy_instance
        WHERE trading_pair_id = #{tradingPairId}
          AND enabled = 1
          AND deleted = 0
    </select>
    
    <select id="selectEnabledBySignalConfigId" resultType="com.qyl.v2trade.business.strategy.model.entity.StrategyInstance">
        SELECT id, user_id, trading_pair_id, signal_config_id, strategy_symbol, enabled
        FROM strategy_instance
        WHERE signal_config_id = #{signalConfigId}
          AND enabled = 1
          AND deleted = 0
    </select>
    
    <select id="selectAllEnabled" resultType="com.qyl.v2trade.business.strategy.model.entity.StrategyInstance">
        SELECT id, user_id, trading_pair_id, signal_config_id, strategy_symbol, enabled
        FROM strategy_instance
        WHERE enabled = 1
          AND deleted = 0
    </select>
    
</mapper>
```

**验收标准**
- [ ] BAR_CLOSE/PRICE 能正确路由到 tradingPairId 对应的实例
- [ ] SIGNAL 能正确路由到 signalConfigId 对应的实例
- [ ] 索引缓存 TTL 生效，自动刷新
- [ ] 启动时预热索引
- [ ] 单测覆盖三种路由场景

---

#### Task 5：异步消费（Dispatcher）

**包路径**
```
com.qyl.v2trade.business.strategy.runtime.dispatcher
```

**核心类**

```java
package com.qyl.v2trade.business.strategy.runtime.dispatcher;

import com.qyl.v2trade.business.strategy.runtime.dedup.TriggerDeduplicator;
import com.qyl.v2trade.business.strategy.runtime.router.EventRouter;
import com.qyl.v2trade.business.strategy.runtime.trigger.StrategyTrigger;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

@Component
public class TriggerDispatcher {
    
    private static final Logger logger = LoggerFactory.getLogger(TriggerDispatcher.class);
    
    @Autowired
    private TriggerDeduplicator deduplicator;
    
    @Autowired
    private EventRouter router;
    
    @Autowired
    private TriggerLogger triggerLogger;
    
    // 队列：BAR_CLOSE/SIGNAL 高优先级，PRICE 低优先级
    private final BlockingQueue<StrategyTrigger> highPriorityQueue = new LinkedBlockingQueue<>(10_000);
    private final BlockingQueue<StrategyTrigger> lowPriorityQueue = new LinkedBlockingQueue<>(50_000);
    
    // 线程池
    private ThreadPoolExecutor executor;
    
    // 线程计数器（必须在类字段最上方声明，避免初始化顺序问题）
    private final AtomicInteger workerCounter = new AtomicInteger(0);
    
    @PostConstruct
    public void init() {
        // 核心线程数 = CPU 核心数
        int corePoolSize = Runtime.getRuntime().availableProcessors();
        // 最大线程数 = 核心数 * 2
        int maxPoolSize = corePoolSize * 2;
        
        // 线程工厂（单独抽取，避免示例代码被直接 copy 后踩坑）
        ThreadFactory threadFactory = r -> {
            Thread t = new Thread(r, "strategy-trigger-worker-" + workerCounter.getAndIncrement());
            t.setDaemon(false);
            return t;
        };
        
        executor = new ThreadPoolExecutor(
            corePoolSize,
            maxPoolSize,
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000),
            threadFactory,
            new ThreadPoolExecutor.CallerRunsPolicy()  // 队列满时由调用线程执行
        );
        
        // 启动消费线程
        startConsumer();
        
        logger.info("TriggerDispatcher 初始化完成: corePoolSize={}, maxPoolSize={}", 
            corePoolSize, maxPoolSize);
    }
    
    private void startConsumer() {
        // 高优先级队列消费者
        executor.submit(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    StrategyTrigger trigger = highPriorityQueue.take();
                    processTrigger(trigger);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                } catch (Exception e) {
                    logger.error("处理高优先级事件失败", e);
                }
            }
        });
        
        // 低优先级队列消费者
        executor.submit(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    StrategyTrigger trigger = lowPriorityQueue.take();
                    processTrigger(trigger);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                } catch (Exception e) {
                    logger.error("处理低优先级事件失败", e);
                }
            }
        });
    }
    
    /**
     * 接收事件（由 TriggerIngress 调用）
     */
    public void dispatch(StrategyTrigger trigger) {
        // 幂等去重
        if (!deduplicator.shouldProcess(trigger.getEventKey())) {
            logger.debug("事件已去重，跳过: eventKey={}", trigger.getEventKey());
            return;
        }
        
        // 根据类型选择队列
        BlockingQueue<StrategyTrigger> queue = 
            (trigger.getTriggerType() == TriggerType.PRICE) ? lowPriorityQueue : highPriorityQueue;
        
        // 尝试入队
        boolean offered = queue.offer(trigger);
        if (!offered) {
            // 队列满：低优先级事件丢弃并打 warn；高优先级事件尽量不丢
            if (trigger.getTriggerType() == TriggerType.PRICE) {
                logger.warn("低优先级队列满，丢弃事件: eventKey={}", trigger.getEventKey());
            } else {
                logger.error("高优先级队列满，事件可能丢失: eventKey={}", trigger.getEventKey());
                // 可以考虑降级到低优先级队列或同步处理
            }
        }
    }
    
    private void processTrigger(StrategyTrigger trigger) {
        try {
            // 路由到实例
            List<Long> instanceIds = router.route(trigger);
            
            if (instanceIds.isEmpty()) {
                logger.debug("事件未路由到任何实例: eventKey={}", trigger.getEventKey());
                return;
            }
            
            // 为每个实例打印日志
            // 【重要】userId 等信息从路由缓存中获取，不查库（见 6.5.1）
            for (Long instanceId : instanceIds) {
                // 从路由缓存中获取 userId（从 CachedEventRouter 的 instanceUserIdCache 获取）
                Long userId = router.getUserIdByInstanceId(instanceId);  // 从缓存获取，不查库
                if (userId == null) {
                    logger.warn("无法从路由缓存获取 userId，跳过日志: instanceId={}", instanceId);
                    continue;
                }
                triggerLogger.log(trigger, instanceId, userId);
            }
            
        } catch (Exception e) {
            logger.error("处理事件失败: eventKey={}", trigger.getEventKey(), e);
        }
    }
    
    @PreDestroy
    public void shutdown() {
        if (executor != null) {
            executor.shutdown();
            try {
                if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

**验收标准**
- [ ] 事件能正确入队
- [ ] 队列满时有背压策略（低优先级丢弃，高优先级尽量不丢）
- [ ] 异步消费不阻塞调用线程
- [ ] 压测下系统稳定，不 OOM、不大量 Full GC

---

#### Task 6：统一打印规范（TriggerLogger）

**包路径**
```
com.qyl.v2trade.business.strategy.runtime.logger
```

**核心类**

```java
package com.qyl.v2trade.business.strategy.runtime.logger;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.qyl.v2trade.business.strategy.mapper.StrategyInstanceMapper;
import com.qyl.v2trade.business.strategy.model.entity.StrategyInstance;
import com.qyl.v2trade.business.strategy.runtime.trigger.StrategyTrigger;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Component
public class TriggerLogger {
    
    private static final Logger logger = LoggerFactory.getLogger("STRATEGY_TRIGGER");
    
    @Autowired
    private ObjectMapper objectMapper;
    
    /**
     * 打印事件路由日志（JSON 单行格式）
     * 
     * 【重要】此方法不查库，userId 等信息由 EventRouter 在路由时提供
     * 避免一个事件路由到 N 个实例时产生 N 次 DB 查询，导致 DB 热点
     * 
     * @param trigger 事件
     * @param instanceId 实例ID
     * @param userId 用户ID（从路由缓存中获取，不查库）
     */
    public void log(StrategyTrigger trigger, Long instanceId, Long userId) {
        try {
            // 构建日志数据
            Map<String, Object> logData = new HashMap<>();
            logData.put("type", trigger.getTriggerType().name());
            logData.put("eventKey", trigger.getEventKey());
            logData.put("asOf", trigger.getAsOfTimeUtc().toString());
            logData.put("pairId", trigger.getTradingPairId());
            logData.put("instanceId", instanceId);
            logData.put("userId", userId);
            
            // 可选字段
            if (trigger.getStrategySymbol() != null) {
                logData.put("strategySymbol", trigger.getStrategySymbol());
            }
            if (trigger.getTimeframe() != null) {
                logData.put("tf", trigger.getTimeframe());
            }
            if (trigger.getSignalConfigId() != null) {
                logData.put("signalConfigId", trigger.getSignalConfigId());
            }
            if (trigger.getSignalId() != null) {
                logData.put("signalId", trigger.getSignalId());
            }
            if (trigger.getPrice() != null) {
                logData.put("price", trigger.getPrice().toString());
            }
            
            // 打印 JSON 单行日志
            String json = objectMapper.writeValueAsString(logData);
            logger.info("route_print {}", json);
            
        } catch (JsonProcessingException e) {
            logger.error("序列化日志数据失败: instanceId={}, eventKey={}", 
                instanceId, trigger.getEventKey(), e);
        } catch (Exception e) {
            logger.error("打印日志失败: instanceId={}, eventKey={}", 
                instanceId, trigger.getEventKey(), e);
        }
    }
}
```

**日志格式示例**

```text
STRATEGY_TRIGGER route_print {"type":"BAR_CLOSE","eventKey":"BAR:12:1m:1730000000000","asOf":"2026-01-15T00:00:00Z","pairId":12,"tf":"1m","instanceId":9001,"userId":10001,"strategySymbol":"BTC-USDT-SWAP"}
STRATEGY_TRIGGER route_print {"type":"PRICE","eventKey":"PRICE:12:1730000001000","asOf":"2026-01-15T00:00:01Z","pairId":12,"instanceId":9001,"userId":10001,"strategySymbol":"BTC-USDT-SWAP","price":"45000.50"}
STRATEGY_TRIGGER route_print {"type":"SIGNAL","eventKey":"SIGNAL:5:signal-12345","asOf":"2026-01-15T00:00:02Z","pairId":12,"instanceId":9002,"userId":10001,"signalConfigId":5,"signalId":"signal-12345","price":"45001.00"}
```

**验收标准**
- [ ] 日志格式统一，JSON 单行
- [ ] 所有必要字段都包含
- [ ] 可通过 `grep "STRATEGY_TRIGGER"` 快速定位
- [ ] 日志可解析为结构化数据

---

#### Task 7：TriggerIngress 实现（统一入口）

**包路径**
```
com.qyl.v2trade.business.strategy.runtime.ingress
```

**实现类**

```java
package com.qyl.v2trade.business.strategy.runtime.ingress;

import com.qyl.v2trade.business.strategy.runtime.dispatcher.TriggerDispatcher;
import com.qyl.v2trade.business.strategy.runtime.trigger.StrategyTrigger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class DefaultTriggerIngress implements TriggerIngress {
    
    @Autowired
    private TriggerDispatcher dispatcher;
    
    @Override
    public void accept(StrategyTrigger trigger) {
        // 轻量校验
        if (trigger == null || trigger.getEventKey() == null) {
            return;
        }
        
        // 直接分发到异步队列
        dispatcher.dispatch(trigger);
    }
}
```

**验收标准**
- [ ] 能接收三类 Adapter 的事件
- [ ] 不阻塞调用线程
- [ ] 空值/无效事件能正确处理

---

#### Task 8：测试接口（可选，用于验证）

**包路径**
```
com.qyl.v2trade.business.strategy.controller
```

**Controller 类**

```java
package com.qyl.v2trade.business.strategy.controller;

import com.qyl.v2trade.business.strategy.runtime.ingress.BarClosedIngressAdapter;
import com.qyl.v2trade.business.strategy.runtime.ingress.PriceTickIngressAdapter;
import com.qyl.v2trade.business.strategy.runtime.ingress.SignalReceivedIngressAdapter;
import com.qyl.v2trade.business.signal.model.entity.Signal;
import com.qyl.v2trade.common.Result;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.Instant;

/**
 * 策略触发器测试接口
 * 
 * <p>【重要】此 Controller 仅在 dev/test 环境启用，生产环境必须禁用
 * 
 * <p>配置项：`strategy.trigger.test-endpoint.enabled=false`（生产环境禁用）
 */
@RestController
@RequestMapping("/api/strategy/trigger/test")
@ConditionalOnProperty(name = "strategy.trigger.test-endpoint.enabled", havingValue = "true", matchIfMissing = false)
public class StrategyTriggerTestController {
    
    @Autowired
    private BarClosedIngressAdapter barClosedAdapter;
    
    @Autowired
    private PriceTickIngressAdapter priceTickAdapter;
    
    @Autowired
    private SignalReceivedIngressAdapter signalReceivedAdapter;
    
    /**
     * 测试 BAR_CLOSE 事件
     */
    @PostMapping("/bar-close")
    public Result<Void> testBarClose(
            @RequestParam Long tradingPairId,
            @RequestParam String timeframe,
            @RequestParam(required = false) String strategySymbol) {
        barClosedAdapter.onBarClosed(
            tradingPairId, 
            timeframe, 
            Instant.now(), 
            strategySymbol
        );
        return Result.success("BAR_CLOSE 事件已发送");
    }
    
    /**
     * 测试 PRICE 事件
     */
    @PostMapping("/price")
    public Result<Void> testPrice(
            @RequestParam Long tradingPairId,
            @RequestParam BigDecimal price,
            @RequestParam(required = false) String strategySymbol) {
        priceTickAdapter.onPriceTick(
            tradingPairId, 
            price, 
            Instant.now(), 
            strategySymbol
        );
        return Result.success("PRICE 事件已发送");
    }
    
    /**
     * 测试 SIGNAL 事件
     */
    @PostMapping("/signal")
    public Result<Void> testSignal(
            @RequestParam Long signalConfigId,
            @RequestParam String signalId,
            @RequestParam(required = false) BigDecimal price) {
        Signal signal = new Signal();
        signal.setId(signalId);
        if (price != null) {
            signal.setPrice(price);
        }
        
        signalReceivedAdapter.onSignalReceived(
            signalConfigId, 
            signalId, 
            signal, 
            Instant.now()
        );
        return Result.success("SIGNAL 事件已发送");
    }
}
```

**验收标准**
- [ ] 三类测试接口都能正常调用
- [ ] 调用后能在日志中看到打印输出
- [ ] 生产环境配置 `strategy.trigger.test-endpoint.enabled=false` 时，接口不可访问

---

#### Task 9：联调/压测脚本交付物

**交付要求**：提供联调和压测脚本，确保开发落地更顺滑。

**9.1 压测脚本建议**

**PRICE 压测脚本**
```bash
# 固定 pairId、随机价格、固定速率（例如 2000/s）持续 60s
for i in {1..120000}; do
  curl -X POST "http://localhost:8080/api/strategy/trigger/test/price?tradingPairId=1&price=$((RANDOM % 100000 + 40000))" &
  if [ $((i % 2000)) -eq 0 ]; then
    sleep 1
  fi
done
```

**BAR_CLOSE 压测脚本**
```bash
# 每秒 10 个（模拟多交易对/多周期）持续 60s
for i in {1..600}; do
  for tf in "1m" "5m" "15m" "1h"; do
    curl -X POST "http://localhost:8080/api/strategy/trigger/test/bar-close?tradingPairId=1&timeframe=$tf" &
  done
  sleep 1
done
```

**SIGNAL 压测脚本（含重复验证 dedup）**
```bash
# 每秒 50 个，重复 10%（验证 dedup）
for i in {1..3000}; do
  signalId="signal-$((i % 300))"  # 重复 10%
  curl -X POST "http://localhost:8080/api/strategy/trigger/test/signal?signalConfigId=1&signalId=$signalId" &
  if [ $((i % 50)) -eq 0 ]; then
    sleep 1
  fi
done
```

**9.2 压测验收标准**

- [ ] PRICE 2000 msg/s 持续 60s，系统稳定，不 OOM
- [ ] BAR_CLOSE 10 msg/s 持续 60s，所有事件都能路由并打印
- [ ] SIGNAL 50 msg/s，重复事件能正确去重（只打印一次）

**9.3 观测指标验证**

压测时通过 Prometheus 查询以下指标：
- `trigger_ingress_total`：验证接入总量
- `trigger_dedup_dropped_total`：验证去重效果
- `trigger_queue_size`：验证队列积压情况
- `trigger_dispatch_latency_ms`：验证处理延迟
- `trigger_queue_drop_total`：验证背压丢弃情况

---

### 3.2 数据库任务

#### Task 1：添加索引

**SQL 脚本**

```sql
-- 为路由查询添加索引
CREATE INDEX idx_strategy_instance_trading_pair_enabled 
ON strategy_instance(trading_pair_id, enabled);

CREATE INDEX idx_strategy_instance_signal_config_enabled 
ON strategy_instance(signal_config_id, enabled);

-- 可选：用户维度索引
CREATE INDEX idx_strategy_instance_user_enabled 
ON strategy_instance(user_id, enabled);

-- 确保 enabled 字段存在（如果表结构不一致）
-- ALTER TABLE strategy_instance ADD COLUMN enabled TINYINT(4) NOT NULL DEFAULT 1 COMMENT '是否启用：1-启用 0-禁用';
```

**验收标准**
- [ ] 索引创建成功
- [ ] 路由查询性能提升（EXPLAIN 验证）

---

### 3.3 配置任务

#### Task 1：添加依赖（pom.xml）

```xml
<!-- Caffeine 缓存 -->
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
    <version>3.1.8</version>
</dependency>
```

---

## 4. 验收标准（DoD）

### 4.1 BAR_CLOSE 路由正确

**Given**：pair=BTCUSDT 的 enabled 实例有 3 个

**When**：发送 BAR_CLOSE(pairId=xx, timeframe=1m, closeTime=T)

**Then**：
- 打印 3 行（每个 instance 一行）
- 字段齐全：type, eventKey, asOf, pairId, tf, instanceId, userId
- eventKey 一致：`BAR:{pairId}:1m:{closeTime}`

### 4.2 PRICE 异步不阻塞

**Given**：价格事件 2000 msg/s

**When**：持续 60s 压测

**Then**：
- 上游线程无明显阻塞
- 队列有背压策略日志（低优先级事件丢弃）
- 系统不 OOM、不大量 Full GC
- 日志正常打印（可能有部分丢弃，但系统稳定）

### 4.3 SIGNAL 幂等去重

**Given**：同一个 signalId 重放 10 次

**When**：10 次到达

**Then**：
- 只打印一次（或每个 instance 只打印一次）
- 其余被 dedup，日志显示 "事件已去重，跳过"

### 4.4 Dedup TTL 生效

**Given**：同 eventKey 在 30s 内重复

**When**：重复发送

**Then**：
- 30s 内不重复打印
- 超过 30s 可再次打印

### 4.5 索引缓存自动刷新

**Given**：索引缓存 TTL 60s

**When**：60s 后查询路由

**Then**：
- 缓存自动刷新
- 新创建的实例能在 60s 内被路由到

### 4.6 TriggerLogger 不得 per-instance 查库

**Given**：一个事件路由到 10 个实例

**When**：打印日志

**Then**：
- TriggerLogger 中无任何 DB 查询
- userId 从路由缓存获取
- 压测 2000 msg/s PRICE 事件，DB 查询量不随实例数量线性增长

### 4.7 新增实例生效时间

**Given**：新增一个 enabled 实例

**When**：发送对应事件

**Then**：
- 最迟 60 秒内路由生效（索引缓存 TTL 60s）
- 若做了联动刷新，可立即生效

### 4.8 时间语义对齐

**Given**：BAR_CLOSE 事件

**When**：检查 `asOfTimeUtc`

**Then**：
- `asOfTimeUtc` 等于窗口结束时间（不是触发时刻）
- period 对齐验证通过（5m 对齐到整 5 分钟等）

---

## 5. 开发顺序建议

1. **定义 StrategyTrigger / TriggerType / eventKey 规范**（Task 1）
2. **做 Deduplicator**（Task 3，Caffeine TTL）
3. **做 EventRouter**（Task 4，先 DB 查询版跑通）
4. **加 RouteIndexCache**（Task 4，TTL 刷新，替换 DB per-event 查询）
5. **接入三类 Adapter**（Task 2，先做 mock/测试接口）
6. **异步队列 + 统一打印**（Task 5, Task 6）
7. **压测与日志验收 + 索引补齐**（Task 8, 数据库任务）

---

## 6. 关键注意事项

### 6.1 硬约束

1. **UTC 时间语义**：`asOfTimeUtc` 必须是 UTC，`barCloseTime` 必须是 close，不要混 open
2. **异步**：不要在 WebSocket/聚合线程里做 DB 查找
3. **轻量 Adapter**：Adapter 里只做"轻量转换"，不能查库、不能路由、不能重逻辑
4. **幂等键冻结**：eventKey 规范一旦确定，后续不能修改（N3/N5/N6 都依赖它）

### 6.2 性能要求

1. **路由索引缓存**：避免每个事件查 DB
2. **背压策略**：队列满时低优先级事件丢弃，高优先级尽量不丢
3. **线程池隔离**：使用独立线程池，不影响其他业务

### 6.3 可观测性

1. **统一日志格式**：JSON 单行，可 grep、可解析
2. **日志级别**：route_print 用 INFO，去重/丢弃用 DEBUG/WARN
3. **监控指标**（可选 N2）：队列长度、处理延迟、去重率

### 6.4 观测与指标（必做）

> **硬要求**：N2 必须实现以下 6 个观测指标，否则排障难、压测不可控。

**指标列表（使用 Micrometer/Prometheus）**

1. **`trigger_ingress_total{type}`**：接入总量
   - type 标签：BAR_CLOSE / PRICE / SIGNAL
   - 用途：监控事件接入速率

2. **`trigger_dedup_dropped_total{type}`**：去重丢弃量
   - type 标签：BAR_CLOSE / PRICE / SIGNAL
   - 用途：监控去重效果，发现重复事件

3. **`trigger_route_empty_total{type}`**：路由到 0 个实例的次数
   - type 标签：BAR_CLOSE / PRICE / SIGNAL
   - 用途：发现映射缺失（实例未启用、配置错误等）

4. **`trigger_queue_size{priority}`**：队列长度
   - priority 标签：high / low
   - 用途：监控队列积压，发现处理瓶颈

5. **`trigger_dispatch_latency_ms{type}`**：从 accept 到打印的延迟（直方图）
   - type 标签：BAR_CLOSE / PRICE / SIGNAL
   - 用途：监控处理延迟，发现性能问题

6. **`trigger_queue_drop_total{type}`**：队列满丢弃
   - type 标签：BAR_CLOSE / PRICE / SIGNAL
   - 用途：监控背压丢弃情况（尤其 PRICE）

**实现位置**

- `TriggerIngress`：接入时增加 `trigger_ingress_total`
- `TriggerDeduplicator`：去重时增加 `trigger_dedup_dropped_total`
- `EventRouter`：路由为空时增加 `trigger_route_empty_total`
- `TriggerDispatcher`：队列操作时增加 `trigger_queue_size`、`trigger_queue_drop_total`
- `TriggerDispatcher`：处理前后记录时间戳，计算 `trigger_dispatch_latency_ms`

**验收标准**

- [ ] 6 个指标全部实现
- [ ] 指标可通过 Prometheus 或 Micrometer 暴露
- [ ] 压测时能通过指标快速定位瓶颈

### 6.5 性能坑点与强制实现约束（必做）

> **硬要求**：以下约束必须严格执行，否则会导致 DB 热点、线程池异常、事件键不稳定等问题。

#### 6.5.1 TriggerLogger 不得 per-instance 查库

**问题**：如果 `TriggerLogger.log(trigger, instanceId)` 内部调用 `instanceMapper.selectById(instanceId)`，会导致：
- 一个事件路由到 N 个实例 → N 次 DB 查询
- PRICE 高频下会直接把 DB 打满

**强制改法**

1. **EventRouter 在构建索引缓存时，同时缓存 `instanceId -> userId` 映射**
   ```java
   // 在 CachedEventRouter 中
   private Cache<Long, Long> instanceUserIdCache;  // instanceId -> userId
   
   // 在 refreshAllIndexes() 中同时构建 userId 缓存
   allEnabled.forEach(inst -> {
       instanceUserIdCache.put(inst.getId(), inst.getUserId());
   });
   ```

2. **EventRouter 接口增加方法**：`Long getUserIdByInstanceId(Long instanceId)`
   - 从缓存获取，不查库

3. **TriggerLogger.log() 方法签名改为**：`log(StrategyTrigger trigger, Long instanceId, Long userId)`
   - userId 由调用方从缓存获取后传入

4. **TriggerDispatcher 调用时**：
   ```java
   Long userId = router.getUserIdByInstanceId(instanceId);  // 从缓存获取
   triggerLogger.log(trigger, instanceId, userId);
   ```

**验收标准（DoD）**

- [ ] TriggerLogger 中无任何 DB 查询（`selectById`、`selectOne` 等）
- [ ] userId 从路由缓存获取
- [ ] 压测 2000 msg/s PRICE 事件，DB 查询量不随实例数量线性增长

#### 6.5.2 线程池/队列背压策略硬约束

**硬约束规则**

1. **PRICE 允许丢弃**（按文档逻辑）
   - 队列满时：记录 `trigger_queue_drop_total{type="PRICE"}`，打 WARN 日志，丢弃事件

2. **BAR_CLOSE / SIGNAL 不允许静默丢弃**
   - 队列满时：
     - 打 `ERROR` 日志：`"高优先级队列满，事件可能丢失: eventKey={}"`
     - 增加 `trigger_queue_drop_total{type="BAR_CLOSE"}` 或 `SIGNAL`
     - **可选降级**：同步打印一条"实例列表摘要"日志，避免彻底丢消息
       ```java
       // 降级打印摘要
       logger.error("高优先级队列满，降级打印摘要: eventKey={}, instanceCount={}", 
           trigger.getEventKey(), instanceIds.size());
       ```

**验收标准（DoD）**

- [ ] PRICE 队列满时能丢弃并记录指标
- [ ] BAR_CLOSE/SIGNAL 队列满时打 ERROR 日志，不静默丢弃
- [ ] 压测时能通过指标和日志快速定位背压问题

#### 6.5.3 PRICE eventKey 时间戳粒度策略

**问题**：PRICE 用 `PRICE:{pairId}:{tick.timestamp}`，如果 tick timestamp 每条都不同，dedup 形同虚设。

**两档策略**

1. **N2 默认**：保持毫秒 eventKey（如文档）
   - 优点：精确，不影响后续策略决策
   - 缺点：高频下日志量大

2. **压测模式（可选开关）**：将 PRICE eventKey 时间桶化
   - 配置项：`strategy.trigger.price-event-key-bucket-ms=200`（默认 0，表示不桶化）
   - 实现：`PRICE:{pairId}:{timestamp/bucketMs}`，减少日志量
   - **注意**：只影响打印，不影响后续策略决策（因为 N2 不做决策）

**验收标准（DoD）**

- [ ] 默认使用毫秒 eventKey
- [ ] 支持配置开关启用时间桶化（可选）
- [ ] 压测时能通过配置减少日志量

#### 6.5.4 Adapter 里查 tradingPairId 的缓存约束

**硬约束**：必须本地缓存 `symbol -> pairId`，不要每条 tick 查 `TradingPairService`。

**实现要求**

1. **每个 Adapter 内部维护本地缓存**（Caffeine/ConcurrentMap）
   ```java
   private final Cache<String, Long> symbolToPairIdCache = Caffeine.newBuilder()
       .expireAfterWrite(30, TimeUnit.MINUTES)
       .maximumSize(10_000)
       .build();
   ```

2. **查不到 pairId 时的日志级别**：
   - PRICE：仅 `debug`（高频，避免刷屏）
   - BAR_CLOSE/SIGNAL：至少 `warn`（低频，需要关注）

**验收标准（DoD）**

- [ ] 每个 Adapter 都有本地 symbol->pairId 缓存
- [ ] 缓存 TTL 5~30 分钟
- [ ] 不直接调用 `TradingPairService`（即使它"可能有缓存"）

#### 6.5.5 路由缓存刷新策略预期说明

**预期说明（必须交代给产品/QA）**

1. **新增/启用实例**：最迟 60 秒内路由生效
   - 原因：索引缓存 TTL 60s 自动刷新
   - 若需更快：提供"手动刷新索引"的内部接口（仅管理员）

2. **禁用实例**：最迟 60 秒内停止打印
   - 原因：索引缓存 TTL 60s 自动刷新

3. **联动刷新（可选）**：在 N1 的实例更新后发本地事件触发 refresh
   - 实现：`StrategyInstanceService.update()` 成功后，发布 `InstanceUpdatedEvent`
   - `CachedEventRouter` 监听该事件，立即刷新索引

**验收标准（DoD）**

- [ ] 文档中明确说明"新增实例生效时间 <= 60s"
- [ ] QA 用例中不使用"立刻生效"作为断言（除非做了联动刷新）
- [ ] 提供手动刷新索引的管理接口（可选）

#### 6.5.6 时间语义对齐约束

**硬约束**：BAR_CLOSE 的 `asOfTimeUtc` 必须等于**窗口结束时间（close）**，不能用聚合回调触发时刻。

**对齐规则**

1. **closeTime 计算**：
   ```java
   // 正确：窗口结束时间 = 窗口起始时间 + 窗口时长
   long barCloseTimeMillis = aggregatedKLine.timestamp() + windowDurationMs;
   Instant barCloseTimeUtc = Instant.ofEpochMilli(barCloseTimeMillis);
   ```

2. **period 对齐验证**：
   - 5m 必须对齐到整点/整 5 分钟（如 10:00, 10:05, 10:10）
   - 15m 必须对齐到整点/整 15 分钟（如 10:00, 10:15, 10:30）
   - 对齐失败：必须打 `WARN` 日志

3. **验收检查**：
   - 验证 `asOfTimeUtc` 是否等于窗口结束时间
   - 验证 period 是否与聚合器窗口一致

**验收标准（DoD）**

- [ ] BAR_CLOSE 的 `asOfTimeUtc` 等于窗口结束时间（不是触发时刻）
- [ ] period 对齐验证通过（5m 对齐到整 5 分钟等）
- [ ] 对齐失败时打 WARN 日志

---

## 7. 总结

**N2 的交付本质**：把"外部世界的事件"变成系统内部统一的 `StrategyTrigger`，并做到 **正确路由到 strategy_instance_id、30s 幂等去重、异步消费不阻塞、统一可 grep 打印、可压测**。

**后续 N3/N5/N6 能否稳定，关键看 N2 是否把以下底座一次性做对**：
- ✅ 路由索引缓存（避免 DB 压力）
- ✅ 去重机制（避免重复处理）
- ✅ 异步背压（避免阻塞上游）
- ✅ 时间语义（UTC + barCloseTime）
- ✅ 统一事件模型（StrategyTrigger）

---

## 8. 附录：完整包结构

```
com.qyl.v2trade.business.strategy.runtime
├── trigger
│   ├── TriggerType.java
│   ├── StrategyTrigger.java
│   └── EventKeyBuilder.java
├── ingress
│   ├── TriggerIngress.java
│   ├── DefaultTriggerIngress.java
│   ├── BarClosedIngressAdapter.java
│   ├── PriceTickIngressAdapter.java
│   └── SignalReceivedIngressAdapter.java
├── dedup
│   ├── TriggerDeduplicator.java
│   └── CaffeineTriggerDeduplicator.java
├── router
│   ├── EventRouter.java
│   └── CachedEventRouter.java
├── dispatcher
│   └── TriggerDispatcher.java
└── logger
    └── TriggerLogger.java
```

---

**文档版本**：v1.0  
**最后更新**：2024-01-XX  
**负责人**：开发团队