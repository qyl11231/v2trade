<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Logic Studio - é‡åŒ–ç­–ç•¥ç¼–æ’å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        .studio-container {
            display: flex;
            height: 100vh;
        }

        /* å·¦ä¾§ç®—å­é¢æ¿ */
        .operator-palette {
            width: 280px;
            background: #252525;
            border-right: 2px solid #333;
            overflow-y: auto;
            padding: 16px;
        }

        .palette-section {
            margin-bottom: 24px;
        }

        .palette-section h3 {
            color: #4a9eff;
            font-size: 14px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .operator-item {
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: grab;
            transition: all 0.2s;
            position: relative;
        }

        .operator-item:hover {
            background: #353535;
            border-color: #4a9eff;
            transform: translateX(4px);
        }

        .operator-item:active {
            cursor: grabbing;
        }

        .operator-item.dragging {
            opacity: 0.5;
        }

        .operator-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 8px;
            vertical-align: middle;
        }

        .operator-name {
            font-weight: 500;
            color: #e0e0e0;
        }

        .operator-desc {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }

        /* ä¸­é—´ç”»å¸ƒåŒº */
        .canvas-area {
            flex: 1;
            position: relative;
            background: #1e1e1e;
            overflow: hidden;
        }

        #graph-canvas {
            width: 100%;
            height: 100%;
            cursor: default;
        }

        .canvas-toolbar {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
        }

        .toolbar-btn {
            background: #2d2d2d;
            border: 1px solid #404040;
            color: #e0e0e0;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: #353535;
            border-color: #4a9eff;
        }

        .toolbar-btn.primary {
            background: #4a9eff;
            border-color: #4a9eff;
            color: white;
        }

        .toolbar-btn.danger {
            background: #e74c3c;
            border-color: #e74c3c;
        }

        /* å³ä¾§å±æ€§é¢æ¿ */
        .inspector-panel {
            width: 360px;
            background: #252525;
            border-left: 2px solid #333;
            overflow-y: auto;
            padding: 16px;
        }

        .inspector-header {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }

        .inspector-header h3 {
            color: #4a9eff;
            font-size: 16px;
        }

        .inspector-content {
            font-size: 13px;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group label {
            display: block;
            color: #aaa;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .property-group input,
        .property-group select,
        .property-group textarea {
            width: 100%;
            background: #2d2d2d;
            border: 1px solid #404040;
            color: #e0e0e0;
            padding: 8px;
            border-radius: 4px;
            font-size: 13px;
        }

        .property-group input:focus,
        .property-group select:focus,
        .property-group textarea:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .property-group input[type="range"] {
            width: 100%;
        }

        .property-row {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .property-row .property-group {
            flex: 1;
            margin-bottom: 0;
        }

        /* JSON é¢„è§ˆåŒº */
        .json-preview {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 240px;
            background: #1a1a1a;
            border-top: 2px solid #333;
            display: flex;
            flex-direction: column;
        }

        .json-preview-header {
            padding: 8px 16px;
            background: #252525;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .json-preview-header h4 {
            color: #4a9eff;
            font-size: 13px;
        }

        .json-preview-content {
            flex: 1;
            overflow: auto;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            line-height: 1.6;
            color: #d4d4d4;
        }

        .json-key {
            color: #9cdcfe;
        }

        .json-string {
            color: #ce9178;
        }

        .json-number {
            color: #b5cea8;
        }

        .json-boolean {
            color: #569cd6;
        }

        /* èŠ‚ç‚¹æ ·å¼ */
        .node {
            position: absolute;
            min-width: 180px;
            background: #2d2d2d;
            border: 2px solid #404040;
            border-radius: 8px;
            padding: 12px;
            cursor: move;
            user-select: none;
            transition: all 0.2s;
        }

        .node:hover {
            border-color: #4a9eff;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.3);
        }

        .node.selected {
            border-color: #4a9eff;
            box-shadow: 0 0 16px rgba(74, 158, 255, 0.5);
        }

        .node.error {
            border-color: #e74c3c;
            box-shadow: 0 0 12px rgba(231, 76, 60, 0.3);
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #404040;
        }

        .node-title {
            font-weight: 600;
            color: #4a9eff;
            font-size: 13px;
        }

        .node-type {
            font-size: 10px;
            color: #888;
            background: #1a1a1a;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .node-body {
            font-size: 12px;
            color: #ccc;
        }

        .node-port {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #4a9eff;
            border: 2px solid #1a1a1a;
            border-radius: 50%;
            cursor: crosshair;
        }

        .node-port.input {
            left: -6px;
        }

        .node-port.output {
            right: -6px;
        }

        .node-port:hover {
            background: #6bb6ff;
            transform: scale(1.3);
        }

        /* è¿çº¿æ ·å¼ */
        .connection-line {
            stroke: #4a9eff;
            stroke-width: 2;
            fill: none;
            pointer-events: stroke;
            cursor: pointer;
        }

        .connection-line:hover {
            stroke: #6bb6ff;
            stroke-width: 3;
        }

        /* éªŒè¯é”™è¯¯æç¤º */
        .validation-error {
            background: #e74c3c;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .validation-error::before {
            content: "âš ";
            font-size: 16px;
        }

        .validation-warning {
            background: #f39c12;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 12px;
        }

        /* ç©ºçŠ¶æ€ */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
        }

        .empty-state h3 {
            margin-bottom: 8px;
            color: #888;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="studio-container">
        <!-- å·¦ä¾§ç®—å­é¢æ¿ -->
        <div class="operator-palette">
            <div class="palette-section">
                <h3>ğŸ“Š ENTRY - å…¥åœºç®—å­</h3>
                <div class="operator-item" data-type="entry" data-operator="multi_factor">
                    <div class="operator-name">ğŸ¯ å¤šå› å­åŠ æƒ</div>
                    <div class="operator-desc">å¤šå› å­æƒé‡é…æ¯”ï¼Œæ”¯æŒ RSI/å‡çº¿/ä¿¡å·ç­‰</div>
                </div>
                <div class="operator-item" data-type="entry" data-operator="sequential_window">
                    <div class="operator-name">â±ï¸ åºåˆ—åŒ–æ—¶é—´çª—</div>
                    <div class="operator-desc">å…ˆ A å B çš„æ—¶åºé€»è¾‘ï¼ŒN æ ¹ Bar å†…è§¦å‘</div>
                </div>
                <div class="operator-item" data-type="entry" data-operator="cross_timeframe">
                    <div class="operator-name">ğŸ”„ è·¨å‘¨æœŸå…±æŒ¯</div>
                    <div class="operator-desc">1h è¶‹åŠ¿è¿‡æ»¤ + 5m æ‹©æ—¶å…¥åœº</div>
                </div>
                <div class="operator-item" data-type="entry" data-operator="indicator_rsi">
                    <div class="operator-name">ğŸ“ˆ RSI æŒ‡æ ‡</div>
                    <div class="operator-desc">ç›¸å¯¹å¼ºå¼±æŒ‡æ ‡ï¼Œå‘¨æœŸå¯é…ç½®</div>
                </div>
                <div class="operator-item" data-type="entry" data-operator="indicator_ma">
                    <div class="operator-name">ğŸ“Š ç§»åŠ¨å¹³å‡</div>
                    <div class="operator-desc">MA/EMAï¼Œæ”¯æŒå¤šå‘¨æœŸ</div>
                </div>
                <div class="operator-item" data-type="entry" data-operator="signal_trigger">
                    <div class="operator-name">ğŸ”” å¤–éƒ¨ä¿¡å·</div>
                    <div class="operator-desc">TradingView ä¿¡å·è§¦å‘</div>
                </div>
            </div>

            <div class="palette-section">
                <h3>ğŸšª EXIT - ç¦»åœºç®—å­</h3>
                <div class="operator-item" data-type="exit" data-operator="atr_stoploss">
                    <div class="operator-name">ğŸ“‰ ATR åŠ¨æ€æ­¢æŸ</div>
                    <div class="operator-desc">åŸºäºæ³¢åŠ¨ç‡çš„è‡ªé€‚åº”æ­¢æŸ</div>
                </div>
                <div class="operator-item" data-type="exit" data-operator="trailing_stop">
                    <div class="operator-name">ğŸ’° ç›ˆåˆ©ä¿æŠ¤æ­¢æŸ</div>
                    <div class="operator-desc">ç›ˆåˆ© 3% åæ¿€æ´»è¿½è¸ªæ­¢æŸ</div>
                </div>
                <div class="operator-item" data-type="exit" data-operator="time_decay">
                    <div class="operator-name">â° æŒä»“è¡°å‡</div>
                    <div class="operator-desc">åŸºäºæ—¶é—´çš„å¼ºåˆ¶ç¦»åœº</div>
                </div>
                <div class="operator-item" data-type="exit" data-operator="take_profit">
                    <div class="operator-name">ğŸ¯ å›ºå®šæ­¢ç›ˆ</div>
                    <div class="operator-desc">å›ºå®šç™¾åˆ†æ¯”æ­¢ç›ˆ</div>
                </div>
            </div>

            <div class="palette-section">
                <h3>ğŸ’¼ POSITION - ä»“ä½ç®—å­</h3>
                <div class="operator-item" data-type="position" data-operator="dynamic_sizing">
                    <div class="operator-name">âš–ï¸ åŠ¨æ€å¤´å¯¸</div>
                    <div class="operator-desc">åŸºäºå›æ’¤çš„ä»“ä½è°ƒèŠ‚</div>
                </div>
                <div class="operator-item" data-type="position" data-operator="pyramid_add">
                    <div class="operator-name">ğŸ“š é‡‘å­—å¡”åŠ ä»“</div>
                    <div class="operator-desc">ç›ˆåˆ©åé€æ­¥åŠ ä»“</div>
                </div>
                <div class="operator-item" data-type="position" data-operator="martingale">
                    <div class="operator-name">ğŸ² é©¬ä¸æ ¼å°”</div>
                    <div class="operator-desc">äºæŸååŠ å€ï¼Œéœ€è®¾ç½®å®‰å…¨çº¢çº¿</div>
                </div>
                <div class="operator-item" data-type="position" data-operator="risk_control">
                    <div class="operator-name">ğŸ›¡ï¸ é£æ§å®¡è®¡</div>
                    <div class="operator-desc">å®æ—¶é£æ§æ£€æŸ¥ä¸è­¦å‘Š</div>
                </div>
            </div>
        </div>

        <!-- ä¸­é—´ç”»å¸ƒåŒº -->
        <div class="canvas-area">
            <div class="canvas-toolbar">
                <button class="toolbar-btn" onclick="clearCanvas()">æ¸…ç©ºç”»å¸ƒ</button>
                <button class="toolbar-btn" onclick="exportJSON()">å¯¼å‡º JSON</button>
                <button class="toolbar-btn primary" onclick="validateAndSave()">éªŒè¯å¹¶ä¿å­˜</button>
                <button class="toolbar-btn" onclick="loadExample()">åŠ è½½ç¤ºä¾‹</button>
            </div>
            <svg id="graph-canvas" width="100%" height="100%">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="#4a9eff" />
                    </marker>
                </defs>
            </svg>
            <div class="empty-state" id="empty-state">
                <h3>ä»å·¦ä¾§æ‹–æ‹½ç®—å­èŠ‚ç‚¹åˆ°ç”»å¸ƒ</h3>
                <p>æˆ–ç‚¹å‡»"åŠ è½½ç¤ºä¾‹"æŸ¥çœ‹å®Œæ•´ç¤ºä¾‹</p>
            </div>
        </div>

        <!-- å³ä¾§å±æ€§é¢æ¿ -->
        <div class="inspector-panel">
            <div class="inspector-header">
                <h3>å±æ€§ç¼–è¾‘å™¨</h3>
            </div>
            <div class="inspector-content" id="inspector-content">
                <p style="color: #666; text-align: center; margin-top: 40px;">ç‚¹å‡»èŠ‚ç‚¹ç¼–è¾‘å±æ€§</p>
            </div>
        </div>

        <!-- JSON é¢„è§ˆåŒº -->
        <div class="json-preview">
            <div class="json-preview-header">
                <h4>ğŸ“„ Runtime Rules JSON (å®æ—¶é¢„è§ˆ)</h4>
                <button class="toolbar-btn" onclick="copyJSON()" style="padding: 4px 12px; font-size: 11px;">å¤åˆ¶</button>
            </div>
            <div class="json-preview-content" id="json-content">
                <pre id="json-preview-text">{}</pre>
            </div>
        </div>
    </div>

    <script>
        // ==================== å…¨å±€çŠ¶æ€ ====================
        let nodes = [];
        let connections = [];
        let selectedNode = null;
        let dragState = { isDragging: false, node: null, offset: { x: 0, y: 0 } };
        let connectionState = { isConnecting: false, fromNode: null, fromPort: null };

        const canvas = document.getElementById('graph-canvas');
        const svgNS = 'http://www.w3.org/2000/svg';

        // ==================== ç®—å­å®šä¹‰ ====================
        const operatorDefinitions = {
            // ENTRY ç®—å­
            'multi_factor': {
                title: 'å¤šå› å­åŠ æƒ',
                type: 'entry',
                inputs: [],
                outputs: ['weighted_score'],
                defaultProps: {
                    factors: [
                        { id: 'factor1', name: 'RSI', weight: 0.6, indicator: 'RSI', period: 14 },
                        { id: 'factor2', name: 'MA', weight: 0.4, indicator: 'MA', period: 50 }
                    ],
                    threshold: 0.7,
                    operator: 'AND'
                },
                renderProps: (props) => {
                    let html = `
                        <div class="property-group">
                            <label>å…¥åœºæ€»é˜ˆå€¼</label>
                            <input type="number" step="0.01" min="0" max="1" value="${props.threshold}" 
                                   onchange="updateNodeProperty('threshold', parseFloat(this.value))" />
                        </div>
                        <div class="property-group">
                            <label>é€»è¾‘è¿ç®—ç¬¦</label>
                            <select onchange="updateNodeProperty('operator', this.value)">
                                <option value="AND" ${props.operator === 'AND' ? 'selected' : ''}>AND (å…¨éƒ¨æ»¡è¶³)</option>
                                <option value="OR" ${props.operator === 'OR' ? 'selected' : ''}>OR (ä»»ä¸€æ»¡è¶³)</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label>å› å­åˆ—è¡¨</label>
                            <div id="factors-list"></div>
                            <button class="toolbar-btn" onclick="addFactor()" style="margin-top: 8px; width: 100%;">+ æ·»åŠ å› å­</button>
                        </div>
                    `;
                    return html;
                }
            },
            'sequential_window': {
                title: 'åºåˆ—åŒ–æ—¶é—´çª—',
                type: 'entry',
                inputs: ['trigger_a'],
                outputs: ['trigger_b'],
                defaultProps: {
                    windowBars: 5,
                    condition: 'AFTER_A'
                },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>æ—¶é—´çª—å£ (Bar æ•°)</label>
                        <input type="number" min="1" max="100" value="${props.windowBars}" 
                               onchange="updateNodeProperty('windowBars', parseInt(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>è§¦å‘æ¡ä»¶</label>
                        <select onchange="updateNodeProperty('condition', this.value)">
                            <option value="AFTER_A" ${props.condition === 'AFTER_A' ? 'selected' : ''}>A è§¦å‘å N æ ¹ Bar å†… B è§¦å‘</option>
                            <option value="BEFORE_A" ${props.condition === 'BEFORE_A' ? 'selected' : ''}>A è§¦å‘å‰ N æ ¹ Bar å†… B è§¦å‘</option>
                        </select>
                    </div>
                `
            },
            'cross_timeframe': {
                title: 'è·¨å‘¨æœŸå…±æŒ¯',
                type: 'entry',
                inputs: ['trend_filter', 'timing_signal'],
                outputs: ['resonance'],
                defaultProps: {
                    trendTimeframe: '1h',
                    timingTimeframe: '5m',
                    trendCondition: 'UP_TREND',
                    timingCondition: 'BREAKOUT'
                },
                renderProps: (props) => `
                    <div class="property-row">
                        <div class="property-group">
                            <label>è¶‹åŠ¿å‘¨æœŸ</label>
                            <select onchange="updateNodeProperty('trendTimeframe', this.value)">
                                <option value="1h" ${props.trendTimeframe === '1h' ? 'selected' : ''}>1h</option>
                                <option value="4h" ${props.trendTimeframe === '4h' ? 'selected' : ''}>4h</option>
                                <option value="1d" ${props.trendTimeframe === '1d' ? 'selected' : ''}>1d</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label>æ‹©æ—¶å‘¨æœŸ</label>
                            <select onchange="updateNodeProperty('timingTimeframe', this.value)">
                                <option value="5m" ${props.timingTimeframe === '5m' ? 'selected' : ''}>5m</option>
                                <option value="15m" ${props.timingTimeframe === '15m' ? 'selected' : ''}>15m</option>
                                <option value="30m" ${props.timingTimeframe === '30m' ? 'selected' : ''}>30m</option>
                            </select>
                        </div>
                    </div>
                `
            },
            'indicator_rsi': {
                title: 'RSI æŒ‡æ ‡',
                type: 'entry',
                inputs: [],
                outputs: ['rsi_value'],
                defaultProps: { period: 14, overbought: 70, oversold: 30 },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>å‘¨æœŸ</label>
                        <input type="number" min="2" max="100" value="${props.period}" 
                               onchange="updateNodeProperty('period', parseInt(this.value))" />
                    </div>
                    <div class="property-row">
                        <div class="property-group">
                            <label>è¶…ä¹°çº¿</label>
                            <input type="number" min="0" max="100" value="${props.overbought}" 
                                   onchange="updateNodeProperty('overbought', parseInt(this.value))" />
                        </div>
                        <div class="property-group">
                            <label>è¶…å–çº¿</label>
                            <input type="number" min="0" max="100" value="${props.oversold}" 
                                   onchange="updateNodeProperty('oversold', parseInt(this.value))" />
                        </div>
                    </div>
                `
            },
            'indicator_ma': {
                title: 'ç§»åŠ¨å¹³å‡',
                type: 'entry',
                inputs: [],
                outputs: ['ma_value'],
                defaultProps: { period: 50, type: 'SMA' },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>å‘¨æœŸ</label>
                        <input type="number" min="1" max="200" value="${props.period}" 
                               onchange="updateNodeProperty('period', parseInt(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>ç±»å‹</label>
                        <select onchange="updateNodeProperty('type', this.value)">
                            <option value="SMA" ${props.type === 'SMA' ? 'selected' : ''}>SMA (ç®€å•ç§»åŠ¨å¹³å‡)</option>
                            <option value="EMA" ${props.type === 'EMA' ? 'selected' : ''}>EMA (æŒ‡æ•°ç§»åŠ¨å¹³å‡)</option>
                        </select>
                    </div>
                `
            },
            'signal_trigger': {
                title: 'å¤–éƒ¨ä¿¡å·',
                type: 'entry',
                inputs: [],
                outputs: ['signal'],
                defaultProps: { signalConfigId: null, direction: 'LONG' },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>ä¿¡å·é…ç½® ID</label>
                        <input type="number" value="${props.signalConfigId || ''}" 
                               onchange="updateNodeProperty('signalConfigId', this.value ? parseInt(this.value) : null)" />
                    </div>
                    <div class="property-group">
                        <label>æ–¹å‘</label>
                        <select onchange="updateNodeProperty('direction', this.value)">
                            <option value="LONG" ${props.direction === 'LONG' ? 'selected' : ''}>LONG (åšå¤š)</option>
                            <option value="SHORT" ${props.direction === 'SHORT' ? 'selected' : ''}>SHORT (åšç©º)</option>
                        </select>
                    </div>
                `
            },
            // EXIT ç®—å­
            'atr_stoploss': {
                title: 'ATR åŠ¨æ€æ­¢æŸ',
                type: 'exit',
                inputs: ['entry_price', 'atr_value'],
                outputs: ['stoploss_price'],
                defaultProps: { atrMultiplier: 2.0, timeframe: '5m' },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>ATR å€æ•°</label>
                        <input type="number" step="0.1" min="0.1" max="10" value="${props.atrMultiplier}" 
                               onchange="updateNodeProperty('atrMultiplier', parseFloat(this.value))" />
                        <small style="color: #888;">å…¬å¼: StopLoss = EntryPrice Â± (ATR Ã— Multiplier)</small>
                    </div>
                    <div class="property-group">
                        <label>æ—¶é—´å‘¨æœŸ</label>
                        <select onchange="updateNodeProperty('timeframe', this.value)">
                            <option value="5m" ${props.timeframe === '5m' ? 'selected' : ''}>5m</option>
                            <option value="15m" ${props.timeframe === '15m' ? 'selected' : ''}>15m</option>
                            <option value="1h" ${props.timeframe === '1h' ? 'selected' : ''}>1h</option>
                        </select>
                    </div>
                `
            },
            'trailing_stop': {
                title: 'ç›ˆåˆ©ä¿æŠ¤æ­¢æŸ',
                type: 'exit',
                inputs: ['current_price', 'entry_price'],
                outputs: ['exit_signal'],
                defaultProps: { profitThreshold: 0.03, trailBack: 0.01 },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>ç›ˆåˆ©æ¿€æ´»é˜ˆå€¼ (%)</label>
                        <input type="number" step="0.01" min="0" max="1" value="${props.profitThreshold}" 
                               onchange="updateNodeProperty('profitThreshold', parseFloat(this.value))" />
                        <small style="color: #888;">ç›ˆåˆ©è¾¾åˆ°æ­¤å€¼åæ¿€æ´»è¿½è¸ªæ­¢æŸ</small>
                    </div>
                    <div class="property-group">
                        <label>å›æ’¤è§¦å‘ (%)</label>
                        <input type="number" step="0.01" min="0" max="1" value="${props.trailBack}" 
                               onchange="updateNodeProperty('trailBack', parseFloat(this.value))" />
                        <small style="color: #888;">ä»æœ€é«˜ç›ˆåˆ©å›æ’¤æ­¤å€¼å³è§¦å‘ç¦»åœº</small>
                    </div>
                `
            },
            'time_decay': {
                title: 'æŒä»“è¡°å‡',
                type: 'exit',
                inputs: ['entry_time'],
                outputs: ['exit_signal'],
                defaultProps: { maxHoldMinutes: 60, requireProfit: false },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>æœ€å¤§æŒä»“æ—¶é—´ (åˆ†é’Ÿ)</label>
                        <input type="number" min="1" max="1440" value="${props.maxHoldMinutes}" 
                               onchange="updateNodeProperty('maxHoldMinutes', parseInt(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>æ˜¯å¦è¦æ±‚ç›ˆåˆ©</label>
                        <select onchange="updateNodeProperty('requireProfit', this.value === 'true')">
                            <option value="false" ${!props.requireProfit ? 'selected' : ''}>å¦ (æ—¶é—´åˆ°å³ç¦»åœº)</option>
                            <option value="true" ${props.requireProfit ? 'selected' : ''}>æ˜¯ (æœªç›ˆåˆ©åˆ™å¼ºåˆ¶ç¦»åœº)</option>
                        </select>
                    </div>
                `
            },
            'take_profit': {
                title: 'å›ºå®šæ­¢ç›ˆ',
                type: 'exit',
                inputs: ['entry_price', 'current_price'],
                outputs: ['exit_signal'],
                defaultProps: { profitRatio: 0.05 },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>æ­¢ç›ˆæ¯”ä¾‹ (%)</label>
                        <input type="number" step="0.01" min="0" max="1" value="${props.profitRatio}" 
                               onchange="updateNodeProperty('profitRatio', parseFloat(this.value))" />
                    </div>
                `
            },
            // POSITION ç®—å­
            'dynamic_sizing': {
                title: 'åŠ¨æ€å¤´å¯¸',
                type: 'position',
                inputs: ['drawdown', 'base_capital'],
                outputs: ['calculated_qty'],
                defaultProps: { riskPerTrade: 0.01, maxDrawdown: 0.05, minQty: 0.001 },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>å•ç¬”é£é™© (%)</label>
                        <input type="number" step="0.001" min="0" max="0.1" value="${props.riskPerTrade}" 
                               onchange="updateNodeProperty('riskPerTrade', parseFloat(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>æœ€å¤§å›æ’¤é˜ˆå€¼ (%)</label>
                        <input type="number" step="0.01" min="0" max="0.5" value="${props.maxDrawdown}" 
                               onchange="updateNodeProperty('maxDrawdown', parseFloat(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>æœ€å°ä»“ä½</label>
                        <input type="number" step="0.001" min="0" value="${props.minQty}" 
                               onchange="updateNodeProperty('minQty', parseFloat(this.value))" />
                    </div>
                `
            },
            'pyramid_add': {
                title: 'é‡‘å­—å¡”åŠ ä»“',
                type: 'position',
                inputs: ['profit_pct', 'current_position'],
                outputs: ['add_qty'],
                defaultProps: { steps: 3, profitThreshold: 0.02, addRatio: 0.5, maxSteps: 5 },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>åŠ ä»“æ­¥æ•°</label>
                        <input type="number" min="1" max="10" value="${props.steps}" 
                               onchange="updateNodeProperty('steps', parseInt(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>ç›ˆåˆ©è§¦å‘é˜ˆå€¼ (%)</label>
                        <input type="number" step="0.01" min="0" max="0.5" value="${props.profitThreshold}" 
                               onchange="updateNodeProperty('profitThreshold', parseFloat(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>åŠ ä»“æ¯”ä¾‹</label>
                        <input type="number" step="0.1" min="0.1" max="2" value="${props.addRatio}" 
                               onchange="updateNodeProperty('addRatio', parseFloat(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>æœ€å¤§æ­¥æ•°é™åˆ¶</label>
                        <input type="number" min="1" max="10" value="${props.maxSteps}" 
                               onchange="updateNodeProperty('maxSteps', parseInt(this.value))" />
                    </div>
                `
            },
            'martingale': {
                title: 'é©¬ä¸æ ¼å°”',
                type: 'position',
                inputs: ['loss_pct', 'current_position'],
                outputs: ['add_qty'],
                defaultProps: { multiplier: 2.0, maxSteps: 5, maxLoss: 0.2 },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>å€æ•°</label>
                        <input type="number" step="0.1" min="1" max="5" value="${props.multiplier}" 
                               onchange="updateNodeProperty('multiplier', parseFloat(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>æœ€å¤§æ­¥æ•° (å®‰å…¨çº¢çº¿)</label>
                        <input type="number" min="1" max="10" value="${props.maxSteps}" 
                               onchange="updateNodeProperty('maxSteps', parseInt(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>æœ€å¤§ç´¯è®¡äºæŸ (%)</label>
                        <input type="number" step="0.01" min="0" max="1" value="${props.maxLoss}" 
                               onchange="updateNodeProperty('maxLoss', parseFloat(this.value))" />
                    </div>
                    <div class="validation-warning" style="margin-top: 12px;">
                        âš ï¸ é©¬ä¸æ ¼å°”ç­–ç•¥é£é™©æé«˜ï¼Œè¯·è°¨æ…ä½¿ç”¨å¹¶è®¾ç½®ä¸¥æ ¼çš„å®‰å…¨çº¢çº¿
                    </div>
                `
            },
            'risk_control': {
                title: 'é£æ§å®¡è®¡',
                type: 'position',
                inputs: ['entry_price', 'stoploss_price', 'position_qty'],
                outputs: ['risk_score'],
                defaultProps: { maxRiskPerTrade: 0.02, maxPositionSize: 1.0 },
                renderProps: (props) => `
                    <div class="property-group">
                        <label>å•ç¬”æœ€å¤§é£é™© (%)</label>
                        <input type="number" step="0.001" min="0" max="0.1" value="${props.maxRiskPerTrade}" 
                               onchange="updateNodeProperty('maxRiskPerTrade', parseFloat(this.value))" />
                    </div>
                    <div class="property-group">
                        <label>æœ€å¤§ä»“ä½å¤§å°</label>
                        <input type="number" step="0.1" min="0" max="10" value="${props.maxPositionSize}" 
                               onchange="updateNodeProperty('maxPositionSize', parseFloat(this.value))" />
                    </div>
                `
            }
        };

        // ==================== èŠ‚ç‚¹ç®¡ç† ====================
        let nodeIdCounter = 0;

        function createNode(operatorType, x, y) {
            const def = operatorDefinitions[operatorType];
            if (!def) return null;

            const node = {
                id: `node_${++nodeIdCounter}`,
                operator: operatorType,
                title: def.title,
                type: def.type,
                x: x,
                y: y,
                width: 200,
                height: 120,
                props: JSON.parse(JSON.stringify(def.defaultProps)),
                inputs: def.inputs || [],
                outputs: def.outputs || [],
                errors: []
            };

            nodes.push(node);
            renderNode(node);
            updateEmptyState();
            updateJSONPreview();
            return node;
        }

        function renderNode(node) {
            // åˆ›å»º DOM èŠ‚ç‚¹
            let nodeEl = document.getElementById(node.id);
            if (!nodeEl) {
                nodeEl = document.createElement('div');
                nodeEl.id = node.id;
                nodeEl.className = 'node';
                nodeEl.dataset.nodeId = node.id;
                document.querySelector('.canvas-area').appendChild(nodeEl);
            }

            // æ›´æ–°æ ·å¼
            nodeEl.className = 'node' + (selectedNode?.id === node.id ? ' selected' : '') + (node.errors.length > 0 ? ' error' : '');
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';

            // æ›´æ–°å†…å®¹
            nodeEl.innerHTML = `
                <div class="node-header">
                    <span class="node-title">${node.title}</span>
                    <span class="node-type">${node.type.toUpperCase()}</span>
                </div>
                <div class="node-body">
                    ${node.errors.length > 0 ? `<div style="color: #e74c3c; font-size: 10px;">âš  ${node.errors[0]}</div>` : ''}
                    ${Object.keys(node.props).slice(0, 2).map(key => {
                        const val = node.props[key];
                        if (typeof val === 'object') return '';
                        return `<div style="font-size: 10px; color: #888;">${key}: ${val}</div>`;
                    }).join('')}
                </div>
            `;

            // æ·»åŠ ç«¯å£
            node.inputs.forEach((input, idx) => {
                let port = nodeEl.querySelector(`.port-input-${idx}`);
                if (!port) {
                    port = document.createElement('div');
                    port.className = `node-port input port-input-${idx}`;
                    port.dataset.port = input;
                    port.dataset.nodeId = node.id;
                    port.dataset.portIndex = idx;
                    nodeEl.appendChild(port);
                }
                port.style.top = `${30 + idx * 25}px`;
            });

            node.outputs.forEach((output, idx) => {
                let port = nodeEl.querySelector(`.port-output-${idx}`);
                if (!port) {
                    port = document.createElement('div');
                    port.className = `node-port output port-output-${idx}`;
                    port.dataset.port = output;
                    port.dataset.nodeId = node.id;
                    port.dataset.portIndex = idx;
                    nodeEl.appendChild(port);
                }
                port.style.top = `${30 + idx * 25}px`;
            });

            // ç»‘å®šäº‹ä»¶
            nodeEl.onmousedown = (e) => {
                if (e.target.classList.contains('node-port')) return;
                selectNode(node);
                startDrag(e, node);
            };

            // ç«¯å£äº‹ä»¶
            nodeEl.querySelectorAll('.node-port').forEach(port => {
                port.onmousedown = (e) => {
                    e.stopPropagation();
                    startConnection(e, node, port);
                };
            });
        }

        function deleteNode(nodeId) {
            nodes = nodes.filter(n => n.id !== nodeId);
            connections = connections.filter(c => c.fromNode !== nodeId && c.toNode !== nodeId);
            const nodeEl = document.getElementById(nodeId);
            if (nodeEl) nodeEl.remove();
            if (selectedNode?.id === nodeId) selectedNode = null;
            updateConnections();
            updateEmptyState();
            updateJSONPreview();
        }

        // ==================== æ‹–æ‹½åŠŸèƒ½ ====================
        function startDrag(e, node) {
            dragState.isDragging = true;
            dragState.node = node;
            const rect = canvas.getBoundingClientRect();
            dragState.offset.x = e.clientX - rect.left - node.x;
            dragState.offset.y = e.clientY - rect.top - node.y;

            document.onmousemove = (e) => {
                if (!dragState.isDragging) return;
                const rect = canvas.getBoundingClientRect();
                node.x = e.clientX - rect.left - dragState.offset.x;
                node.y = e.clientY - rect.top - dragState.offset.y;
                renderNode(node);
                updateConnections();
            };

            document.onmouseup = () => {
                dragState.isDragging = false;
                document.onmousemove = null;
                document.onmouseup = null;
            };
        }

        // ==================== è¿çº¿åŠŸèƒ½ ====================
        function startConnection(e, node, port) {
            connectionState.isConnecting = true;
            connectionState.fromNode = node;
            connectionState.fromPort = port.dataset.port;
            connectionState.fromPortIndex = parseInt(port.dataset.portIndex);
            connectionState.isOutput = port.classList.contains('output');

            if (!connectionState.isOutput) {
                // å¦‚æœæ˜¯è¾“å…¥ç«¯å£ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ç°æœ‰è¿æ¥
                const existing = connections.find(c => c.toNode === node.id && c.toPort === connectionState.fromPort);
                if (existing) {
                    deleteConnection(existing.id);
                }
            }

            document.onmousemove = (e) => {
                if (!connectionState.isConnecting) return;
                // ç»˜åˆ¶ä¸´æ—¶è¿çº¿
                drawTempConnection(e);
            };

            document.onmouseup = (e) => {
                if (connectionState.isConnecting) {
                    finishConnection(e);
                }
                connectionState.isConnecting = false;
                document.onmousemove = null;
                document.onmouseup = null;
                clearTempConnection();
            };
        }

        function finishConnection(e) {
            const target = e.target;
            if (!target.classList.contains('node-port')) return;

            const toNodeId = target.dataset.nodeId;
            const toNode = nodes.find(n => n.id === toNodeId);
            if (!toNode) return;

            const toPort = target.dataset.port;
            const toPortIndex = parseInt(target.dataset.portIndex);
            const isToInput = target.classList.contains('input');

            // éªŒè¯è¿æ¥æœ‰æ•ˆæ€§
            if (connectionState.isOutput && !isToInput) return; // è¾“å‡ºåªèƒ½è¿è¾“å…¥
            if (!connectionState.isOutput && isToInput) return; // è¾“å…¥åªèƒ½è¿è¾“å‡º
            if (connectionState.fromNode.id === toNodeId) return; // ä¸èƒ½è‡ªè¿

            // æ£€æŸ¥æ˜¯å¦å½¢æˆç¯
            if (wouldCreateCycle(connectionState.fromNode.id, toNodeId)) {
                alert('âš ï¸ è¿æ¥ä¼šå½¢æˆå¾ªç¯ï¼Œå·²é˜»æ­¢');
                return;
            }

            // åˆ›å»ºè¿æ¥
            const conn = {
                id: `conn_${Date.now()}`,
                fromNode: connectionState.isOutput ? connectionState.fromNode.id : toNodeId,
                fromPort: connectionState.isOutput ? connectionState.fromPort : toPort,
                toNode: connectionState.isOutput ? toNodeId : connectionState.fromNode.id,
                toPort: connectionState.isOutput ? toPort : connectionState.fromPort
            };

            // ç§»é™¤åŒç«¯å£çš„æ—§è¿æ¥
            connections = connections.filter(c => 
                !(c.toNode === conn.toNode && c.toPort === conn.toPort)
            );

            connections.push(conn);
            updateConnections();
            updateJSONPreview();
            validateGraph();
        }

        function wouldCreateCycle(fromId, toId) {
            // ç®€å•çš„ç¯æ£€æµ‹ï¼šå¦‚æœ toId èƒ½åˆ°è¾¾ fromIdï¼Œåˆ™å½¢æˆç¯
            const visited = new Set();
            const queue = [toId];

            while (queue.length > 0) {
                const current = queue.shift();
                if (current === fromId) return true;
                if (visited.has(current)) continue;
                visited.add(current);

                connections.filter(c => c.fromNode === current).forEach(c => {
                    queue.push(c.toNode);
                });
            }
            return false;
        }

        function updateConnections() {
            // æ¸…é™¤æ—§è¿çº¿
            canvas.querySelectorAll('.connection-line').forEach(line => line.remove());

            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.fromNode);
                const toNode = nodes.find(n => n.id === conn.toNode);
                if (!fromNode || !toNode) return;

                const fromPort = fromNode.outputs.indexOf(conn.fromPort);
                const toPort = toNode.inputs.indexOf(conn.toPort);

                if (fromPort === -1 || toPort === -1) return;

                const x1 = fromNode.x + fromNode.width;
                const y1 = fromNode.y + 30 + fromPort * 25;
                const x2 = toNode.x;
                const y2 = toNode.y + 30 + toPort * 25;

                const path = document.createElementNS(svgNS, 'path');
                const midX = (x1 + x2) / 2;
                path.setAttribute('d', `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`);
                path.setAttribute('class', 'connection-line');
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.onclick = () => deleteConnection(conn.id);
                canvas.appendChild(path);
            });
        }

        function drawTempConnection(e) {
            clearTempConnection();
            if (!connectionState.isConnecting) return;

            const fromNode = connectionState.fromNode;
            const fromPortIndex = connectionState.fromPortIndex;
            const rect = canvas.getBoundingClientRect();
            const x1 = fromNode.x + (connectionState.isOutput ? fromNode.width : 0);
            const y1 = fromNode.y + 30 + fromPortIndex * 25;
            const x2 = e.clientX - rect.left;
            const y2 = e.clientY - rect.top;

            const path = document.createElementNS(svgNS, 'path');
            const midX = (x1 + x2) / 2;
            path.setAttribute('d', `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`);
            path.setAttribute('class', 'connection-line');
            path.setAttribute('style', 'stroke-dasharray: 5,5; opacity: 0.6;');
            path.id = 'temp-connection';
            canvas.appendChild(path);
        }

        function clearTempConnection() {
            const temp = document.getElementById('temp-connection');
            if (temp) temp.remove();
        }

        function deleteConnection(connId) {
            connections = connections.filter(c => c.id !== connId);
            updateConnections();
            updateJSONPreview();
        }

        // ==================== èŠ‚ç‚¹é€‰æ‹©ä¸å±æ€§ç¼–è¾‘ ====================
        function selectNode(node) {
            if (selectedNode) {
                const prevEl = document.getElementById(selectedNode.id);
                if (prevEl) prevEl.classList.remove('selected');
            }
            selectedNode = node;
            renderNode(node);
            showInspector(node);
        }

        function showInspector(node) {
            const def = operatorDefinitions[node.operator];
            if (!def) return;

            const content = document.getElementById('inspector-content');
            let html = `
                <div class="property-group">
                    <label>èŠ‚ç‚¹ç±»å‹</label>
                    <input type="text" value="${node.title}" disabled />
                </div>
            `;

            html += def.renderProps(node.props);
            html += `<button class="toolbar-btn danger" onclick="deleteNode('${node.id}')" style="margin-top: 16px; width: 100%;">åˆ é™¤èŠ‚ç‚¹</button>`;

            content.innerHTML = html;
        }

        function updateNodeProperty(key, value) {
            if (!selectedNode) return;
            selectedNode.props[key] = value;
            renderNode(selectedNode);
            showInspector(selectedNode);
            updateJSONPreview();
            validateGraph();
        }

        // ==================== JSON ç”Ÿæˆ ====================
        function generateRuntimeRules() {
            const rules = {
                entry: {},
                exit: {},
                position: {}
            };

            nodes.forEach(node => {
                const def = operatorDefinitions[node.operator];
                if (!def) return;

                const nodeData = {
                    id: node.id,
                    operator: node.operator,
                    type: node.type,
                    props: node.props,
                    connections: {
                        inputs: connections.filter(c => c.toNode === node.id).map(c => ({
                            from: c.fromNode,
                            port: c.fromPort
                        })),
                        outputs: connections.filter(c => c.fromNode === node.id).map(c => ({
                            to: c.toNode,
                            port: c.toPort
                        }))
                    }
                };

                if (node.type === 'entry') {
                    if (!rules.entry.nodes) rules.entry.nodes = [];
                    rules.entry.nodes.push(nodeData);
                } else if (node.type === 'exit') {
                    if (!rules.exit.nodes) rules.exit.nodes = [];
                    rules.exit.nodes.push(nodeData);
                } else if (node.type === 'position') {
                    if (!rules.position.nodes) rules.position.nodes = [];
                    rules.position.nodes.push(nodeData);
                }
            });

            return rules;
        }

        function updateJSONPreview() {
            const rules = generateRuntimeRules();
            const jsonText = JSON.stringify(rules, null, 2);
            const preview = document.getElementById('json-preview-text');
            preview.textContent = jsonText;
        }

        function copyJSON() {
            const rules = generateRuntimeRules();
            const jsonText = JSON.stringify(rules, null, 2);
            navigator.clipboard.writeText(jsonText).then(() => {
                alert('JSON å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
            });
        }

        function exportJSON() {
            const rules = generateRuntimeRules();
            const blob = new Blob([JSON.stringify(rules, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `strategy-rules-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ==================== éªŒè¯åŠŸèƒ½ ====================
        function validateGraph() {
            // æ¸…é™¤æ‰€æœ‰é”™è¯¯
            nodes.forEach(node => node.errors = []);

            nodes.forEach(node => {
                const def = operatorDefinitions[node.operator];
                if (!def) return;

                // éªŒè¯å¤šå› å­æƒé‡
                if (node.operator === 'multi_factor') {
                    const totalWeight = node.props.factors?.reduce((sum, f) => sum + (f.weight || 0), 0) || 0;
                    if (totalWeight > 1.01 || totalWeight < 0) {
                        node.errors.push(`å› å­æƒé‡æ€»å’Œ ${totalWeight.toFixed(2)} æ— æ•ˆï¼Œåº”åœ¨ 0-1 ä¹‹é—´`);
                    }
                }

                // éªŒè¯ ATR æ­¢æŸ
                if (node.operator === 'atr_stoploss') {
                    if (node.props.atrMultiplier > 10 || node.props.atrMultiplier < 0.1) {
                        node.errors.push('ATR å€æ•°åº”åœ¨ 0.1-10 ä¹‹é—´');
                    }
                }

                // éªŒè¯ç›ˆåˆ©ä¿æŠ¤
                if (node.operator === 'trailing_stop') {
                    if (node.props.profitThreshold <= 0 || node.props.trailBack <= 0) {
                        node.errors.push('ç›ˆåˆ©é˜ˆå€¼å’Œå›æ’¤å€¼å¿…é¡»å¤§äº 0');
                    }
                    if (node.props.trailBack >= node.props.profitThreshold) {
                        node.errors.push('å›æ’¤å€¼ä¸èƒ½å¤§äºç­‰äºç›ˆåˆ©é˜ˆå€¼');
                    }
                }

                // éªŒè¯é©¬ä¸æ ¼å°”
                if (node.operator === 'martingale') {
                    if (node.props.maxSteps > 10) {
                        node.errors.push('æœ€å¤§æ­¥æ•°è¶…è¿‡å®‰å…¨çº¢çº¿ (10)');
                    }
                    if (node.props.multiplier > 5) {
                        node.errors.push('å€æ•°è¶…è¿‡å®‰å…¨çº¢çº¿ (5)');
                    }
                }

                // éªŒè¯é‡‘å­—å¡”åŠ ä»“
                if (node.operator === 'pyramid_add') {
                    if (node.props.steps > node.props.maxSteps) {
                        node.errors.push(`åŠ ä»“æ­¥æ•° ${node.props.steps} è¶…è¿‡æœ€å¤§é™åˆ¶ ${node.props.maxSteps}`);
                    }
                }
            });

            // æ£€æŸ¥å¾ªç¯
            nodes.forEach(node => {
                if (wouldCreateCycle(node.id, node.id)) {
                    node.errors.push('èŠ‚ç‚¹å‚ä¸å¾ªç¯è¿æ¥');
                }
            });

            // é‡æ–°æ¸²æŸ“æ‰€æœ‰èŠ‚ç‚¹
            nodes.forEach(node => renderNode(node));

            // æ˜¾ç¤ºéªŒè¯ç»“æœ
            const errors = nodes.flatMap(n => n.errors);
            if (errors.length > 0) {
                const inspector = document.getElementById('inspector-content');
                if (selectedNode && selectedNode.errors.length === 0) {
                    // å¦‚æœæœ‰å…¶ä»–èŠ‚ç‚¹é”™è¯¯ï¼Œæ˜¾ç¤ºè­¦å‘Š
                    const warning = document.createElement('div');
                    warning.className = 'validation-warning';
                    warning.innerHTML = `âš ï¸ ç”»å¸ƒä¸Šæœ‰ ${errors.length} ä¸ªéªŒè¯é”™è¯¯`;
                    inspector.appendChild(warning);
                }
            }
        }

        function validateAndSave() {
            validateGraph();
            const errors = nodes.flatMap(n => n.errors);
            if (errors.length > 0) {
                alert(`âŒ éªŒè¯å¤±è´¥ï¼Œå‘ç° ${errors.length} ä¸ªé”™è¯¯ï¼š\n${errors.slice(0, 3).join('\n')}${errors.length > 3 ? '\n...' : ''}`);
                return;
            }

            if (nodes.length === 0) {
                alert('âš ï¸ ç”»å¸ƒä¸ºç©ºï¼Œæ— æ³•ä¿å­˜');
                return;
            }

            const rules = generateRuntimeRules();
            console.log('éªŒè¯é€šè¿‡ï¼Œè§„åˆ™ï¼š', rules);
            alert('âœ… éªŒè¯é€šè¿‡ï¼è§„åˆ™å·²ä¿å­˜åˆ°æ§åˆ¶å°ï¼ˆå®é™…åº”å‘é€åˆ°åç«¯ï¼‰');
        }

        // ==================== å·¥å…·å‡½æ•° ====================
        function clearCanvas() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºç”»å¸ƒå—ï¼Ÿ')) {
                nodes = [];
                connections = [];
                selectedNode = null;
                document.querySelectorAll('.node').forEach(el => el.remove());
                updateConnections();
                updateEmptyState();
                updateJSONPreview();
                document.getElementById('inspector-content').innerHTML = '<p style="color: #666; text-align: center; margin-top: 40px;">ç‚¹å‡»èŠ‚ç‚¹ç¼–è¾‘å±æ€§</p>';
            }
        }

        function updateEmptyState() {
            const emptyState = document.getElementById('empty-state');
            if (nodes.length === 0) {
                emptyState.style.display = 'block';
            } else {
                emptyState.style.display = 'none';
            }
        }

        function loadExample() {
            clearCanvas();
            
            // åˆ›å»ºç¤ºä¾‹èŠ‚ç‚¹
            const rsi = createNode('indicator_rsi', 50, 100);
            const ma = createNode('indicator_ma', 50, 250);
            const multiFactor = createNode('multi_factor', 300, 150);
            const entry = createNode('signal_trigger', 550, 150);
            
            const atrStop = createNode('atr_stoploss', 300, 400);
            const trailing = createNode('trailing_stop', 550, 400);
            
            const dynamicSize = createNode('dynamic_sizing', 800, 150);
            const riskControl = createNode('risk_control', 800, 400);

            // åˆ›å»ºè¿æ¥
            setTimeout(() => {
                // æ¨¡æ‹Ÿè¿æ¥ï¼ˆå®é™…åº”é€šè¿‡ UI æ“ä½œï¼‰
                console.log('ç¤ºä¾‹èŠ‚ç‚¹å·²åˆ›å»ºï¼Œè¯·æ‰‹åŠ¨è¿æ¥');
            }, 100);
        }

        // ==================== æ‹–æ‹½ç®—å­åˆ°ç”»å¸ƒ ====================
        document.querySelectorAll('.operator-item').forEach(item => {
            item.onmousedown = (e) => {
                item.classList.add('dragging');
                const operator = item.dataset.operator;
                
                document.onmousemove = (e) => {
                    // è·Ÿéšé¼ æ ‡
                };

                document.onmouseup = (e) => {
                    item.classList.remove('dragging');
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    if (x > 0 && y > 0 && x < rect.width && y < rect.height) {
                        createNode(operator, x - 100, y - 60);
                    }
                    
                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            };
        });

        // ==================== åˆå§‹åŒ– ====================
        updateEmptyState();
        updateJSONPreview();

        // é”®ç›˜å¿«æ·é”®
        document.onkeydown = (e) => {
            if (e.key === 'Delete' && selectedNode) {
                deleteNode(selectedNode.id);
            }
        };
    </script>
</body>
</html>
           