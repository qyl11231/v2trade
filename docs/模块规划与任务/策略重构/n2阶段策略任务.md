

## Step 0：量化团队分工 + 与产品对齐结论（N2 只做“接入与打印”，不做决策）

**团队匹配**

* **系统架构/事件工程师**：事件模型、路由、去重、异步队列
* **后端 Java**：Adapter 接入、Mapper 扩展、缓存索引、日志规范
* **SRE/性能**：压测脚本、线程池参数、观测指标
* **QA**：Given/When/Then 用例、重复事件/乱序/高频验证
* **前端/产品**：N2 不新增 UI（最多加“测试触发器”入口可选）

**和产品沟通后的边界裁决**

* ✅ N2 交付物是：**事件进入系统 → 路由到实例 → 幂等去重 → 异步消费 → 控制台/日志统一打印**
* ❌ 不做：规则结算、状态机推进、写 `rules_record/intent_record`（这些属于 N3/N5/N6）

---

## Step 1：目标与边界（N2）

### 1.1 核心目标

接入并打印三类事件（来源可以是内部模块/消息/HTTP），且能定位到受影响实例：

1. **BarClosedEvent**（K 线闭合）
2. **PriceTickEvent**（价格更新/最新价）
3. **SignalReceivedEvent**（外部信号到达）

### 1.2 输入依赖

* N1 已完成：`strategy_instance` 可查，且启用状态可用；路由主键以 `strategy_instance_id` 为准。 
* 交易对与信号配置已存在（`trading_pair` / `signal_config`）

### 1.3 输出交付

* 打印链路：`event -> matched instanceIds -> print`
* **重复事件不刷屏**（30s TTL 去重）
* **事件处理不阻塞行情/聚合线程**（异步）

---

## Step 2：事件统一模型（StrategyTrigger）

> 这是 N2 的“统一输入协议”。后续 N3/N5/N6 都复用它，避免返工。 

### 2.1 核心结构

**包建议**
`com.qyl.v2trade.business.strategy.runtime.trigger`

**关键类**

* `enum TriggerType { BAR_CLOSE, PRICE, SIGNAL }`
* `class StrategyTrigger`

  * `TriggerType triggerType`
  * `String eventKey`（幂等键，必须全局可复现）
  * `Instant asOfTimeUtc`（统一 UTC 语义）
  * `Long tradingPairId`（BAR/PRICE 必填）
  * `String strategySymbol`（用于打印/排障，可选）
  * `String timeframe`（BAR_CLOSE 必填，如 “5m/1h”）
  * `Long signalConfigId`（SIGNAL 必填）
  * `String signalId`（SIGNAL 强烈建议提供，用于幂等与追踪）
  * `BigDecimal price`（PRICE 必填；SIGNAL 可带 signalPrice）
  * `Signal signalInfo`（SIGNAL 详细信息）

### 2.2 eventKey 规范（必须冻结）

* **BAR_CLOSE**：`BAR:{pairId}:{timeframe}:{barCloseEpochMillis}`
* **PRICE**：`PRICE:{pairId}:{priceEpochMillis or seq}`

  * 若没有 seq，用毫秒时间；**高频时会更“稀疏去重”**，可接受（N2 只打印）
* **SIGNAL**：`SIGNAL:{signalConfigId}:{signalId}`（signalId 必须唯一；没有则退化为 hash(payload)）

---

## Step 3：事件接入层（Adapter / Ingress）

> 不管事件来自 MQ、WebSocket、HTTP、内部回调，都先落到 Trigger。

### 3.1 接入接口定义

**包建议**
`com.qyl.v2trade.business.strategy.runtime.ingress`

* `interface TriggerIngress { void accept(StrategyTrigger trigger); }`

### 3.2 三类 Adapter

* `BarClosedIngressAdapter`

  * 从 K 线聚合器拿到 bar close → build trigger → `ingress.accept`
* `PriceTickIngressAdapter`

  * 从行情最新价订阅 → build trigger → `ingress.accept`
* `SignalReceivedIngressAdapter`

  * 从信号模块（或 HTTP 接口）→ build trigger → `ingress.accept`

> **硬要求**：Adapter 里只做“轻量转换”，不能查库、不能路由、不能重逻辑（避免阻塞上游线程）。 

---

## Step 4：路由层（EventRouter）——把事件映射到 strategy_instance_id

### 4.1 路由规则（冻结）

* BAR_CLOSE：`tradingPairId + timeframe -> enabled instances`

  * **N2 简化**：先按 `trading_pair_id` 路由；timeframe 先用于打印（后续 N4/N5 才真正用）
* PRICE：`tradingPairId -> enabled instances`
* SIGNAL：`signalConfigId -> enabled instances`

### 4.2 数据访问与缓存策略（避免每个事件查 DB）

**核心结论**：N2 就要具备“可压测”，所以要做**实例路由索引缓存**。

**推荐实现**

* 启动时加载（或首次使用时加载）：

  * `Map<Long tradingPairId, List<Long instanceId>> pairIndex`
  * `Map<Long signalConfigId, List<Long instanceId>> signalIndex`
* 索引数据来源：`strategy_instance`（只取必要字段：`id,user_id,trading_pair_id,signal_config_id,enabled,strategy_symbol`）

**缓存更新方式（N2 先做最小闭环）**

* 方案 A（推荐，简单可靠）：索引缓存 **TTL 30~60s 自动刷新**（不依赖 UI/事件联动）
* 方案 B（增强）：在 N1 的 instance toggle/create/update 后，发一个本地事件让索引即时刷新（可选）

### 4.3 Mapper 扩展（建议加方法）

在 `StrategyInstanceMapper` 新增：

* `List<StrategyInstance> selectEnabledByTradingPairId(Long tradingPairId)`
* `List<StrategyInstance> selectEnabledBySignalConfigId(Long signalConfigId)`
* `List<StrategyInstance> selectAllEnabled()`（用于启动预热索引）

> 索引缺失会拖垮路由：建议数据库加索引（见 Step 7）。 

---

## Step 5：幂等去重（Dedup）——30 秒内同 eventKey 只处理一次

### 5.1 组件定义

**包建议**
`com.qyl.v2trade.business.strategy.runtime.dedup`

* `interface TriggerDeduplicator { boolean shouldProcess(String eventKey); }`

### 5.2 实现建议

* 使用 **Caffeine**（或 Guava Cache / ConcurrentHashMap + 定时清理）
* 策略：`expireAfterWrite(30s)`
* `shouldProcess`：第一次返回 true，30s 内重复返回 false

### 5.3 验收点

* 重复 BAR_CLOSE（同一根 bar close）不刷屏
* 信号重放（相同 signalId）不刷屏

---

## Step 6：异步消费（不阻塞上游线程）

### 6.1 处理链路

`IngressAdapter -> TriggerIngress.accept -> Dedup -> Router -> DispatchToAsync -> Print`

### 6.2 最小可用实现

* `BlockingQueue<StrategyTrigger>` + `ThreadPoolExecutor` 消费
* 或 Spring `@Async`（但要注意线程池隔离与背压）

**背压/保护（建议 N2 就加）**

* 队列满：丢弃低价值事件（PRICE）并打 warn；BAR_CLOSE/SIGNAL 尽量不丢（或单独队列）
* 线程池命名：`strategy-trigger-worker-%d`

---

## Step 7：统一打印规范（可 grep、可审计、可压测）

### 7.1 打印字段（冻结）

每条 “实例打印” 必须包含：

* `triggerType`
* `eventKey`
* `asOfTimeUtc`
* `tradingPairId`
* `strategySymbol`（若有）
* `timeframe`（bar）
* `signalConfigId` / `signalId`（signal）
* `instanceId`
* `userId`

### 7.2 打印格式（建议 JSON 单行）

示例（单行）：

```text
STRATEGY_TRIGGER route_print {"type":"BAR_CLOSE","eventKey":"BAR:12:1m:1730000000000","asOf":"2026-01-15T00:00:00Z","pairId":12,"tf":"1m","instanceId":9001,"userId":10001}
```

---

## Step 8：数据库索引与约束（N2 允许加索引，不加新表）

为了让路由查询稳定：

* `strategy_instance(trading_pair_id, enabled)`
* `strategy_instance(signal_config_id, enabled)`
* `strategy_instance(user_id, enabled)`（可选）
* 若你们实例表还未落 `enabled` 字段（SQL 与实体不一致时），需要补齐 `ALTER TABLE`（否则路由的 “enabled 实例” 过滤无法保证）。 

---

## Step 9：验收标准（DoD，Given/When/Then）

### 9.1 BAR_CLOSE 路由正确

* **Given**：pair=BTCUSDT 的 enabled 实例有 3 个
* **When**：发送 BAR_CLOSE(pairId=xx, timeframe=1m, closeTime=T)
* **Then**：打印 3 行（每个 instance 一行），字段齐全，eventKey 一致

### 9.2 PRICE 异步不阻塞

* **Given**：价格事件 2000 msg/s
* **When**：持续 60s 压测
* **Then**：上游线程无明显阻塞；队列有背压策略日志；系统不 OOM、不大量 Full GC

### 9.3 SIGNAL 幂等去重

* **Given**：同一个 signalId 重放 10 次
* **When**：10 次到达
* **Then**：只打印一次（或每个 instance 只打印一次），其余被 dedup

### 9.4 Dedup TTL 生效

* **Given**：同 eventKey 在 30s 内重复
* **When**：重复发送
* **Then**：30s 内不重复打印；超过 30s 可再次打印

---

## Step 10：开发顺序建议（两天内可闭环）

1. 定义 `StrategyTrigger / TriggerType / eventKey 规范`
2. 做 `Deduplicator`（Caffeine TTL）
3. 做 `EventRouter`（先 DB 查询版跑通）
4. 加 `RouteIndexCache`（TTL 刷新，替换 DB per-event 查询）
5. 接入三类 Adapter（先做 mock/测试接口）
6. 异步队列 + 统一打印
7. 压测与日志验收 + 索引补齐

---

## 总结

* **N2 的交付本质**：把“外部世界的事件”变成系统内部统一的 `StrategyTrigger`，并做到 **正确路由到 strategy_instance_id、30s 幂等去重、异步消费不阻塞、统一可 grep 打印、可压测**。 
* 你后续 N3/N5/N6 能不能稳，关键就看 N2 是否把 **路由索引缓存、去重、异步背压、时间语义（UTC + barCloseTime）** 这些底座一次性做对。  
