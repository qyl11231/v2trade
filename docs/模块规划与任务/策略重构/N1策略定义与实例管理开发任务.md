# N1：策略定义 + 策略实例管理闭环 - 开发任务详情

> **节点目标**：用户在 Web 上完成策略定义和实例的创建、查询、启停等操作，建立完整的管理闭环。

---

## 一、目标与边界

### 1.1 核心目标

- ✅ 用户在 Web 上创建策略 definition（策略模板）
- ✅ 用户在 Web 上创建策略 instance（绑定交易对、绑定信号、初始资金、TP/SL）
- ✅ 用户在 Web 上查看策略详情（definition + instances 列表）
- ✅ 用户在 Web 上启用/禁用策略 definition 和 instance

### 1.2 输入依赖

- ✅ `trading_pair` 表已存在且可查询
- ✅ `signal_config` 表已存在且可查询（可选绑定）
- ✅ 用户认证体系已就绪（从请求头获取 `userId`）

### 1.3 输出交付

- ✅ DB 有 `strategy_definition`、`strategy_instance` 数据，可查询
- ✅ Web 页面可操作（列表、创建、详情、启停）
- ✅ API 接口完整可用
- ✅ 数据校验完整（唯一性、合法性）

---

## 二、后端开发任务

### 2.1 数据模型层（Entity）

#### 2.1.1 StrategyDefinition Entity

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/model/entity/StrategyDefinition.java`

**字段映射**（参考 `strategy.sql`）：

```java
- id: Long (主键，自增)
- userId: Long (所属用户ID)
- strategyName: String (策略名称，64字符)
- strategyType: String (策略类型：Martin/Grid/Trend/Arbitrage)
- strategyPattern: String (策略模式：SIGNAL_DRIVEN/INDICATOR_DRIVEN/HYBRID)
- enabled: Integer (是否启用：1-启用 0-禁用)
- createdAt: LocalDateTime (自动填充)
- updatedAt: LocalDateTime (自动填充)
```

**约束要求**：
- 使用 `@TableName("strategy_definition")`
- 使用 `@Data`、`@TableId(type = IdType.AUTO)`
- `createdAt`、`updatedAt` 使用 `@TableField(fill = FieldFill.INSERT/INSERT_UPDATE)`
- 添加 JavaDoc 注释

#### 2.1.2 StrategyInstance Entity

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/model/entity/StrategyInstance.java`

#### 2.1.3 StrategyInstanceHistory Entity（新增）

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/model/entity/StrategyInstanceHistory.java`

**字段映射**（参考 `strategy.sql`）：

```java
- id: Long (主键，自增)
- userId: Long (所属用户ID)
- strategyId: Long (策略ID)
- strategyInstanceId: Long (策略实例ID，外键关联 strategy_instance.id)
- signalConfigId: Long (绑定信号定义ID，0表示无信号绑定)
- tradingPairId: Long (交易对ID)
- strategySymbol: String (策略交易对，32字符)
- initialCapital: BigDecimal (策略初始资金)
- runtimeRules: String (策略大脑运行规则JSON，可为空)
- takeProfitRatio: BigDecimal (策略止盈比例，可为空)
- stopLossRatio: BigDecimal (策略止损比例，可为空)
- version: Integer (版本号)
- createdAt: LocalDateTime (历史记录创建时间)
- updatedAt: LocalDateTime (自动填充)
```

**约束要求**：
- 使用 `@TableName("strategy_instance_history")`
- 使用 `@Data`、`@TableId(type = IdType.AUTO)`
- `runtimeRules` 使用 `@TableField(typeHandler = com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler)` 处理 JSON
- 添加 JavaDoc 注释

**字段映射**（参考 `strategy.sql`）：

```java
- id: Long (主键，自增)
- userId: Long (所属用户ID)
- strategyId: Long (策略ID，外键关联 strategy_definition.id)
- signalConfigId: Long (绑定信号定义ID，可为空)
- tradingPairId: Long (交易对ID，外键关联 trading_pair.id)
- strategySymbol: String (策略交易对，32字符)
- initialCapital: BigDecimal (策略初始资金，20位整数8位小数)
- runtimeRules: String (策略大脑运行规则JSON，可为空，N4阶段使用)
- takeProfitRatio: BigDecimal (策略止盈比例，10位整数4位小数，可为空)
- stopLossRatio: BigDecimal (策略止损比例，10位整数4位小数，可为空)
- version: Integer (版本号，默认1)
- createdAt: LocalDateTime (自动填充)
- updatedAt: LocalDateTime (自动填充)
```

**约束要求**：
- 使用 `@TableName("strategy_instance")`
- 使用 `@Data`、`@TableId(type = IdType.AUTO)`
- `runtimeRules` 使用 `@TableField(typeHandler = com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler)` 处理 JSON
- 添加 JavaDoc 注释

### 2.2 数据访问层（Mapper）

#### 2.2.0 StrategyInstanceHistoryMapper（新增）

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/mapper/StrategyInstanceHistoryMapper.java`

**接口定义**：
```java
@Mapper
public interface StrategyInstanceHistoryMapper extends BaseMapper<StrategyInstanceHistory> {
    /**
     * 根据实例ID查询历史记录列表（按版本号倒序）
     */
    List<StrategyInstanceHistory> selectByInstanceId(@Param("instanceId") Long instanceId);
    
    /**
     * 根据实例ID和版本号查询历史记录
     */
    StrategyInstanceHistory selectByInstanceIdAndVersion(@Param("instanceId") Long instanceId, 
                                                          @Param("version") Integer version);
}
```

**Mapper XML**：`src/main/resources/mapper/strategy/StrategyInstanceHistoryMapper.xml`

#### 2.2.1 StrategyDefinitionMapper

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/mapper/StrategyDefinitionMapper.java`

**接口定义**：
```java
@Mapper
public interface StrategyDefinitionMapper extends BaseMapper<StrategyDefinition> {
    /**
     * 根据用户ID和策略名称查询（用于唯一性校验）
     */
    StrategyDefinition selectByUserIdAndStrategyName(@Param("userId") Long userId, 
                                                      @Param("strategyName") String strategyName);
    
    /**
     * 查询用户的所有策略定义（支持按enabled过滤）
     */
    List<StrategyDefinition> selectByUserId(@Param("userId") Long userId, 
                                             @Param("enabled") Integer enabled);
}
```

#### 2.2.2 StrategyInstanceMapper

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/mapper/StrategyInstanceMapper.java`

**接口定义**：
```java
@Mapper
public interface StrategyInstanceMapper extends BaseMapper<StrategyInstance> {
    /**
     * 根据策略ID查询所有实例
     */
    List<StrategyInstance> selectByStrategyId(@Param("strategyId") Long strategyId);
    
    /**
     * 根据用户ID和策略ID查询实例列表
     */
    List<StrategyInstance> selectByUserIdAndStrategyId(@Param("userId") Long userId, 
                                                        @Param("strategyId") Long strategyId);
    
    /**
     * 唯一性校验：同一用户、同一策略、同一交易对、同一信号配置 = 唯一实例
     */
    StrategyInstance selectByUniqueKey(@Param("userId") Long userId,
                                       @Param("strategyId") Long strategyId,
                                       @Param("tradingPairId") Long tradingPairId,
                                       @Param("signalConfigId") Long signalConfigId);
}
```

**Mapper XML**：
- `src/main/resources/mapper/strategy/StrategyDefinitionMapper.xml`
- `src/main/resources/mapper/strategy/StrategyInstanceMapper.xml`

### 2.3 业务逻辑层（Service）

#### 2.3.1 StrategyDefinitionService

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/service/StrategyDefinitionService.java`

**接口方法**：
```java
public interface StrategyDefinitionService extends IService<StrategyDefinition> {
    /**
     * 创建策略定义
     * @param request 创建请求DTO
     * @param userId 用户ID
     * @return 创建的策略定义
     * @throws BusinessException 策略名称已存在、参数校验失败
     */
    StrategyDefinition create(StrategyDefinitionCreateRequest request, Long userId);
    
    /**
     * 更新策略定义
     * @param id 策略ID
     * @param request 更新请求DTO
     * @param userId 用户ID
     * @return 更新后的策略定义
     * @throws BusinessException 策略不存在、无权限、策略名称冲突
     */
    StrategyDefinition update(Long id, StrategyDefinitionUpdateRequest request, Long userId);
    
    /**
     * 启用/禁用策略定义
     * @param id 策略ID
     * @param enabled 1-启用 0-禁用
     * @param userId 用户ID
     * @return 更新后的策略定义
     * @throws BusinessException 策略不存在、无权限
     */
    StrategyDefinition toggleEnabled(Long id, Integer enabled, Long userId);
    
    /**
     * 查询策略详情（含实例列表）
     * @param id 策略ID
     * @param userId 用户ID
     * @return 策略详情VO（含instances列表）
     * @throws BusinessException 策略不存在、无权限
     */
    StrategyDefinitionDetailVO getDetail(Long id, Long userId);
    
    /**
     * 查询用户的所有策略定义列表
     * @param userId 用户ID
     * @param enabled 是否启用（可选，null表示全部）
     * @return 策略定义列表
     */
    List<StrategyDefinitionVO> listByUserId(Long userId, Integer enabled);
}
```

**实现类**：`src/main/java/com/qyl/v2trade/business/strategy/service/impl/StrategyDefinitionServiceImpl.java`

**核心校验逻辑**：
1. **唯一性校验**：`unique(user_id, strategy_name)` - 同一用户下策略名称不能重复
2. **权限校验**：只能操作自己的策略
3. **参数校验**：`strategyType`、`strategyPattern` 必须是枚举值
4. **日志记录**：关键操作记录 `userId`、`strategyId`、`strategyName`

#### 2.3.2 StrategyInstanceService

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/service/StrategyInstanceService.java`

**接口方法**：
```java
public interface StrategyInstanceService extends IService<StrategyInstance> {
    /**
     * 创建策略实例
     * @param request 创建请求DTO
     * @param userId 用户ID
     * @return 创建的策略实例
     * @throws BusinessException 策略不存在、交易对不存在、信号配置不存在、实例已存在、参数校验失败
     */
    StrategyInstance create(StrategyInstanceCreateRequest request, Long userId);
    
    /**
     * 更新策略实例
     * @param id 实例ID
     * @param request 更新请求DTO
     * @param userId 用户ID
     * @return 更新后的策略实例
     * @throws BusinessException 实例不存在、无权限、参数校验失败
     */
    StrategyInstance update(Long id, StrategyInstanceUpdateRequest request, Long userId);
    
    /**
     * 启用/禁用策略实例
     * @param id 实例ID
     * @param enabled 1-启用 0-禁用
     * @param userId 用户ID
     * @return 更新后的策略实例
     * @throws BusinessException 实例不存在、无权限
     */
    StrategyInstance toggleEnabled(Long id, Integer enabled, Long userId);
    
    /**
     * 查询策略实例详情
     * @param id 实例ID
     * @param userId 用户ID
     * @return 策略实例详情VO
     * @throws BusinessException 实例不存在、无权限
     */
    StrategyInstanceDetailVO getDetail(Long id, Long userId);
    
    /**
     * 根据策略ID查询实例列表
     * @param strategyId 策略ID
     * @param userId 用户ID
     * @return 实例列表
     */
    List<StrategyInstanceVO> listByStrategyId(Long strategyId, Long userId);
    
    /**
     * 查询策略实例历史记录列表
     * @param instanceId 实例ID
     * @param userId 用户ID
     * @return 历史记录列表（按版本号倒序）
     * @throws BusinessException 实例不存在、无权限
     */
    List<StrategyInstanceHistoryVO> listHistory(Long instanceId, Long userId);
    
    /**
     * 查询策略实例历史记录详情
     * @param historyId 历史记录ID
     * @param userId 用户ID
     * @return 历史记录详情
     * @throws BusinessException 历史记录不存在、无权限
     */
    StrategyInstanceHistoryVO getHistoryDetail(Long historyId, Long userId);
}
```

**实现类**：`src/main/java/com/qyl/v2trade/business/strategy/service/impl/StrategyInstanceServiceImpl.java`

**核心校验逻辑**：
1. **唯一性校验**：`unique(user_id, strategy_id, trading_pair_id, signal_config_id)` - 同一策略、同一交易对、同一信号配置 = 唯一实例（允许同策略同交易对不同信号=不同实例）
   - **注意**：`signal_config_id` 为 0 表示"无信号绑定"，用于唯一性约束
2. **外键校验**：
   - `strategyId` 必须存在且属于该用户
   - `tradingPairId` 必须存在
   - `signalConfigId` 如果提供且不为0，必须存在且属于该用户
3. **参数校验**：
   - `initialCapital > 0`
   - `takeProfitRatio`、`stopLossRatio` 如果提供，必须在合理范围（0-1之间）
   - `strategySymbol` 必须与 `tradingPair.symbol` 一致（合约类型需确保有-SWAP后缀）
4. **权限校验**：只能操作自己的实例
5. **版本管理**：
   - 更新实例时，先将当前版本数据保存到 `strategy_instance_history` 表
   - 版本号自增（当前版本号 + 1）
   - 历史记录包含完整的实例快照信息
6. **日志记录**：关键操作记录 `userId`、`strategyId`、`strategyInstanceId`、`version`

### 2.4 数据传输对象（DTO）

#### 2.4.1 请求DTO

**StrategyDefinitionCreateRequest**
```java
- strategyName: String (@NotBlank, @Size(max=64))
- strategyType: String (@NotBlank, 枚举值：Martin/Grid/Trend/Arbitrage)
- strategyPattern: String (@NotBlank, 枚举值：SIGNAL_DRIVEN/INDICATOR_DRIVEN/HYBRID)
- enabled: Integer (可选，默认1)
```

**StrategyDefinitionUpdateRequest**
```java
- strategyName: String (@NotBlank, @Size(max=64))
- strategyType: String (@NotBlank)
- strategyPattern: String (@NotBlank)
- enabled: Integer (可选)
```

**StrategyInstanceCreateRequest**
```java
- strategyId: Long (@NotNull)
- signalConfigId: Long (可选，不提供或为null时自动设置为0表示无信号绑定)
- tradingPairId: Long (@NotNull)
- strategySymbol: String (自动生成，从tradingPair获取，合约类型自动添加-SWAP后缀)
- initialCapital: BigDecimal (@NotNull, @DecimalMin("0.00000001"))
- takeProfitRatio: BigDecimal (可选, @DecimalMin("0"), @DecimalMax("1"))
- stopLossRatio: BigDecimal (可选, @DecimalMin("0"), @DecimalMax("1"))
```

**StrategyInstanceUpdateRequest**
```java
- signalConfigId: Long (可选)
- initialCapital: BigDecimal (@NotNull, @DecimalMin("0.00000001"))
- takeProfitRatio: BigDecimal (可选)
- stopLossRatio: BigDecimal (可选)
```

#### 2.4.2 响应VO

**StrategyDefinitionVO**
```java
- id: Long
- userId: Long
- strategyName: String
- strategyType: String
- strategyPattern: String
- enabled: Integer
- createdAt: LocalDateTime
- updatedAt: LocalDateTime
```

**StrategyDefinitionDetailVO**（继承 StrategyDefinitionVO）
```java
- instances: List<StrategyInstanceVO> (实例列表)
```

**StrategyInstanceVO**
```java
- id: Long
- userId: Long
- strategyId: Long
- strategyName: String (关联查询)
- signalConfigId: Long
- signalConfigName: String (关联查询，可选)
- tradingPairId: Long
- tradingPairSymbol: String (关联查询)
- strategySymbol: String
- initialCapital: BigDecimal
- runtimeRules: String (JSON字符串)
- takeProfitRatio: BigDecimal
- stopLossRatio: BigDecimal
- version: Integer
- enabled: Integer
- createdAt: LocalDateTime
- updatedAt: LocalDateTime
```

**StrategyInstanceDetailVO**（继承 StrategyInstanceVO）
```java
- strategyDefinition: StrategyDefinitionVO (策略定义详情)
- tradingPair: TradingPairVO (交易对详情，可选)
- signalConfig: SignalConfigVO (信号配置详情，可选)
```

**StrategyInstanceHistoryVO**
```java
- id: Long (历史记录ID)
- userId: Long
- strategyId: Long
- strategyInstanceId: Long
- signalConfigId: Long (0表示无信号绑定)
- signalConfigName: String (关联查询，可选)
- tradingPairId: Long
- tradingPairSymbol: String (关联查询)
- strategySymbol: String
- initialCapital: BigDecimal
- runtimeRules: String (JSON字符串)
- takeProfitRatio: BigDecimal
- stopLossRatio: BigDecimal
- version: Integer (版本号)
- createdAt: LocalDateTime (历史记录创建时间)
- updatedAt: LocalDateTime
```

### 2.5 控制器层（Controller）

#### 2.5.1 StrategyDefinitionController

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/controller/StrategyDefinitionController.java`

**接口清单**：

| 方法 | 路径 | 说明 |
|------|------|------|
| POST | `/api/strategy/definition` | 创建策略定义 |
| PUT | `/api/strategy/definition/{id}` | 更新策略定义 |
| GET | `/api/strategy/definition/{id}` | 查询策略详情（含实例列表） |
| GET | `/api/strategy/definition/list` | 查询策略定义列表 |
| PUT | `/api/strategy/definition/{id}/toggle` | 启用/禁用策略定义 |

**请求头要求**：
- 所有接口需要 `X-User-Id` 请求头（从 `common.js` 的 `getUserHeader()` 获取）

**示例代码结构**：
```java
@RestController
@RequestMapping("/api/strategy/definition")
public class StrategyDefinitionController {
    
    @PostMapping
    public Result<StrategyDefinitionVO> create(@RequestBody @Valid StrategyDefinitionCreateRequest request,
                                                @RequestHeader("X-User-Id") Long userId) {
        // 调用 service.create(request, userId)
        // 返回 Result.success(vo)
    }
    
    // ... 其他方法
}
```

#### 2.5.2 StrategyInstanceController

**文件路径**：`src/main/java/com/qyl/v2trade/business/strategy/controller/StrategyInstanceController.java`

**接口清单**：

| 方法 | 路径 | 说明 |
|------|------|------|
| POST | `/api/strategy/instance` | 创建策略实例 |
| PUT | `/api/strategy/instance/{id}` | 更新策略实例 |
| GET | `/api/strategy/instance/{id}` | 查询策略实例详情 |
| GET | `/api/strategy/instance/list` | 查询策略实例列表（支持按strategyId过滤） |
| PUT | `/api/strategy/instance/{id}/toggle` | 启用/禁用策略实例 |
| GET | `/api/strategy/instance/{id}/history` | 查询策略实例历史记录列表 |
| GET | `/api/strategy/instance/history/{historyId}` | 查询策略实例历史记录详情 |

**请求头要求**：
- 所有接口需要 `X-User-Id` 请求头

---

## 三、前端开发任务

### 3.1 页面结构

#### 3.1.1 策略定义列表页

**文件路径**：`src/main/resources/static/strategy-list.html`

**功能要求**：
1. 展示策略定义列表（表格）
2. 支持创建策略定义（弹窗/跳转）
3. 支持查看策略详情（跳转）
4. 支持启用/禁用策略定义（开关）
5. 支持编辑策略定义（弹窗/跳转）

**表格列**：
- 策略名称
- 策略类型（Martin/Grid/Trend/Arbitrage）
- 策略模式（信号驱动/指标驱动/混合）
- 状态（启用/禁用）
- 创建时间
- 操作（查看详情、编辑、启用/禁用）

**交互要求**：
- 使用 Layui table 组件
- 支持状态筛选（全部/启用/禁用）
- 创建/编辑使用弹窗表单
- 启用/禁用使用开关组件，需二次确认

#### 3.1.2 策略定义详情页

**文件路径**：`src/main/resources/static/strategy-detail.html`

**功能要求**：
1. 展示策略定义基本信息
2. 展示该策略下的所有实例列表
3. 支持创建新实例（弹窗）
4. 支持查看实例详情（跳转）
5. 支持编辑策略定义（弹窗）

**页面布局**：
- 顶部：策略定义信息卡片（名称、类型、模式、状态等）
- 中部：实例列表表格
- 底部：操作按钮（创建实例、返回列表）

#### 3.1.3 策略实例创建/编辑弹窗

**功能要求**：
1. 表单字段：
   - 策略选择（下拉，只读，从详情页传入）
   - 交易对选择（下拉，必填）
   - 信号配置选择（下拉，可选）
   - 初始资金（数字输入，必填）
   - 止盈比例（数字输入，可选，0-1）
   - 止损比例（数字输入，可选，0-1）
2. 表单校验：
   - 所有必填项校验
   - 数字范围校验
   - 唯一性校验（提交时后端返回）
3. 提交成功后刷新列表

#### 3.1.4 策略实例列表页（可选）

**文件路径**：`src/main/resources/static/strategy-instance-list.html`

**功能要求**：
1. 展示所有策略实例列表（跨策略）
2. 支持按策略ID过滤
3. 支持查看实例详情
4. 支持启用/禁用实例

#### 3.1.5 策略实例历史记录查看

**功能要求**：
1. 在实例详情页或实例列表中，提供"查看历史"按钮
2. 历史记录列表展示：
   - 版本号
   - 修改时间
   - 关键参数（初始资金、止盈比例、止损比例等）
   - 操作（查看详情）
3. 历史记录详情弹窗：
   - 展示完整的历史快照信息
   - 与当前实例信息对比显示

### 3.2 前端API调用

**统一使用 `common.js` 的 `request()` 函数**

**示例代码**：
```javascript
// 创建策略定义
function createStrategyDefinition(data) {
    return request({
        url: '/api/strategy/definition',
        method: 'POST',
        data: data
    });
}

// 查询策略列表
function getStrategyList(enabled) {
    return request({
        url: '/api/strategy/definition/list',
        method: 'GET',
        params: enabled ? { enabled: enabled } : {}
    });
}

// 查询策略详情
function getStrategyDetail(id) {
    return request({
        url: '/api/strategy/definition/' + id,
        method: 'GET'
    });
}

// 启用/禁用策略
function toggleStrategy(id, enabled) {
    return request({
        url: '/api/strategy/definition/' + id + '/toggle',
        method: 'PUT',
        data: { enabled: enabled }
    });
}

// 创建策略实例
function createStrategyInstance(data) {
    return request({
        url: '/api/strategy/instance',
        method: 'POST',
        data: data
    });
}

// 查询实例列表
function getInstanceList(strategyId) {
    return request({
        url: '/api/strategy/instance/list',
        method: 'GET',
        params: strategyId ? { strategyId: strategyId } : {}
    });
}

// 查询实例历史记录列表
function getInstanceHistory(instanceId) {
    return request({
        url: '/api/strategy/instance/' + instanceId + '/history',
        method: 'GET'
    });
}

// 查询历史记录详情
function getHistoryDetail(historyId) {
    return request({
        url: '/api/strategy/instance/history/' + historyId,
        method: 'GET'
    });
}
```

### 3.3 前端UI规范

**遵循 Layui 2.9.21 规范**：
- 使用 Layui table 组件展示列表
- 使用 Layui form 组件处理表单
- 使用 Layui layer 组件处理弹窗
- 使用 Layui switch 组件处理开关
- 统一错误提示和成功提示

---

## 四、数据库约束与索引

### 4.1 唯一约束

**strategy_definition 表**：
```sql
UNIQUE KEY `uk_userId_strategy_name` (`user_id`, `strategy_name`)
```

**strategy_instance 表**：
```sql
-- 建议添加唯一约束（如果SQL中未定义）
UNIQUE KEY `uk_user_strategy_pair_signal` (`user_id`, `strategy_id`, `trading_pair_id`, `signal_config_id`)
```

**注意**：
- `signal_config_id` 为 0 表示"无信号绑定"，用于唯一性约束
- 创建实例时，如果 `signal_config_id` 为 null 或不提供，自动设置为 0
- 查询时，`signal_config_id = 0` 的记录表示未绑定信号配置

### 4.2 索引建议

**strategy_definition 表**：
- `idx_user_id` (`user_id`) - 查询用户策略列表
- `idx_enabled` (`enabled`) - 筛选启用状态

**strategy_instance 表**：
- `idx_user_id` (`user_id`) - 查询用户实例列表
- `idx_strategy_id` (`strategy_id`) - 查询策略下的实例
- `idx_trading_pair_id` (`trading_pair_id`) - 查询交易对下的实例
- `idx_signal_config_id` (`signal_config_id`) - 查询信号配置下的实例（N2阶段使用）
- `idx_enabled` (`enabled`) - 筛选启用状态

**strategy_instance_history 表**：
- `idx_instance_id` (`strategy_instance_id`) - 查询实例的历史记录
- `idx_user_id` (`user_id`) - 查询用户的历史记录
- `idx_version` (`strategy_instance_id`, `version`) - 按版本号查询

---

## 五、验收标准（DoD - Definition of Done）

### 5.1 功能验收

#### 5.1.1 策略定义管理
- ✅ 创建策略定义：必填项校验通过，唯一性校验通过，数据正确入库
- ✅ 查询策略列表：能正确展示用户的所有策略，支持按状态筛选
- ✅ 查询策略详情：能正确展示策略信息和实例列表
- ✅ 更新策略定义：能正确更新，唯一性校验通过，权限校验通过
- ✅ 启用/禁用策略：状态正确切换，日志正确记录

#### 5.1.2 策略实例管理
- ✅ 创建策略实例：必填项校验通过，外键校验通过，唯一性校验通过，数据正确入库，`signal_config_id` 为 null 时自动设置为 0
- ✅ 查询实例列表：能正确展示策略下的所有实例
- ✅ 查询实例详情：能正确展示实例信息和关联的策略/交易对/信号配置
- ✅ 更新策略实例：能正确更新，参数校验通过，权限校验通过，**历史记录正确保存，版本号正确递增**
- ✅ 启用/禁用实例：状态正确切换，日志正确记录
- ✅ 查询历史记录：能正确展示实例的历史记录列表，按版本号倒序
- ✅ 查询历史详情：能正确展示历史记录的完整快照信息

### 5.2 数据校验验收

#### 5.2.1 唯一性校验
- ✅ 同一用户不能创建同名策略定义
- ✅ 同一用户、同一策略、同一交易对、同一信号配置不能创建重复实例
- ✅ 唯一性冲突时返回明确的错误信息

#### 5.2.2 外键校验
- ✅ 创建实例时，`strategyId` 必须存在且属于该用户
- ✅ 创建实例时，`tradingPairId` 必须存在
- ✅ 创建实例时，`signalConfigId` 如果提供，必须存在且属于该用户
- ✅ 外键不存在时返回明确的错误信息

#### 5.2.3 参数校验
- ✅ `strategyType`、`strategyPattern` 必须是枚举值
- ✅ `initialCapital > 0`
- ✅ `takeProfitRatio`、`stopLossRatio` 在 0-1 之间
- ✅ `strategySymbol` 与 `tradingPair.symbol` 一致，合约类型自动添加 `-SWAP` 后缀
- ✅ `signal_config_id` 为 null 时自动设置为 0
- ✅ 参数校验失败时返回明确的错误信息

### 5.3 权限验收

- ✅ 用户只能查询/操作自己的策略定义和实例
- ✅ 越权操作返回明确的错误信息（404 或 403）
- ✅ 所有操作日志包含 `userId`、`strategyId`、`strategyInstanceId`

### 5.4 前端验收

- ✅ 所有页面能正常加载和交互
- ✅ 表单校验正确（前端 + 后端双重校验）
- ✅ 错误提示友好明确
- ✅ 操作成功后正确刷新数据
- ✅ 响应式布局正常（主要屏幕尺寸）
- ✅ 历史记录列表能正确展示，按版本号倒序
- ✅ 历史记录详情弹窗能正确展示完整快照
- ✅ `signal_config_id = 0` 时正确显示"未绑定"或"-"

### 5.5 接口验收

- ✅ 所有接口返回统一格式 `Result<T>`
- ✅ 成功响应码为 200
- ✅ 错误响应码和错误信息明确
- ✅ 请求头 `X-User-Id` 正确传递
- ✅ 接口文档完整（或代码注释清晰）

---

## 六、开发注意事项

### 6.1 关键约束（必须遵守）

1. **唯一性约束**：
   - 策略定义：`unique(user_id, strategy_name)`
   - 策略实例：`unique(user_id, strategy_id, trading_pair_id, signal_config_id)`
   - **注意**：`signal_config_id` 为 NULL 时的唯一性处理

2. **权限隔离**：
   - 所有查询/操作必须基于 `userId` 过滤
   - 不能跨用户操作数据

3. **日志记录**：
   - 关键操作（创建/更新/启停）必须记录日志
   - 日志必须包含：`userId`、`strategyId`、`strategyInstanceId`

4. **时间语义**：
   - 所有时间字段使用 `LocalDateTime`
   - 使用 MyBatis-Plus 自动填充

### 6.2 技术实现注意

1. **JSON 字段处理**：
   - `runtimeRules` 使用 `JacksonTypeHandler` 处理
   - 存储时序列化，查询时反序列化

2. **BigDecimal 精度**：
   - 使用 `BigDecimal` 处理金额和比例
   - 避免使用 `double` 或 `float`

3. **枚举值校验**：
   - 建议定义常量类或枚举类
   - 在 Service 层进行校验

4. **版本管理实现**：
   - 更新实例时，先保存历史记录，再更新实例（同一事务）
   - 版本号自增逻辑：`newVersion = currentVersion + 1`
   - 历史记录保存时，使用当前版本号（保存历史时的版本）

5. **交易对符号生成**：
   - 创建/更新实例时，根据 `trading_pair.market_type` 自动生成 `strategy_symbol`
   - 合约类型（SWAP/FUTURES）且符号无 `-SWAP` 后缀时，自动添加
   - 现货类型（SPOT）直接使用原符号

6. **signal_config_id 处理**：
   - 创建实例时，如果 `signal_config_id` 为 null 或不提供，设置为 0
   - 查询时，`signal_config_id = 0` 表示未绑定信号配置
   - 前端显示时，0 显示为"未绑定"或"-"

7. **异常处理**：
   - 使用 `BusinessException` 抛出业务异常
   - 全局异常处理器统一处理

### 6.3 前端实现注意

1. **请求头传递**：
   - 使用 `common.js` 的 `getUserHeader()` 获取请求头
   - 确保所有请求都包含 `X-User-Id`

2. **表单校验**：
   - 前端使用 Layui form 校验
   - 后端使用 `@Valid` 注解校验
   - 双重校验确保数据安全

3. **错误处理**：
   - 统一使用 `layer.msg()` 提示错误
   - 错误信息从后端 `Result.message` 获取

4. **数据刷新**：
   - 创建/更新/删除成功后刷新列表
   - 使用 `table.reload()` 刷新表格

---

## 七、接口清单汇总

### 7.1 策略定义接口

| 方法 | 路径 | 请求体 | 响应 | 说明 |
|------|------|--------|------|------|
| POST | `/api/strategy/definition` | `StrategyDefinitionCreateRequest` | `Result<StrategyDefinitionVO>` | 创建策略定义 |
| PUT | `/api/strategy/definition/{id}` | `StrategyDefinitionUpdateRequest` | `Result<StrategyDefinitionVO>` | 更新策略定义 |
| GET | `/api/strategy/definition/{id}` | - | `Result<StrategyDefinitionDetailVO>` | 查询策略详情 |
| GET | `/api/strategy/definition/list` | `?enabled=1` | `Result<List<StrategyDefinitionVO>>` | 查询策略列表 |
| PUT | `/api/strategy/definition/{id}/toggle` | `{enabled: 1}` | `Result<StrategyDefinitionVO>` | 启用/禁用策略 |

### 7.2 策略实例接口

| 方法 | 路径 | 请求体 | 响应 | 说明 |
|------|------|--------|------|------|
| POST | `/api/strategy/instance` | `StrategyInstanceCreateRequest` | `Result<StrategyInstanceVO>` | 创建策略实例 |
| PUT | `/api/strategy/instance/{id}` | `StrategyInstanceUpdateRequest` | `Result<StrategyInstanceVO>` | 更新策略实例 |
| GET | `/api/strategy/instance/{id}` | - | `Result<StrategyInstanceDetailVO>` | 查询实例详情 |
| GET | `/api/strategy/instance/list` | `?strategyId=1` | `Result<List<StrategyInstanceVO>>` | 查询实例列表 |
| PUT | `/api/strategy/instance/{id}/toggle` | `{enabled: 1}` | `Result<StrategyInstanceVO>` | 启用/禁用实例 |

---

## 八、开发顺序建议

### 8.1 后端开发顺序

1. **Entity 层**：创建 `StrategyDefinition` 和 `StrategyInstance` Entity
2. **Mapper 层**：创建 Mapper 接口和 XML
3. **DTO 层**：创建请求和响应 DTO
4. **Service 层**：实现业务逻辑和校验
5. **Controller 层**：实现接口和参数校验

### 8.2 前端开发顺序

1. **API 封装**：在 `common.js` 或新建 `strategy.js` 封装接口调用
2. **列表页**：先实现策略定义列表页
3. **详情页**：实现策略定义详情页（含实例列表）
4. **创建/编辑**：实现创建和编辑弹窗
5. **实例管理**：实现实例的创建/编辑/启停

### 8.3 测试顺序

1. **单元测试**：Service 层业务逻辑测试
2. **接口测试**：使用 Postman 或类似工具测试所有接口
3. **集成测试**：前后端联调测试
4. **验收测试**：按照 DoD 逐项验收

---

## 九、后续节点依赖

### 9.1 N2 阶段依赖

- ✅ `strategy_instance` 表必须存在且可查询
- ✅ `strategy_instance.enabled` 字段用于路由过滤
- ✅ `strategy_instance.trading_pair_id` 用于 K 线事件路由
- ✅ `strategy_instance.signal_config_id` 用于信号事件路由

### 9.2 关键字段说明

- **`strategy_instance_id`**：N2 及后续所有节点都以 `strategy_instance_id` 为核心路由键
- **`enabled`**：只有启用的实例才会接收事件和处理
- **`runtime_rules`**：N4 阶段使用，N1 阶段可为空

---

## 十、常见问题与解决方案

### 10.1 唯一性约束问题

**问题**：`signal_config_id` 为 NULL 时，MySQL 唯一约束如何处理？

**解决方案（已确定）**：
- **使用 0 表示"无信号绑定"**：创建实例时，如果 `signal_config_id` 为 null 或不提供，自动设置为 0
- 唯一约束：`unique(user_id, strategy_id, trading_pair_id, signal_config_id)`
- 业务逻辑：
  - `signal_config_id = 0` 表示未绑定信号配置
  - `signal_config_id > 0` 表示绑定了具体的信号配置
  - 查询时，需要区分 0 和 null（0 是有效值，null 不应该出现）
- 前端显示：`signal_config_id = 0` 时，显示"未绑定"或"-"

### 10.2 交易对符号一致性

**问题**：`strategy_instance.strategy_symbol` 与 `trading_pair.symbol` 如何保持一致？合约类型的交易对是否需要特殊处理？

**解决方案**：
- **自动生成策略符号**：创建/更新实例时，从 `trading_pair` 表查询 `symbol` 和 `market_type`
- **合约类型处理**：
  - 如果 `market_type = 'SWAP'` 或 `market_type = 'FUTURES'`
  - 且 `symbol` 后缀不包含 `-SWAP`
  - 则自动添加 `-SWAP` 后缀到 `strategy_symbol`
  - 例如：`trading_pair.symbol = 'BTC-USDT'` 且 `market_type = 'SWAP'`，则 `strategy_symbol = 'BTC-USDT-SWAP'`
- **现货类型处理**：
  - 如果 `market_type = 'SPOT'`，直接使用 `trading_pair.symbol`
- **不允许用户手动输入**：`strategy_symbol` 字段由系统自动生成，前端不提供输入框
- **校验规则**：更新实例时，如果 `trading_pair_id` 改变，重新生成 `strategy_symbol`

### 10.3 版本号管理

**问题**：`strategy_instance.version` 字段如何使用？如何实现实例的版本管理和历史记录？

**解决方案（已实现）**：

#### 10.3.1 版本号规则
- **初始版本**：创建实例时，`version = 1`
- **版本递增**：每次更新实例时，版本号自增（当前版本 + 1）
- **版本号作用**：标识实例的修改次数，用于历史记录追踪

#### 10.3.2 历史记录保存机制
- **触发时机**：更新实例（`update` 方法）时
- **保存步骤**：
  1. 查询当前实例的完整数据
  2. 将当前数据保存到 `strategy_instance_history` 表
  3. 设置 `strategy_instance_id` 为当前实例ID
  4. 设置 `version` 为当前实例的版本号（保存历史时的版本）
  5. 更新实例数据，版本号自增
- **历史记录字段**：保存实例的所有字段快照（包括 `runtime_rules`、`initial_capital`、`take_profit_ratio`、`stop_loss_ratio` 等）

#### 10.3.3 历史记录查询
- **查询接口**：
  - `GET /api/strategy/instance/{id}/history` - 查询实例的所有历史记录（按版本号倒序）
  - `GET /api/strategy/instance/history/{historyId}` - 查询单条历史记录详情
- **前端展示**：
  - 在实例详情页提供"查看历史"按钮
  - 历史记录列表展示：版本号、修改时间、关键参数对比
  - 历史记录详情弹窗展示完整的历史快照

#### 10.3.4 实现要点
- **事务处理**：保存历史记录和更新实例必须在同一事务中
- **性能考虑**：历史记录表需要建立索引（`idx_instance_id`、`idx_version`）
- **数据完整性**：历史记录一旦保存，不允许修改（只读）
- **版本号唯一性**：同一实例的版本号必须唯一且递增

---

---

## 十一、版本管理与历史记录实现细节

### 11.1 更新实例时的历史记录保存流程

```java
@Transactional
public StrategyInstance update(Long id, StrategyInstanceUpdateRequest request, Long userId) {
    // 1. 查询当前实例
    StrategyInstance current = getById(id);
    if (current == null) {
        throw new BusinessException(404, "实例不存在");
    }
    
    // 2. 权限校验
    if (!current.getUserId().equals(userId)) {
        throw new BusinessException(403, "无权限操作");
    }
    
    // 3. 保存历史记录（当前版本快照）
    StrategyInstanceHistory history = new StrategyInstanceHistory();
    BeanUtils.copyProperties(current, history);
    history.setId(null); // 新记录
    history.setStrategyInstanceId(current.getId());
    history.setVersion(current.getVersion()); // 保存当前版本号
    history.setCreatedAt(LocalDateTime.now());
    history.setUpdatedAt(LocalDateTime.now());
    strategyInstanceHistoryMapper.insert(history);
    
    // 4. 更新实例数据
    // ... 更新逻辑 ...
    current.setVersion(current.getVersion() + 1); // 版本号自增
    updateById(current);
    
    return current;
}
```

### 11.2 交易对符号生成工具方法

```java
/**
 * 根据交易对信息生成策略符号
 * @param tradingPair 交易对信息
 * @return 策略符号
 */
private String generateStrategySymbol(TradingPair tradingPair) {
    String symbol = tradingPair.getSymbol();
    String marketType = tradingPair.getMarketType();
    
    // 合约类型且无-SWAP后缀，自动添加
    if (("SWAP".equals(marketType) || "FUTURES".equals(marketType)) 
        && !symbol.endsWith("-SWAP")) {
        return symbol + "-SWAP";
    }
    
    // 现货类型直接返回
    return symbol;
}
```

### 11.3 signal_config_id 处理工具方法

```java
/**
 * 处理 signal_config_id，null 转换为 0
 * @param signalConfigId 原始值
 * @return 处理后的值（0 表示无信号绑定）
 */
private Long normalizeSignalConfigId(Long signalConfigId) {
    return signalConfigId == null ? 0L : signalConfigId;
}
```

---

**文档版本**：v1.1  
**最后更新**：2026-01-12  
**维护者**：开发团队  
**更新内容**：
- 增加版本管理和历史记录功能
- 明确 signal_config_id = 0 表示无信号绑定
- 增加合约交易对 -SWAP 后缀自动处理
- 增加历史记录查询接口和前端展示