行，我重来一版——**更硬、更可落地、更像“工业级研发计划书”**，并且把你那 8 点思路升级成：**主链路闭环优先、每个节点都有明确输入/输出/边界/验收、能让 Cursor 直接拆任务开干**。

下面这份你可以直接当“研发任务基线文档”。

---

# V2-Trade 策略系统重构 · 节点化研发计划（最强大脑版）

> **核心裁决（全程遵守）**

1. **闭环优先**：每个节点交付必须能“跑起来并可验证”，不是写一堆类
2. **先主链路后完善**：先把策略/指标/风控跑通，再做兼容/安全/细节
3. **事件驱动 + 状态可恢复**：同一实例串行、幂等、可重启恢复
4. **只写 Action，不写 HOLD**：决策记录只落真正动作意图，否则必爆库
5. **规则先 MVP，再深研 DSL**：先能配置+计算+解释，再追求表达力

---

## 0. 统一名词与边界（这决定不会返工）

### 0.1 三层结构（必须固定）

* **Definition（策略定义）**：策略模板/类型/模式，不运行
* **Instance（策略实例）**：真正运行体，一个策略可以多个实例（不同 pair / 不同信号绑定 / 不同资金参数）
* **Runtime（运行时）**：内存对象，持有状态机、缓存视图、串行队列

### 0.2 三条流水（必须固定）

* **Input Facts（输入事实）**：K线闭合、价格、外部信号（只记录/只接收）
* **Rule Evaluation（规则结算）**：算“条件是否命中”，写 rules_record（可解释）
* **Decision Intent（决策意图）**：只写 OPEN/CLOSE/ADD/REDUCE/REVERSE（可执行）

### 0.3 两个“永恒真理”

* **同一 strategy_instance 的事件处理必须串行**
* **事件可重复到达，系统必须幂等**

---

# 节点总览（从“能跑”到“可长期演进”）

我把你的 1~8 重排成 **N1~N8**，每个节点都给：目标、输入、输出、任务、验收、注意事项。

> 你原来的顺序最大的问题：把“规则定义（最不确定）”放到太靠前，会导致状态机/事件层返工。
> 新顺序保证：**先把运行底座做扎实，再把规则大脑接进去。**

---

## N1：策略定义 + 策略实例 管理闭环（UI/API 可用）

### 目标

用户在 Web 上完成：

* 创建策略 definition
* 创建策略 instance（绑定交易对、绑定信号、初始资金、TP/SL）
* 查看详情（definition + instances 列表）

### 输入

* trading_pair 已存在
* signal_config 可选绑定

### 输出

* DB 有 definition、instance，可查询
* Web 可操作

### 后端任务

1. StrategyDefinition CRUD（含 enabled）
2. StrategyInstance CRUD（含 enabled）
3. 校验（必须）

   * 策略名唯一建议：`unique(user_id, strategy_name)`
   * 实例唯一建议：`unique(user_id, strategy_id, trading_pair_id, signal_config_id)`（允许同策略同交易对不同信号=不同实例）
4. DTO：definition详情带 instances 列表

### 前端任务

* 策略列表、创建页、详情页
* 实例创建弹窗/页面 + 实例列表

### 验收（DoD）

* 创建/查询/启停全通
* 任何越权/非法输入都有明确错误
* 日志包含 userId/strategyId/instanceId

### 必须注意（Cursor）

* **从今天开始：所有后续模块以 strategy_instance_id 为核心路由键**（不再用 strategy_id+pair 乱猜）

---

## N2：前置层事件接入（先打印，但要求“正确路由+幂等+可压测”）

> 你说“输出到控制台打印”，我同意，但必须是生产级“正确打印”：路由、时间、去重都要对。

### 目标

接入并打印三类事件，且能定位到受影响的 instance：

1. 聚合 K 线闭合事件（BarClosedEvent）
2. 价格事件（PriceTick / LatestPrice）
3. 外部信号事件（SignalReceived）

### 输入

* N1 已完成，instance 可查

### 输出

* 控制台打印：`event -> instanceIds -> print`
* 事件进入系统不阻塞行情线程

### 后端任务（硬要求）

1. 定义统一事件封装 `StrategyTrigger`

   * triggerType: BAR_CLOSE / PRICE / SIGNAL
   * eventKey（幂等键）
   * asOfTime（UTC）
2. EventRouter（核心）

   * BAR_CLOSE：pair + timeframe -> 找启用实例（按 pair 绑定）
   * PRICE：pair -> 找启用实例
   * SIGNAL：signal_config_id -> 找绑定该 signal 的实例
3. Dedup（至少内存 TTL 去重）

   * 同一个 eventKey 30s 内只处理一次
4. 打印格式必须统一（可用于 grep 排错）

   * `triggerType, eventKey, asOfTime, pair, instanceId, userId`

### 验收（DoD）

* 三类事件都能稳定打印
* 重复事件不刷屏（去重生效）
* 压测下不阻塞行情/聚合线程（异步消费）

### 必须注意（Cursor）

* **UTC 时间语义**：barCloseTime 必须是 close，不要混 open
* **异步**：不要在 WebSocket/聚合线程里做 DB 查找

---

## N3：策略运行时容器 + 状态机恢复（“重启不失忆”）

### 目标

项目启动时：

* 加载所有 enabled 的 strategy_instance
* 创建运行时 runtime（内存）
* 从 DB 恢复 strategy_logic_state（没有则初始化）
* N2 的事件能驱动 runtime “进入处理流程”（先不决策）

### 输入

* N1 + N2 已完成

### 输出

* runtime 常驻
* 状态机可查可恢复
* Web 可查看所有实例当前 state

### 后端任务

1. StrategyRuntimeManager

   * bootstrap load instances
   * per instance 建立：串行队列/执行器 + 状态机对象 + 缓存视图（latest price/latest bar/latest signal）
2. StateMachine（必须是显式状态迁移表）

   * phase/side/qty/avgEntry
   * 提供外部可调用方法：`onBarClose/onPrice/onSignal`
3. 状态持久化规范（必须）

   * 每次状态变化才写 DB（不要每个事件都写）
   * `strategy_logic_state` 必须唯一一条“当前态”
4. Web API

   * 实例状态列表、详情

### 前端任务

* 实例状态监控页面（列表 + 详情）
* 详情页展示：phase/side/qty/avg/lastEventTime

### 验收（DoD）

* 重启后状态一致（能恢复到正确 phase/持仓方向）
* 同一 instance 事件串行（日志可证明）
* Web 可实时查看状态

### 必须注意（Cursor）

* **串行执行是生命线**：用 StripedExecutor 或 per-instance queue
* **状态写库要节流**：只在 phase/position 变化时写

---

## N4：策略大脑运行规则（MVP）= “可配置 + 可校验 + 可解释”

> 你说 runtime_rules 先不做深研，我赞同。但必须先做 MVP 版，否则后面 N5~N7 没法落地。

### 目标


* 入场：信号触发 / 指标触发（二选一或 AND）
* 出场：止盈止损（基于价格）
* 仓位：固定比例下单（base_order_ratio）

### 输入

* N1~N3 已完成（有实例、有状态机、有事件）

### 输出

* 用户能在 Web 配规则并保存到 instance.runtime_rules
* 后端能解析为 RuleModel（Java 对象）
* 保存前校验错误能定位路径

### 任务拆解

1. 定义 runtime_rules JSON 结构（冻结 v0）
2. 后端：RuleValidator（字段合法、操作符合法、参数范围）
3. 前端：规则配置 UI（表单化）
4. 后端：RuleParser -> RuleModel

### 验收（DoD）

* 可保存、可读取、可校验、可预览
* 后端能把 JSON 转成 RuleModel 并单测覆盖

### 必须注意（Cursor）

* **先不要搞脚本语言**（Groovy/Lua/JS）——那会把安全/沙箱/调试拖爆
* MVP 结构化 DSL 才能快速闭环、可回测

---

## N5：规则结算引擎

### 目标

事件驱动状态机后，触发一次规则结算：
* 如果有指标要调用指标模块
* 得到结算结果：是否命中、命中原因、快照摘要
* 写入 `strategy_rules_record`

### 输入

* N4 有 RuleModel
* N3 runtime 有快照（latest price/bar/signal/indicator）

### 输出

* rules_record 有可追踪的结算记录
* Web 可查看最近结算结果（用于验证规则配置正确）

### 后端任务

1. DecisionContextBuilder（快照采样）

   * stateSnapshot + ruleSnapshot + triggerSnapshot + marketSnapshot
2. RuleEngine（纯函数）

   * `evaluate(ctx) -> RuleEvalResult`
3. 写库 rules_record（可控频率）

   * 只在“触发源有效”或“规则命中/接近命中”时写（避免爆）

### 验收（DoD）

* 配好规则后，来事件能看到结算记录
* 结算记录包含：触发类型、命中条件、关键值（价格/指标/信号）
* 单测覆盖典型场景：入场命中、止损命中、未命中

### 必须注意（Cursor）

* **rules_record 是 debug/audit 表，不是每秒流水表**：必须节流（例如每根 bar 最多一条）

---

## N6：决策意图生成（写 strategy_intent_record）= “只写真正动作”

### 目标

当规则结算命中且符合状态机允许动作时：

* 写入 `strategy_intent_record`
* 状态机进入 pending（OPEN_PENDING/EXIT_PENDING/ADD_PENDING）
* Web 可查看决策记录列表

### 输入

* N5 RuleEvalResult
* N3 StateMachine phase

### 输出

* intent_record 只出现真实动作
* 不写 HOLD

### 后端任务（必须硬）

1. IntentPolicy（动作生成规则）

   * FLAT + entryHit -> OPEN
   * OPENED + tp/slHit -> CLOSE
   * 其他 -> HOLD（不写库）
2. IntentDedup（幂等）

   * 同一 triggerKey 不得重复写 intent
   * **建议：DB 唯一约束兜底 + Redis/内存 dedup**
3. 状态推进

   * OPEN -> OPEN_PENDING
   * CLOSE -> EXIT_PENDING

### 验收（DoD）

* 同一事件重复到达不会写多条 intent
* HOLD 不落库
* intent 与 phase 推进一致（能对账）

### 必须注意（Cursor）

* 你问“intent 怎么会写爆？”——就靠两件事防爆：
  **(1) HOLD 不写** + **(2) 幂等去重**
* PRICE 触发必须 cooldown，否则止损价附近会抖动连发

---

## N7：执行回执联动（先 stub）= “闭环跑通”

### 目标

先不做真实下单，做 stub 执行器：

* 消费 intent_record
* 模拟“执行成功/失败回执”
* 推进 strategy_logic_state
* 让全链路闭环跑起来

### 输入

* N6 有 intent_record & pending phase

### 输出

* OPEN_PENDING -> OPENED
* EXIT_PENDING -> IDLE（或 CLOSED->IDLE）

### 后端任务

1. IntentExecutorStub（异步消费）
2. ExecutionResultEvent（SUCCESS/FAIL）
3. StateMachine.applyExecutionResult()
4. Web：显示执行结果（先在日志/状态字段展示即可）

### 验收（DoD）

* 从事件 → 结算 → 意图 → 执行stub → 状态更新，全链路跑通
* 重启后 pending 状态可恢复并继续执行（或标记为待处理）

---

## N8：生命周期自维护（策略“长期运行不出错”的关键）

> 你说“平仓后初始化新状态机”，这里升级为“周期化运行机制”。

### 目标

策略实例可长期运行：

* 平仓后回到 IDLE，进入下一轮
* 清理过期触发（过期信号、冷却窗口、过旧指标）
* 防止内存无限增长（事件 ring buffer、缓存上限）

### 后端任务

1. CycleResetPolicy

   * EXIT 成功后：state->IDLE，清理 transient 缓存
2. StaleDataPolicy

   * 信号超过 N 分钟视为无效
   * 指标超过 N 根 bar 视为无效
3. RuntimeGuard

   * 每个 instance 的内存上限（ring buffer 200~1000 条）

### 验收（DoD）

* 长时间跑（模拟 24h 事件）不爆内存、不爆库
* 平仓后能再次入场（循环成立）

---

# 关键“研发铁律”（你要让 Cursor 一开始就写进骨架里）

这部分我建议你直接贴到 Cursor 的指令里，避免它写歪。

1. **串行**：同一 strategy_instance 永远串行处理
2. **幂等**：每类触发都有 eventKey；intent 必须 dedup
3. **HOLD 不落库**：只记 metrics/log（必要时写 rules_record 但要节流）
4. **快照一致性**：一次结算/决策必须基于同一个 DecisionContext
5. **时间语义**：全部 UTC；barCloseTime 才能触发规则结算
6. **写库节流**：rules_record 是解释表，不是行情流水

---

# 你要的「Cursor 指令」（这版更强，直接拆任务+产出代码骨架）

你复制下面这段给 Cursor 就行：

> **Cursor 指令（强约束版）**
> 你是顶级 Java/SpringBoot 架构师，请基于我已重构的策略模型（一个策略多个实例），按 N1~N8 输出“可直接执行的研发任务书”。
> 必须输出：
>
> 1. 每个节点的：目标、输入、输出、后端任务、前端任务、接口清单、数据校验规则、验收标准（Given/When/Then）
> 2. 给出核心包结构与关键类骨架代码（router/runtime/stateMachine/context/ruleEngine/intentEngine/executorStub）
> 3. 强制约束：同一 strategy_instance 串行；事件幂等；HOLD 不落库；UTC 语义；rules_record 节流；intent 必须 dedup（最好 DB 唯一 + 缓存去重双保险）
> 4. N2 先做到控制台打印，但必须正确路由到 instance；N3 必须重启恢复；N4 runtime_rules 做 MVP 结构化 DSL（禁止上脚本语言）；N6 只写动作意图；N7 用执行 stub 跑通闭环；N8 做长期运行自维护。
>    不要引入新表（允许加索引/唯一约束），不要把功能做成定时轮询，全部事件驱动。

---

# 最后一句：你原思路里最需要“升级”的点

你原来的 6/7/8 其实少了一个“解释层”（rules_record 的定位）。
我这版把它明确为 **“规则结算记录 = 可解释层”**，这会极大降低你后续研究 runtime_rules 时的返工成本，也能让前端验证闭环更轻松。
