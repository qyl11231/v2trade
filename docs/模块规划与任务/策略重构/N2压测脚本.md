# N2 事件系统压测脚本

## 前置条件

1. **启用测试接口**：在 `application.yml` 中设置：
   ```yaml
   strategy:
     trigger:
       test-endpoint:
         enabled: true
   ```

2. **准备数据**：
   - 确保有启用的 `strategy_instance` 记录
   - 确保有对应的 `trading_pair` 记录
   - 确保有对应的 `signal_config` 记录（用于信号测试）

## 测试接口说明

### 基础接口

#### 1. 测试 K 线闭合事件（单个）

```bash
curl -X POST "http://localhost:8080/api/strategy/trigger/test/bar-close?tradingPairId=1&timeframe=5m"
```

**参数说明**：
- `tradingPairId`：交易对ID（必填）
- `timeframe`：时间周期，如 "1m", "5m", "15m", "1h"（必填）
- `barCloseTimeMillis`：K线闭合时间戳（毫秒，可选，默认当前时间）
- `strategySymbol`：策略交易对符号（可选）

#### 2. 测试信号事件（单个）

```bash
curl -X POST "http://localhost:8080/api/strategy/trigger/test/signal?signalConfigId=1&signalId=test-signal-001"
```

**参数说明**：
- `signalConfigId`：信号配置ID（必填）
- `signalId`：信号ID，必须唯一（必填）
- `price`：信号价格（可选）

### 批量压测接口

#### 1. 批量测试 K 线闭合事件

```bash
curl -X POST "http://localhost:8080/api/strategy/trigger/test/bar-close/batch?tradingPairId=1&timeframe=5m&count=100&intervalMs=50"
```

**参数说明**：
- `tradingPairId`：交易对ID（必填）
- `timeframe`：时间周期（必填）
- `count`：发送数量（默认10）
- `intervalMs`：发送间隔（毫秒，默认100ms）

#### 2. 批量测试信号事件

```bash
curl -X POST "http://localhost:8080/api/strategy/trigger/test/signal/batch?signalConfigId=1&count=50&intervalMs=100"
```

**参数说明**：
- `signalConfigId`：信号配置ID（必填）
- `count`：发送数量（默认10）
- `intervalMs`：发送间隔（毫秒，默认100ms）

## 压测脚本

### 1. K 线闭合事件压测（Bash）

```bash
#!/bin/bash

# 配置
BASE_URL="http://localhost:8080"
TRADING_PAIR_ID=1
TIMEFRAME="5m"
COUNT=100
INTERVAL_MS=50

echo "开始压测 K 线闭合事件..."
echo "交易对ID: $TRADING_PAIR_ID"
echo "时间周期: $TIMEFRAME"
echo "发送数量: $COUNT"
echo "发送间隔: ${INTERVAL_MS}ms"
echo ""

START_TIME=$(date +%s)

for i in $(seq 1 $COUNT); do
    BAR_CLOSE_TIME=$(($(date +%s%3N) + $i * $INTERVAL_MS))
    curl -s -X POST "${BASE_URL}/api/strategy/trigger/test/bar-close?tradingPairId=${TRADING_PAIR_ID}&timeframe=${TIMEFRAME}&barCloseTimeMillis=${BAR_CLOSE_TIME}" > /dev/null
    
    if [ $((i % 10)) -eq 0 ]; then
        echo "已发送: $i/$COUNT"
    fi
    
    if [ $INTERVAL_MS -gt 0 ] && [ $i -lt $COUNT ]; then
        sleep $(echo "scale=3; $INTERVAL_MS / 1000" | bc)
    fi
done

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

echo ""
echo "压测完成！"
echo "总耗时: ${DURATION}秒"
echo "平均速率: $(echo "scale=2; $COUNT / $DURATION" | bc) 事件/秒"
```

### 2. 信号事件压测（Bash）

```bash
#!/bin/bash

# 配置
BASE_URL="http://localhost:8080"
SIGNAL_CONFIG_ID=1
COUNT=50
INTERVAL_MS=100

echo "开始压测信号事件..."
echo "信号配置ID: $SIGNAL_CONFIG_ID"
echo "发送数量: $COUNT"
echo "发送间隔: ${INTERVAL_MS}ms"
echo ""

START_TIME=$(date +%s)

for i in $(seq 1 $COUNT); do
    SIGNAL_ID="test-signal-$(date +%s%3N)-${i}"
    curl -s -X POST "${BASE_URL}/api/strategy/trigger/test/signal?signalConfigId=${SIGNAL_CONFIG_ID}&signalId=${SIGNAL_ID}" > /dev/null
    
    if [ $((i % 10)) -eq 0 ]; then
        echo "已发送: $i/$COUNT"
    fi
    
    if [ $INTERVAL_MS -gt 0 ] && [ $i -lt $COUNT ]; then
        sleep $(echo "scale=3; $INTERVAL_MS / 1000" | bc)
    fi
done

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

echo ""
echo "压测完成！"
echo "总耗时: ${DURATION}秒"
echo "平均速率: $(echo "scale=2; $COUNT / $DURATION" | bc) 事件/秒"
```

### 3. 并发压测脚本（使用 ab 或 wrk）

#### 使用 ab (Apache Bench)

```bash
# K 线闭合事件并发压测
ab -n 1000 -c 10 -p bar_close_post.txt -T application/x-www-form-urlencoded \
   "http://localhost:8080/api/strategy/trigger/test/bar-close?tradingPairId=1&timeframe=5m"

# 信号事件并发压测
ab -n 500 -c 5 -p signal_post.txt -T application/x-www-form-urlencoded \
   "http://localhost:8080/api/strategy/trigger/test/signal?signalConfigId=1&signalId=test-001"
```

#### 使用 wrk

```bash
# K 线闭合事件压测
wrk -t4 -c100 -d30s -s bar_close_script.lua http://localhost:8080/api/strategy/trigger/test/bar-close

# 信号事件压测
wrk -t4 -c100 -d30s -s signal_script.lua http://localhost:8080/api/strategy/trigger/test/signal
```

### 4. Python 压测脚本

```python
#!/usr/bin/env python3
import requests
import time
import threading
from concurrent.futures import ThreadPoolExecutor

BASE_URL = "http://localhost:8080"

def test_bar_close(trading_pair_id, timeframe, bar_close_time_ms):
    """测试单个 K 线闭合事件"""
    url = f"{BASE_URL}/api/strategy/trigger/test/bar-close"
    params = {
        "tradingPairId": trading_pair_id,
        "timeframe": timeframe,
        "barCloseTimeMillis": bar_close_time_ms
    }
    try:
        response = requests.post(url, params=params, timeout=5)
        return response.status_code == 200
    except Exception as e:
        print(f"请求失败: {e}")
        return False

def test_signal(signal_config_id, signal_id):
    """测试单个信号事件"""
    url = f"{BASE_URL}/api/strategy/trigger/test/signal"
    params = {
        "signalConfigId": signal_config_id,
        "signalId": signal_id
    }
    try:
        response = requests.post(url, params=params, timeout=5)
        return response.status_code == 200
    except Exception as e:
        print(f"请求失败: {e}")
        return False

def pressure_test_bar_close(trading_pair_id=1, timeframe="5m", count=100, concurrency=10):
    """K 线闭合事件压测"""
    print(f"开始压测 K 线闭合事件: count={count}, concurrency={concurrency}")
    start_time = time.time()
    
    def worker(i):
        bar_close_time = int(time.time() * 1000) + i * 100
        return test_bar_close(trading_pair_id, timeframe, bar_close_time)
    
    with ThreadPoolExecutor(max_workers=concurrency) as executor:
        results = list(executor.map(worker, range(count)))
    
    end_time = time.time()
    duration = end_time - start_time
    success_count = sum(results)
    
    print(f"压测完成！")
    print(f"总耗时: {duration:.2f}秒")
    print(f"成功: {success_count}/{count}")
    print(f"平均速率: {count/duration:.2f} 事件/秒")

def pressure_test_signal(signal_config_id=1, count=50, concurrency=5):
    """信号事件压测"""
    print(f"开始压测信号事件: count={count}, concurrency={concurrency}")
    start_time = time.time()
    
    def worker(i):
        signal_id = f"test-signal-{int(time.time() * 1000)}-{i}"
        return test_signal(signal_config_id, signal_id)
    
    with ThreadPoolExecutor(max_workers=concurrency) as executor:
        results = list(executor.map(worker, range(count)))
    
    end_time = time.time()
    duration = end_time - start_time
    success_count = sum(results)
    
    print(f"压测完成！")
    print(f"总耗时: {duration:.2f}秒")
    print(f"成功: {success_count}/{count}")
    print(f"平均速率: {count/duration:.2f} 事件/秒")

if __name__ == "__main__":
    # K 线闭合事件压测
    pressure_test_bar_close(trading_pair_id=1, timeframe="5m", count=100, concurrency=10)
    
    print("\n" + "="*50 + "\n")
    
    # 信号事件压测
    pressure_test_signal(signal_config_id=1, count=50, concurrency=5)
```

## 验证方法

### 1. 查看日志

```bash
# 查看策略触发器日志（过滤掉 PRICE 事件）
grep "STRATEGY_TRIGGER" logs/application.log | grep "route_print"

# 查看 BAR_CLOSE 事件
grep "STRATEGY_TRIGGER" logs/application.log | grep "BAR_CLOSE"

# 查看 SIGNAL 事件
grep "STRATEGY_TRIGGER" logs/application.log | grep "SIGNAL"
```

### 2. 验证去重效果

发送相同的 eventKey 多次，应该只打印一次：

```bash
# 发送相同的 K 线闭合事件（相同 tradingPairId + timeframe + barCloseTime）
curl -X POST "http://localhost:8080/api/strategy/trigger/test/bar-close?tradingPairId=1&timeframe=5m&barCloseTimeMillis=1730000000000"
curl -X POST "http://localhost:8080/api/strategy/trigger/test/bar-close?tradingPairId=1&timeframe=5m&barCloseTimeMillis=1730000000000"
curl -X POST "http://localhost:8080/api/strategy/trigger/test/bar-close?tradingPairId=1&timeframe=5m&barCloseTimeMillis=1730000000000"

# 查看日志，应该只有一条 route_print 日志
```

### 3. 验证路由正确性

确保事件能正确路由到对应的 strategy_instance：

```bash
# 查看路由日志，确认 instanceId 和 userId 都有值
grep "STRATEGY_TRIGGER" logs/application.log | grep "route_print" | jq .
```

## 压测建议

1. **K 线闭合事件**：
   - 建议速率：10-50 事件/秒
   - 持续时间：60 秒
   - 验证：系统稳定，不 OOM，不大量 Full GC

2. **信号事件**：
   - 建议速率：50 事件/秒
   - 持续时间：60 秒
   - 验证：重复事件能正确去重（只打印一次）

3. **混合压测**：
   - 同时发送 K 线闭合和信号事件
   - 验证：系统稳定，队列有背压策略

## 注意事项

1. **生产环境禁用**：确保 `strategy.trigger.test-endpoint.enabled=false`
2. **数据准备**：压测前确保有对应的 strategy_instance 记录
3. **监控指标**：压测时关注 CPU、内存、队列长度等指标
4. **日志级别**：压测时建议将日志级别调整为 INFO，避免 DEBUG 日志过多


