非常好，这个要求**本身就是“能不能上生产”的分水岭**。
我会 **完全尊重你已经冻结的表结构**，不再引入新表、不重命名、不推翻；只做**阶段二（Decision Phase）在现有架构下的“生产级重写设计”**。

下面这版不是“想法”，而是 **可交给工程师实现、可在生产跑、可长期维护的规范文本**。

---

# 阶段 2：策略决策阶段（Strategy Decision Phase）— 生产级重写设计

> **一句话定位**
>
> 阶段二是：
> **在策略实例“已存在且状态确定”的前提下，将外部刺激（信号 / 行情 / 指标）转化为“明确、可追溯、可回放的交易意图声明”。**

---

## 一、阶段二在整个系统中的架构位置

### 🔹 与阶段一的关系（必须先说清楚）

| 维度      | 阶段一                | 阶段二              |
| ------- | ------------------ | ---------------- |
| 系统状态    | **构建运行体**          | **驱动运行体产生认知结果**  |
| 是否修改状态  | ❌ 不修改              | ❌ 不修改            |
| 是否写 DB  | ✔️ logic_state 初始化 | ✔️ intent_record |
| 是否依赖行情  | ❌ 不依赖              | ✔️ 依赖            |
| 是否依赖信号  | ❌ 不消费              | ✔️ 只读最新          |
| 是否产生副作用 | ❌                  | ❌                |

> **核心原则：**
>
> 👉 阶段二是**纯决策层**
> 👉 不碰账户、不下单、不改状态
> 👉 所有副作用交给阶段三

---

## 二、阶段二的唯一职责（严格定义）

> **阶段二只做一件事：**
>
> > 对某个策略实例，在某一时刻，回答：
> >
> > **“我现在想做什么？”**

这个“想做什么”必须：

* 明确（OPEN / CLOSE / HOLD…）
* 可回放
* 不依赖未来状态
* 不因为重启而改变

👉 这正是 `strategy_intent_record` 的存在意义

---

## 三、阶段二的输入 / 输出边界（生产级）

### 🔹 输入（全部只读）

来自阶段一创建的内存结构：

```text
StrategyInstance
 ├── strategy_id
 ├── trading_pair_id
 ├── param (快照)
 ├── logic_state (快照)
 ├── signal_view (LATEST_ONLY)
 ├── market_view (最新行情)
```

⚠️ 输入数据必须满足：

* 都是**当前时刻可见**
* 都是**已初始化**
* 不需要额外 IO

---

### 🔹 输出（唯一）

```sql
INSERT INTO strategy_intent_record
```

**只写一次，不回滚，不覆盖**

---

## 四、阶段二的执行触发模型（非常关键）

### 阶段二不是“常驻循环”，而是**事件驱动**

#### 可触发阶段二的事件类型：

| 事件                 | 是否允许  |
|--------------------| ----- |
| 新 signal_intent 到达 | ✅     |
| 行情价格变化             | ✅     |
| 指标计算完成             | ✅     |
| 新K线到达              | ✅     |
| 定时器（例如每分钟）         | ❌（禁止） |

> **理由：**
>
> 定时扫描在生产环境一定会：
>
> * 重复决策
> * 状态错乱
> * 负载不可控

---

## 五、阶段二的决策流程（标准化、可实现）

以下流程 **必须对每一个 StrategyInstance 独立执行**。

---

### Step 1️⃣ 构建“决策上下文”（只读）

```text
DecisionContext
 ├── strategy_id
 ├── trading_pair_id
 ├── symbol #（如果是合约加后缀需要有-SWAP）
 ├── logic_state_snapshot
 ├── param_snapshot
 ├── signal_intent (nullable)
 ├── market_snapshot
 ├── indicators_snapshot
```

> **这是防止“隐式依赖”的关键步骤**

---

### Step 2️⃣ 判定是否允许进入决策

**三道硬性门禁：**

1. `logic_state.phase` 是否允许决策
2. 是否存在可见 signal / market trigger
3. 是否与上一次 intent 冲突（防抖）

👉 任一失败 → 直接产出 `HOLD`

---

### Step 3️⃣ 意图推导（纯函数）

```text
DecisionResult = f(DecisionContext)
```

输出只可能是：

* intent_action
* calculated_qty
* decision_reason

⚠️ **不允许写 DB、不允许修改状态**

---

### Step 4️⃣ 决策落库（唯一副作用）

```sql
INSERT INTO strategy_intent_record (...)
```

这一步必须：

* 原子
* 幂等（由上层保证）
* 永不更新历史记录

---

## 六、阶段二如何保证“生产环境可用”

### ✅ 1. 不会乱消费信号

* signal_view = **LATEST_ONLY**
* signal 是“当前意图”，不是“操作指令”
* 决策是策略主动行为

---

### ✅ 2. 不会重复开仓 / 平仓

* 阶段二不修改 `logic_state`
* 重复决策 ≠ 重复执行
* 真正的“只执行一次”在阶段三

---

### ✅ 3. 系统重启不影响一致性

* 所有决策结果都已落库
* 决策依据可复盘
* 内存丢失不影响历史

---

## 七、阶段二在代码层的优雅拆分（建议）

```text
decision/
 ├── DecisionEngine            # 决策入口
 ├── DecisionContextBuilder    # 上下文构建
 ├── GuardChain                # 决策门禁
 ├── IntentResolver            # 意图推导
 ├── IntentRecorder            # 落库
```

👉 每个类**只有一个职责**

---

## 八、阶段二明确“不做的事”（再次强调）

| 行为             | 原因         |
| -------------- | ---------- |
| 不写 logic_state | 状态只由执行确认   |
| 不发交易指令         | 执行属于下游     |
| 不判断账户余额        | 资金裁决在更下游   |
| 不处理失败重试        | 决策是声明，不是命令 |

---

## 九、最终评价（很重要）

> **在你当前冻结的表结构下：**
>
> * 阶段二的职责是**清晰、单一、可验证的**
> * 这套设计在真实生产环境中 **完全可用**
> * 并且具备长期演进空间（多信号、多指标、多触发源）

---

## 一句话总结（你可以写进系统文档）

> **阶段二不是“下单前的准备”，而是“策略认知的最终声明层”。**

