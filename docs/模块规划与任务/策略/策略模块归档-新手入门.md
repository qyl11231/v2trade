# 策略模块归档文档 - 新手入门指南

> **本文档面向新手开发者，系统梳理策略模块的表设计和阶段0、阶段1的核心内容**  
> **版本**：v1.0  
> **创建时间**：2024

---

## 📋 目录

1. [策略模块概述](#策略模块概述)
2. [数据库表设计](#数据库表设计)
3. [阶段0：策略规划原则](#阶段0策略规划原则)
4. [阶段1：策略实例化](#阶段1策略实例化)
5. [核心概念理解](#核心概念理解)
6. [常见问题解答](#常见问题解答)

---

## 一、策略模块概述

### 1.1 模块定位

**策略模块是什么？**

策略模块是一个**纯决策引擎**，负责：
- ✅ 基于信号和行情，生成"策略意图"（我想做什么）
- ✅ 管理策略的逻辑状态（我现在是什么状态）
- ✅ 计算下单数量（基于策略参数）

**策略模块不是什么？**

- ❌ 不是交易系统（不直接下单）
- ❌ 不关心账户余额
- ❌ 不感知交易所规则
- ❌ 不处理风控

### 1.2 系统架构位置

```
┌─────────────────┐
│  信号源 / 行情   │
└────────┬────────┘
         ↓
┌─────────────────┐
│   策略模块      │ ← 本文档讲解
│  (决策引擎)     │
└────────┬────────┘
         ↓
┌─────────────────┐
│ Capital Controller│
└────────┬────────┘
         ↓
┌─────────────────┐
│ Execution/Exchange│
└─────────────────┘
```

### 1.3 核心设计理念

1. **策略 ≠ 账户**：策略有独立的逻辑世界
2. **状态必须可恢复**：系统重启不失忆
3. **LATEST_ONLY 信号消费**：只关注最新信号
4. **防御性优先**：宁可拒绝，不要出错

---

## 二、数据库表设计

### 2.1 表结构总览

策略模块共涉及 **6个核心表**：

| 表名 | 用途 | 阶段 |
|------|------|------|
| `strategy_definition` | 策略定义（策略是什么） | 阶段0 |
| `strategy_param` | 策略参数（决策所需参数） | 阶段0 |
| `strategy_symbol` | 策略交易对绑定 | 阶段0 |
| `strategy_signal_subscription` | 策略信号订阅 | 阶段0 |
| `strategy_logic_state` | 策略逻辑状态（防止失忆） | 阶段1 |
| `strategy_intent_record` | 策略决策记录（我想做什么） | 阶段2 |
| `signal_intent` | 信号意图表（LATEST_ONLY模型） | 阶段2 |

### 2.2 表详细说明

#### 📊 表1：strategy_definition（策略定义表）

**作用**：描述"策略是什么"

**关键字段**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | BIGINT | 策略ID（主键） |
| `user_id` | BIGINT | 所属用户ID |
| `strategy_name` | VARCHAR(64) | 策略名称（唯一） |
| `strategy_type` | VARCHAR(32) | 策略类型：SIGNAL_DRIVEN / INDICATOR_DRIVEN / HYBRID |
| `decision_mode` | VARCHAR(64) | 决策模式：FOLLOW_SIGNAL / INTENT_DRIVEN |
| `enabled` | TINYINT | 是否启用：1-启用 0-禁用 |

**示例数据**：
```sql
INSERT INTO strategy_definition VALUES 
(1, 1001, '趋势跟随策略', 'SIGNAL_DRIVEN', 'FOLLOW_SIGNAL', 1);
```

**理解要点**：
- 一个策略定义可以绑定多个交易对
- `enabled=0` 时策略不会运行
- `decision_mode` 决定策略如何响应信号

---

#### 📊 表2：strategy_param（策略参数表）

**作用**：存储策略决策所需的全部参数

**关键字段**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | BIGINT | 参数ID（主键） |
| `strategy_id` | BIGINT | 策略ID（唯一，一个策略一套参数） |
| `initial_capital` | DECIMAL(20,8) | 策略初始虚拟资金 |
| `base_order_ratio` | DECIMAL(10,4) | 单次下单资金占比（如0.1表示10%） |
| `take_profit_ratio` | DECIMAL(10,4) | 止盈比例（如0.05表示5%） |
| `stop_loss_ratio` | DECIMAL(10,4) | 止损比例（如0.02表示2%） |
| `entry_condition` | JSON | 入场条件（结构化表达） |
| `exit_condition` | JSON | 退出条件（结构化表达） |

**entry_condition 示例**：
```json
{
  "mode": "ANY",
  "rules": [
    {"factor": "PRICE", "operator": "GT", "value": 65000},
    {"factor": "SIGNAL_DIRECTION", "operator": "EQ", "value": "LONG"}
  ]
}
```

**exit_condition 示例**：
```json
{
  "mode": "ANY",
  "rules": [
    {"type": "TAKE_PROFIT", "ratio": 0.05},
    {"type": "STOP_LOSS", "ratio": 0.02}
  ]
}
```

**理解要点**：
- 一个策略只有一套参数（1对1关系）
- `initial_capital` 是虚拟资金，用于计算下单数量
- 条件使用JSON存储，支持灵活扩展

---

#### 📊 表3：strategy_symbol（策略交易对表）

**作用**：记录策略在哪些交易对上运行

**关键字段**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | BIGINT | 主键 |
| `strategy_id` | BIGINT | 策略ID |
| `trading_pair_id` | BIGINT | 交易对ID |
| `enabled` | TINYINT | 是否启用：1-启用 0-禁用 |

**唯一约束**：`(strategy_id, trading_pair_id)` - 一个策略在一个交易对上只有一条记录

**理解要点**：
- **一个策略可以绑定多个交易对**
- **每个交易对都是独立的执行单元**
- `enabled=0` 时该交易对不会运行

**示例**：
```sql
-- 策略1在BTC-USDT和ETH-USDT上运行
INSERT INTO strategy_symbol VALUES (1, 1, 101, 1); -- BTC-USDT
INSERT INTO strategy_symbol VALUES (2, 1, 102, 1); -- ETH-USDT
```

---

#### 📊 表4：strategy_signal_subscription（策略信号订阅表）

**作用**：记录策略订阅了哪些信号配置

**关键字段**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | BIGINT | 订阅ID（主键） |
| `strategy_id` | BIGINT | 策略ID |
| `signal_config_id` | BIGINT | 信号配置ID |
| `consume_mode` | VARCHAR(32) | 消费模式：LATEST_ONLY |
| `enabled` | TINYINT | 是否启用：1-启用 0-禁用 |

**唯一约束**：`(strategy_id, signal_config_id)` - 一个策略对一个信号配置只有一条订阅

**理解要点**：
- 一个策略可以订阅多个信号配置
- `consume_mode=LATEST_ONLY` 表示只关注最新信号
- `enabled=0` 时该订阅不生效

---

#### 📊 表5：strategy_logic_state（策略逻辑状态表）⭐核心表

**作用**：**防止策略失忆**，记录策略在每个交易对上的当前状态

**关键字段**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | BIGINT | 状态ID（主键） |
| `strategy_id` | BIGINT | 策略ID |
| `trading_pair_id` | BIGINT | 交易对ID |
| `logic_position_side` | VARCHAR(16) | 逻辑持仓方向：LONG / SHORT / FLAT |
| `logic_position_qty` | DECIMAL(20,8) | 逻辑持仓数量 |
| `avg_entry_price` | DECIMAL(20,8) | 逻辑平均开仓价 |
| `state_phase` | VARCHAR(32) | 策略阶段：IDLE / OPEN_PENDING / OPENED / EXIT_PENDING / CLOSED |
| `last_signal_intent_id` | BIGINT | 最近一次关联的信号意图ID |
| `unrealized_pnl` | DECIMAL(20,8) | 未实现盈亏 |
| `realized_pnl` | DECIMAL(20,8) | 已实现盈亏 |

**唯一约束**：`(strategy_id, trading_pair_id)` - **一个策略在一个交易对上只有一条状态记录**

**状态阶段说明**：

| 阶段 | 说明 |
|------|------|
| `IDLE` | 空闲状态，无持仓 |
| `OPEN_PENDING` | 已决策待执行（等待开仓） |
| `OPENED` | 已开仓，有持仓 |
| `PARTIAL_EXIT` | 部分减仓 |
| `EXIT_PENDING` | 已决策待平仓 |
| `CLOSED` | 已平仓 |

**理解要点**（非常重要）：
- ⭐ **这是策略的"唯一事实源"** - 所有状态查询都从这里来
- ⭐ **系统重启后从这里恢复状态** - 防止失忆
- ⭐ **每个策略+交易对组合必须有且仅有一条记录**
- ⭐ **状态变更必须立即持久化** - 不能只存在内存中

**示例数据**：
```sql
-- 策略1在BTC-USDT上，当前持仓0.1 BTC，做多，已开仓
INSERT INTO strategy_logic_state VALUES (
  1, 1001, 1, 101,
  'LONG', 0.1, 65000.00,
  'OPENED', 123, 500.00, 0.00
);
```

---

#### 📊 表6：strategy_intent_record（策略决策记录表）

**作用**：记录"策略决定做什么"（阶段2使用）

**关键字段**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | BIGINT | 决策记录ID（主键） |
| `strategy_id` | BIGINT | 策略ID |
| `trading_pair_id` | BIGINT | 交易对ID |
| `signal_id` | BIGINT | 触发决策的信号ID |
| `intent_action` | VARCHAR(32) | 决策意图：OPEN / CLOSE / ADD / REDUCE / REVERSE / HOLD |
| `calculated_qty` | DECIMAL(20,8) | 策略计算出的下单数量 |
| `decision_reason` | VARCHAR(255) | 决策原因说明 |
| `created_at` | DATETIME | 决策时间 |

**决策意图说明**：

| 意图 | 说明 |
|------|------|
| `OPEN` | 开仓 |
| `CLOSE` | 平仓 |
| `ADD` | 加仓 |
| `REDUCE` | 减仓 |
| `REVERSE` | 反手 |
| `HOLD` | 不动作 |

**理解要点**：
- 这是**只写一次**的表 - 记录历史决策，不更新、不删除
- 每个决策都有完整的上下文（原因、数量、触发信号）
- 用于复盘和审计

---

#### 📊 表7：signal_intent（信号意图表）

**作用**：存储信号意图（LATEST_ONLY模型）

**关键字段**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | BIGINT | 意图ID（主键） |
| `strategy_id` | BIGINT | 策略ID |
| `trading_pair_id` | BIGINT | 交易对ID |
| `signal_id` | VARCHAR(128) | 信号唯一ID（如TradingView alert id） |
| `intent_direction` | VARCHAR(16) | 意图方向：BUY / SELL / FLAT / REVERSE |
| `intent_status` | VARCHAR(16) | 意图状态：ACTIVE / CONSUMED / EXPIRED / IGNORED |
| `generated_at` | DATETIME | 信号产生时间 |
| `received_at` | DATETIME | 系统接收时间 |

**意图状态说明**：

| 状态 | 说明 |
|------|------|
| `ACTIVE` | 当前有效意图（策略只读这个） |
| `CONSUMED` | 已被策略兑现 |
| `EXPIRED` | 被后续反向/新意图覆盖 |
| `IGNORED` | 被策略明确忽略 |

**理解要点**：
- **LATEST_ONLY模型**：策略只关注最新的 `ACTIVE` 信号
- 新信号到达会覆盖旧信号
- 策略只读，不修改信号状态（阶段2约束）

---

### 2.3 表关系图

```
strategy_definition (1)
    ├── strategy_param (1:1) - 一个策略一套参数
    ├── strategy_symbol (1:N) - 一个策略多个交易对
    ├── strategy_signal_subscription (1:N) - 一个策略多个信号订阅
    ├── strategy_logic_state (1:N) - 一个策略多个状态（按交易对）
    └── strategy_intent_record (1:N) - 一个策略多个决策记录

strategy_symbol (N)
    └── strategy_logic_state (1:1) - 一个交易对一个状态

signal_intent (N)
    └── strategy_intent_record (1:N) - 一个信号可能触发多个决策
```

---

## 三、阶段0：策略规划原则

### 3.1 阶段0是什么？

**阶段0 = 策略配置阶段**

在阶段0，我们定义：
- 策略是什么（strategy_definition）
- 策略需要什么参数（strategy_param）
- 策略在哪些交易对上运行（strategy_symbol）
- 策略订阅哪些信号（strategy_signal_subscription）

**阶段0的输出**：数据库中的静态配置

---

### 3.2 核心设计原则

#### 原则1：策略 ≠ 账户

```
策略有自己的"逻辑世界"
├── 逻辑持仓（logic_position）
├── 逻辑资金（initial_capital）
└── 逻辑盈亏（unrealized_pnl）

真实账户
├── 真实持仓
├── 真实资金
└── 真实盈亏
```

**为什么这样设计？**
- 策略可以独立测试和回测
- 策略可以跑在多个账户上
- 策略逻辑和资金管理解耦

#### 原则2：状态必须可恢复

**问题**：系统重启后，策略会"失忆"吗？

**答案**：不会！因为：
- `strategy_logic_state` 表持久化所有状态
- 系统启动时从数据库恢复状态
- 状态变更立即写回数据库

#### 原则3：LATEST_ONLY 信号消费

**问题**：策略如何处理信号？

**答案**：
- 不排队消费历史信号
- 只关注最新的 `ACTIVE` 信号
- 新信号覆盖旧信号

**示例**：
```
时间线：
10:00 - 信号1：BUY  → ACTIVE
10:05 - 信号2：SELL → ACTIVE（覆盖信号1）
10:10 - 策略读取 → 只看到信号2（SELL）
```

#### 原则4：防御性优先于聪明

**宁可拒绝，不要出错**

- 状态缺失 → 拒绝执行
- 信号为空 → 不决策
- 参数非法 → 策略不可启用
- 状态漂移 → 强制回滚

---

### 3.3 策略运行模型

#### 多维度拆分模型

```
Strategy（策略）
 └── Symbol (1..N)（交易对）
      └── 独立逻辑状态
```

**理解**：
- 一个策略可以绑定多个交易对
- **每个交易对都是独立的执行单元**
- 一个交易对异常不影响其他交易对

**示例**：
```
策略：趋势跟随策略
├── BTC-USDT（独立状态）
├── ETH-USDT（独立状态）
└── SOL-USDT（独立状态）

BTC-USDT 出错 → ETH-USDT 和 SOL-USDT 继续运行
```

---

### 3.4 策略生命周期（状态机）

```
IDLE（空闲）
  ↓
OPEN_PENDING（已决策待执行）
  ↓
OPENED（已开仓）
  ↓
PARTIAL_EXIT（部分减仓，可选）
  ↓
EXIT_PENDING（已决策待平仓）
  ↓
CLOSED（已平仓）
  ↓
IDLE（回到空闲）
```

**关键点**：
- 状态必须持久化（存到 `strategy_logic_state`）
- 状态变更必须立即写回数据库
- 系统重启后从数据库恢复状态

---

## 四、阶段1：策略实例化

### 4.1 阶段1是什么？

**阶段1 = 策略实例化阶段**

**目标**：把"数据库中的静态配置"变成"内存中可独立运行的策略实例单元"

**核心要求**：
- ✅ 不失忆（状态可恢复）
- ✅ 不乱消费信号（只建立观察关系）
- ✅ 不提前做任何交易决策

---

### 4.2 阶段1的输入与输出

#### 输入（来自阶段0）

```
strategy_definition      ← 策略定义
strategy_param          ← 策略参数
strategy_symbol         ← 交易对绑定
strategy_signal_subscription ← 信号订阅
strategy_logic_state    ← 逻辑状态（可能不存在）
```

#### 输出（阶段1的唯一产物）

```
StrategyRuntime（策略运行时）
 ├── strategy_id
 ├── decision_mode
 ├── param（参数快照）
 └── instances[]（实例列表）
      ├── trading_pair_id
      ├── logic_state（状态快照）
      └── signal_view（信号观察关系，只读）
```

**重要**：阶段1不产生任何交易意图、不写决策表

---

### 4.3 什么是"策略实例单元"？

**核心概念**：

> **一个策略 + 一个交易对 = 一个独立实例**

**实例粒度**：

| 维度 | 是否共享 |
|------|---------|
| 策略参数 | ✅ 共享（所有实例共用） |
| 信号订阅 | ✅ 共享（所有实例共用） |
| 决策模式 | ✅ 共享（所有实例共用） |
| logic_state | ❌ 每个交易对独立 |
| 信号意图消费 | ❌ 每个交易对独立 |

**示例**：
```
策略：趋势跟随策略（绑定3个交易对）

内存中创建：
├── StrategyRuntime
│   ├── param（共享）
│   └── instances[]
│       ├── Instance1（BTC-USDT，独立状态）
│       ├── Instance2（ETH-USDT，独立状态）
│       └── Instance3（SOL-USDT，独立状态）
```

---

### 4.4 实例化完整流程

#### Step 1️⃣ 加载策略定义

```sql
SELECT * FROM strategy_definition
WHERE enabled = 1;
```

**结果**：获取所有启用的策略

---

#### Step 2️⃣ 加载并绑定策略参数

```sql
SELECT * FROM strategy_param
WHERE strategy_id = ?;
```

**结果**：参数在内存中是**只读快照**

---

#### Step 3️⃣ 加载交易对，拆分实例

```sql
SELECT * FROM strategy_symbol
WHERE strategy_id = ? AND enabled = 1;
```

**结果**：为每个 `trading_pair_id` 创建一个 `StrategyInstance`

**关键**：
- 一个策略绑定N个交易对 → 创建N个实例
- 每个实例独立管理自己的状态

---

#### Step 4️⃣ 恢复或初始化 logic_state（⭐关键）

```sql
SELECT * FROM strategy_logic_state
WHERE strategy_id = ? AND trading_pair_id = ?;
```

**情况A：存在记录（正常运行过）**

```text
✔ 恢复：
- logic_position_side
- logic_position_qty
- avg_entry_price
- state_phase
- last_signal_intent_id
```

**情况B：不存在记录（第一次跑）**

```text
✔ 初始化：
- logic_position_side = FLAT
- logic_position_qty = 0
- state_phase = IDLE
- last_signal_intent_id = null
```

**并立即写回数据库**（防止中途崩溃）

**这一步解决"系统重启会失忆"问题**

---

#### Step 5️⃣ 加载信号订阅（但不消费）

```sql
SELECT * FROM strategy_signal_subscription
WHERE strategy_id = ? AND enabled = 1;
```

**内存结构**：
```text
SignalView {
  signal_config_id,
  consume_mode,
  readOnly = true
}
```

**⚠️ 阶段1只建立"观察关系"，不拉取信号**

---

### 4.5 阶段1的核心约束

#### 🚫 阶段1明确不做的事

| 项目 | 原因 |
|------|------|
| 不拉历史信号 | 防止补算污染 |
| 不生成 intent | 防止状态错乱 |
| 不判断 BUY/SELL | 决策属于阶段2 |
| 不计算资金 | 资金裁决在更下游 |

---

### 4.6 关于 LATEST_ONLY 的正确理解

#### ❌ 错误理解（要避免）

> "策略完全跟随信号，一来就用"

#### ✅ 正确理解（阶段1采用）

> **信号不排队，只维护"当前有效意图视图"**

**数据流**：
```
Signal Stream  →  Signal Intent 表
                     ↓
               Strategy 只读最新 ACTIVE
```

**阶段1只是建立这个只读视图关系，不触碰信号状态机**

---

### 4.7 阶段1的验收标准

#### ✅ 功能验收

- 系统重启后：
  - `strategy_logic_state` 正确恢复
  - 不会重复开仓
- 一个策略6个交易对：
  - 内存中是6个独立实例
- 禁用某个交易对：
  - 实例不会被创建

#### ✅ 数据验收

- `logic_state` 永远存在（1对1）
- 没有任何 `decision_record` 被写入

---

### 4.8 阶段1结束的标志

> **策略已"活着"，但还没"动手"**

**具体表现**：
- ✅ 策略在内存中存在
- ✅ 每个交易对都有独立实例
- ✅ 每个实例都有可恢复状态
- ✅ 没有任何交易行为发生

---

## 五、核心概念理解

### 5.1 逻辑状态 vs 真实状态

| 维度 | 逻辑状态 | 真实状态 |
|------|---------|---------|
| 存储位置 | `strategy_logic_state` 表 | 交易所账户 |
| 用途 | 策略决策依据 | 实际持仓 |
| 更新时机 | 策略决策后 | 订单成交后 |
| 可能不一致 | ✅ 是（正常现象） | - |

**为什么可能不一致？**
- 策略决策了，但订单还没成交
- 订单部分成交
- 订单失败

**如何处理不一致？**
- 逻辑状态用于策略决策
- 真实状态用于资金管理
- 两者解耦，由下游模块协调

---

### 5.2 信号意图 vs 策略意图

| 维度 | 信号意图（signal_intent） | 策略意图（strategy_intent_record） |
|------|-------------------------|--------------------------------|
| 来源 | 外部信号源（如TradingView） | 策略决策引擎 |
| 含义 | "信号建议做什么" | "策略决定做什么" |
| 存储表 | `signal_intent` | `strategy_intent_record` |
| 状态 | ACTIVE / CONSUMED / EXPIRED | 只写一次，不更新 |

**关系**：
```
信号意图（BUY）
    ↓
策略决策（可能跟随，也可能忽略）
    ↓
策略意图（OPEN / HOLD）
```

---

### 5.3 策略实例 vs 策略运行时

| 维度 | StrategyInstance | StrategyRuntime |
|------|-----------------|----------------|
| 粒度 | 一个交易对 | 一个策略 |
| 包含 | 单个交易对的状态和视图 | 所有交易对实例的集合 |
| 关系 | StrategyRuntime 包含多个 StrategyInstance | - |

**结构**：
```
StrategyRuntime
├── strategy_id: 1
├── decision_mode: FOLLOW_SIGNAL
├── param: {...}
└── instances: [
      StrategyInstance(trading_pair_id=101),
      StrategyInstance(trading_pair_id=102),
      StrategyInstance(trading_pair_id=103)
    ]
```

---

## 六、常见问题解答

### Q1: 为什么策略要有"逻辑状态"？

**A**: 因为策略需要"记忆"：
- 我现在是空仓还是持仓？
- 我持仓多少？
- 我是什么时候开仓的？
- 我现在的盈亏是多少？

如果没有逻辑状态，策略每次重启都会"失忆"，可能重复开仓或无法正确决策。

---

### Q2: 为什么一个策略要拆成多个实例？

**A**: 因为：
- 一个策略可能在多个交易对上运行（如BTC、ETH、SOL）
- 每个交易对的状态是独立的（BTC持仓不影响ETH）
- 一个交易对出错不影响其他交易对

**示例**：
```
策略：趋势跟随策略
├── BTC-USDT：持仓0.1，做多
├── ETH-USDT：空仓
└── SOL-USDT：持仓0.5，做空

BTC-USDT 出错 → ETH和SOL继续运行
```

---

### Q3: 阶段1为什么不消费信号？

**A**: 因为阶段1的目标是"让策略活着"，不是"让策略决策"：
- 阶段1：建立观察关系（我知道要关注哪些信号）
- 阶段2：读取信号并决策（我看到信号了，决定做什么）

**类比**：
- 阶段1 = 打开收音机（建立连接）
- 阶段2 = 听到广播并决定行动（接收信号并决策）

---

### Q4: 如果系统重启，策略状态会丢失吗？

**A**: 不会！因为：
1. 所有状态都存储在 `strategy_logic_state` 表中
2. 系统启动时（阶段1）会从数据库恢复状态
3. 如果状态不存在，会创建默认状态（IDLE）

**流程**：
```
系统重启
  ↓
阶段1启动
  ↓
查询 strategy_logic_state
  ↓
如果存在 → 恢复状态
如果不存在 → 创建默认状态（IDLE）
  ↓
策略继续运行
```

---

### Q5: LATEST_ONLY 是什么意思？

**A**: 只关注最新的有效信号，不排队消费历史信号。

**示例**：
```
时间线：
10:00 - 信号1：BUY  → ACTIVE
10:05 - 信号2：SELL → ACTIVE（覆盖信号1）
10:10 - 策略读取 → 只看到信号2（SELL）

策略不会处理信号1，因为已经被信号2覆盖了
```

**为什么这样设计？**
- 避免处理过时信号
- 简化信号管理
- 提高决策效率

---

### Q6: 策略参数中的 initial_capital 是真实资金吗？

**A**: 不是！这是**虚拟资金**，用于：
- 计算下单数量（如：10%的资金 = 0.1 * initial_capital）
- 计算策略收益曲线
- 策略内部盈亏估算

**真实资金**由下游的 Capital Controller 管理。

**示例**：
```
策略参数：initial_capital = 10000 USDT
下单比例：base_order_ratio = 0.1 (10%)

计算下单数量：
下单金额 = 10000 * 0.1 = 1000 USDT
下单数量 = 1000 / 当前价格
```

---

### Q7: 阶段1和阶段2的区别是什么？

**A**: 

| 维度 | 阶段1 | 阶段2 |
|------|------|------|
| 目标 | 让策略"活着" | 让策略"认知" |
| 输入 | 数据库配置 | 策略实例 + 信号/行情 |
| 输出 | 内存中的策略实例 | 策略决策记录 |
| 是否决策 | ❌ 不决策 | ✅ 决策 |
| 是否写库 | ✅ 写 logic_state（初始化） | ✅ 写 intent_record |
| 是否消费信号 | ❌ 不消费 | ✅ 只读最新信号 |

**一句话总结**：
- 阶段1：策略已"活着"，但还没"动手"
- 阶段2：策略已"认知"，但还没"行动"

---

## 七、快速参考

### 7.1 表关系速查

```
strategy_definition (1)
    ├── strategy_param (1:1)
    ├── strategy_symbol (1:N)
    ├── strategy_signal_subscription (1:N)
    ├── strategy_logic_state (1:N，按交易对)
    └── strategy_intent_record (1:N)

strategy_symbol (N)
    └── strategy_logic_state (1:1)
```

### 7.2 状态阶段速查

| 阶段 | 说明 | 可执行操作 |
|------|------|-----------|
| IDLE | 空闲 | 可以开仓 |
| OPEN_PENDING | 待执行 | 等待开仓确认 |
| OPENED | 已开仓 | 可以平仓、加仓、减仓 |
| EXIT_PENDING | 待平仓 | 等待平仓确认 |
| CLOSED | 已平仓 | 可以重新开仓 |

### 7.3 决策意图速查

| 意图 | 说明 | 适用阶段 |
|------|------|---------|
| OPEN | 开仓 | IDLE |
| CLOSE | 平仓 | OPENED |
| ADD | 加仓 | OPENED |
| REDUCE | 减仓 | OPENED |
| REVERSE | 反手 | OPENED |
| HOLD | 不动作 | 任何阶段 |

---

## 八、下一步学习

完成阶段0和阶段1的理解后，可以继续学习：

1. **阶段2：策略决策阶段**
   - 如何基于信号和行情生成决策
   - 决策流程和门禁机制
   - 事件驱动模型

2. **代码实现**
   - 查看 `策略阶段1开发规范与任务.md`
   - 查看实际代码实现

3. **测试和调试**
   - 如何测试策略实例化
   - 如何验证状态恢复
   - 如何调试策略问题

---

**文档版本**：v1.0  
**最后更新**：2024  
**维护者**：开发团队

---

> 💡 **提示**：本文档是新手入门指南，更多技术细节请参考：
> - `策略规划原则.md` - 完整的设计理念
> - `策略阶段1开发规范与任务.md` - 详细的开发规范
> - `策略阶段2开发规范与任务.md` - 阶段2的开发规范



