# 策略阶段2 - 条件解释执行方案

> **版本**：v1.0  
> **创建时间**：2024  
> **目标**：实现 entry_condition / exit_condition（JSON）的解释执行，满足可长期演进、可审计、可控

---

## 【1. 方案路线】

**选择：A) 结构化规则树（推荐）**

**理由**：

1. **安全性**：
   - ✅ 不执行任意代码，只解析结构化JSON
   - ✅ 白名单机制（factor key、operator都有白名单）
   - ✅ 类型安全（强类型检查，防止注入）

2. **可维护性**：
   - ✅ 清晰的AST结构，便于理解和调试
   - ✅ 易于扩展（新增factor/operator只需添加实现）
   - ✅ 代码可读性强（规则树结构直观）

3. **可审计性**：
   - ✅ 完整的hitReason（记录哪些规则命中/未命中）
   - ✅ 可回放（规则树可序列化，便于复盘）
   - ✅ 结构化输出（便于查询和分析）

4. **性能**：
   - ✅ 可缓存解析结果（JSON -> AST只需解析一次）
   - ✅ 短路求值（ANY模式找到第一个true即返回）
   - ✅ 无脚本引擎开销

**不选择B（表达式字符串）的原因**：
- ❌ 安全性风险（SpEL/JS可能执行任意代码）
- ❌ 可审计性差（难以记录具体哪些条件命中）
- ❌ 性能开销（需要解析和执行脚本）

---

## 【2. JSON 规范】

### 2.1 最小 Schema

```json
{
  "version": "1.0",           // 版本号（用于兼容性）
  "mode": "ALL|ANY",          // 组合模式
  "rules": [                  // 规则列表
    {
      "factor": "IND.RSI_14", // 因子key（白名单）
      "operator": "LT",        // 操作符（白名单）
      "value": 30,             // 比较值
      "type": "NUMBER",        // 值类型：NUMBER/STRING/BOOLEAN
      "nullable": false        // 是否允许为空（false时缺值会block）
    }
  ],
  "groups": [                 // 嵌套组（可选）
    {
      "mode": "ALL|ANY",
      "rules": [...],
      "groups": [...]          // 支持递归嵌套
    }
  ]
}
```

### 2.2 示例 JSON

**入场条件（entry_condition）**：

```json
{
  "version": "1.0",
  "mode": "ALL",
  "rules": [
    {
      "factor": "IND.RSI_14",
      "operator": "LT",
      "value": 30,
      "type": "NUMBER",
      "nullable": false
    },
    {
      "factor": "SIG.DIRECTION",
      "operator": "EQ",
      "value": "BUY",
      "type": "STRING",
      "nullable": false
    }
  ]
}
```

**出场条件（exit_condition）**：

```json
{
  "version": "1.0",
  "mode": "ANY",
  "rules": [
    {
      "factor": "PX.LAST",
      "operator": "LTE",
      "value": "STATE.STOP_LOSS_PRICE",
      "type": "NUMBER",
      "nullable": false
    },
    {
      "factor": "IND.RSI_14",
      "operator": "GT",
      "value": 70,
      "type": "NUMBER",
      "nullable": false
    }
  ],
  "groups": [
    {
      "mode": "ALL",
      "rules": [
        {
          "factor": "BAR.CLOSE",
          "operator": "GT",
          "value": "BAR.OPEN",
          "type": "NUMBER",
          "nullable": false
        },
        {
          "factor": "BAR.VOLUME",
          "operator": "GT",
          "value": 1000000,
          "type": "NUMBER",
          "nullable": false
        }
      ]
    }
  ]
}
```

### 2.3 数值类型处理

- **NUMBER**：使用 `BigDecimal` 比较（精度安全）
- **STRING**：使用 `String.equals()` 比较
- **BOOLEAN**：使用 `Boolean` 比较
- **缺失值处理**：
  - `nullable: false` → 缺值时返回 `EvaluationResult.blocked("factor缺失")`
  - `nullable: true` → 缺值时返回 `false`（不block）

---

## 【3. FactorResolver（因子系统）】

### 3.1 Factor Key 白名单

| 前缀 | 说明 | 示例 |
|------|------|------|
| `SIG.*` | 信号因子 | `SIG.DIRECTION`, `SIG.INTENT_ID` |
| `IND.*` | 指标因子 | `IND.RSI_14`, `IND.MACD`, `IND.MACD.SIGNAL` |
| `BAR.*` | K线因子 | `BAR.OPEN`, `BAR.HIGH`, `BAR.LOW`, `BAR.CLOSE`, `BAR.VOLUME` |
| `PX.*` | 价格因子 | `PX.LAST`, `PX.BID`, `PX.ASK` |
| `STATE.*` | 逻辑状态因子 | `STATE.POSITION_SIDE`, `STATE.POSITION_QTY`, `STATE.STOP_LOSS_PRICE` |

### 3.2 关键代码

```java
package com.qyl.v2trade.business.strategy.decision.logic.condition;

import com.qyl.v2trade.business.strategy.decision.context.DecisionContext;
import lombok.Builder;
import lombok.Getter;

import java.math.BigDecimal;
import java.util.Optional;

/**
 * 因子解析器接口
 */
public interface FactorResolver {
    
    /**
     * 解析因子值
     * 
     * @param factorKey 因子key（如 "IND.RSI_14"）
     * @param ctx 决策上下文
     * @return 因子值（如果不存在返回Optional.empty()）
     */
    Optional<TypedValue> resolve(String factorKey, DecisionContext ctx);
    
    /**
     * 支持的因子前缀（用于白名单校验）
     */
    String getSupportedPrefix();
}

/**
 * 类型化值
 */
@Getter
@Builder
public class TypedValue {
    private final ValueType type;
    private final BigDecimal numberValue;
    private final String stringValue;
    private final Boolean booleanValue;
    
    public enum ValueType {
        NUMBER, STRING, BOOLEAN
    }
    
    public static TypedValue ofNumber(BigDecimal value) {
        return TypedValue.builder()
            .type(ValueType.NUMBER)
            .numberValue(value)
            .build();
    }
    
    public static TypedValue ofString(String value) {
        return TypedValue.builder()
            .type(ValueType.STRING)
            .stringValue(value)
            .build();
    }
    
    public static TypedValue ofBoolean(Boolean value) {
        return TypedValue.builder()
            .type(ValueType.BOOLEAN)
            .booleanValue(value)
            .build();
    }
}

/**
 * 指标因子解析器实现
 */
@Component
public class IndicatorFactorResolver implements FactorResolver {
    
    @Override
    public String getSupportedPrefix() {
        return "IND.";
    }
    
    @Override
    public Optional<TypedValue> resolve(String factorKey, DecisionContext ctx) {
        if (!factorKey.startsWith("IND.")) {
            return Optional.empty();
        }
        
        // 提取指标代码（如 "IND.RSI_14" -> "RSI_14"）
        String indicatorCode = factorKey.substring(4);
        
        IndicatorSnapshot indicator = ctx.getIndicatorSnapshot();
        if (indicator == null || !indicator.hasValue()) {
            return Optional.empty();
        }
        
        // 主值匹配
        if (indicatorCode.equals(indicator.getIndicatorCode())) {
            return Optional.of(TypedValue.ofNumber(indicator.getValue()));
        }
        
        // 扩展值匹配（如 "IND.MACD.SIGNAL"）
        if (indicator.getExtraValues() != null) {
            BigDecimal extraValue = indicator.getExtraValues().get(indicatorCode);
            if (extraValue != null) {
                return Optional.of(TypedValue.ofNumber(extraValue));
            }
        }
        
        return Optional.empty();
    }
}

/**
 * 信号因子解析器实现
 */
@Component
public class SignalFactorResolver implements FactorResolver {
    
    @Override
    public String getSupportedPrefix() {
        return "SIG.";
    }
    
    @Override
    public Optional<TypedValue> resolve(String factorKey, DecisionContext ctx) {
        if (!factorKey.startsWith("SIG.")) {
            return Optional.empty();
        }
        
        SignalSnapshot signal = ctx.getSignalSnapshot();
        if (signal == null || !signal.isValid()) {
            return Optional.empty();
        }
        
        String field = factorKey.substring(4);
        switch (field) {
            case "DIRECTION":
                return Optional.of(TypedValue.ofString(signal.getIntentDirection()));
            case "INTENT_ID":
                return Optional.of(TypedValue.ofNumber(
                    BigDecimal.valueOf(signal.getSignalIntentId())));
            default:
                return Optional.empty();
        }
    }
}

/**
 * 价格因子解析器实现
 */
@Component
public class PriceFactorResolver implements FactorResolver {
    
    @Override
    public String getSupportedPrefix() {
        return "PX.";
    }
    
    @Override
    public Optional<TypedValue> resolve(String factorKey, DecisionContext ctx) {
        if (!factorKey.startsWith("PX.")) {
            return Optional.empty();
        }
        
        PriceSnapshot price = ctx.getPriceSnapshot();
        if (price == null || !price.isAvailable()) {
            return Optional.empty();
        }
        
        String field = factorKey.substring(3);
        switch (field) {
            case "LAST":
                return Optional.of(TypedValue.ofNumber(price.getCurrentPrice()));
            default:
                return Optional.empty();
        }
    }
}

/**
 * K线因子解析器实现
 */
@Component
public class BarFactorResolver implements FactorResolver {
    
    @Override
    public String getSupportedPrefix() {
        return "BAR.";
    }
    
    @Override
    public Optional<TypedValue> resolve(String factorKey, DecisionContext ctx) {
        if (!factorKey.startsWith("BAR.")) {
            return Optional.empty();
        }
        
        BarSnapshot bar = ctx.getBarSnapshot();
        if (bar == null) {
            return Optional.empty();
        }
        
        String field = factorKey.substring(4);
        switch (field) {
            case "OPEN":
                return Optional.of(TypedValue.ofNumber(bar.getOpen()));
            case "HIGH":
                return Optional.of(TypedValue.ofNumber(bar.getHigh()));
            case "LOW":
                return Optional.of(TypedValue.ofNumber(bar.getLow()));
            case "CLOSE":
                return Optional.of(TypedValue.ofNumber(bar.getClose()));
            case "VOLUME":
                return Optional.of(TypedValue.ofNumber(bar.getVolume()));
            default:
                return Optional.empty();
        }
    }
}

/**
 * 状态因子解析器实现
 */
@Component
public class StateFactorResolver implements FactorResolver {
    
    @Override
    public String getSupportedPrefix() {
        return "STATE.";
    }
    
    @Override
    public Optional<TypedValue> resolve(String factorKey, DecisionContext ctx) {
        if (!factorKey.startsWith("STATE.")) {
            return Optional.empty();
        }
        
        LogicStateSnapshot state = ctx.getLogicStateBefore();
        if (state == null) {
            return Optional.empty();
        }
        
        String field = factorKey.substring(6);
        switch (field) {
            case "POSITION_SIDE":
                return Optional.of(TypedValue.ofString(state.getLogicPositionSide()));
            case "POSITION_QTY":
                return Optional.of(TypedValue.ofNumber(state.getLogicPositionQty()));
            case "STOP_LOSS_PRICE":
                // 从参数计算止损价
                ParamSnapshot param = ctx.getParamSnapshot();
                if (param != null && state.getAvgEntryPrice() != null && 
                    param.getStopLossRatio() != null) {
                    BigDecimal stopLossPrice = state.getAvgEntryPrice()
                        .multiply(BigDecimal.ONE.subtract(param.getStopLossRatio()));
                    return Optional.of(TypedValue.ofNumber(stopLossPrice));
                }
                return Optional.empty();
            default:
                return Optional.empty();
        }
    }
}

/**
 * 因子解析器注册表
 */
@Component
@RequiredArgsConstructor
public class FactorResolverRegistry {
    
    private final List<FactorResolver> resolvers;
    private final Map<String, FactorResolver> resolverMap = new HashMap<>();
    
    @PostConstruct
    public void init() {
        for (FactorResolver resolver : resolvers) {
            resolverMap.put(resolver.getSupportedPrefix(), resolver);
        }
    }
    
    /**
     * 解析因子值
     */
    public Optional<TypedValue> resolve(String factorKey, DecisionContext ctx) {
        // 查找匹配的解析器
        for (Map.Entry<String, FactorResolver> entry : resolverMap.entrySet()) {
            if (factorKey.startsWith(entry.getKey())) {
                return entry.getValue().resolve(factorKey, ctx);
            }
        }
        return Optional.empty();
    }
    
    /**
     * 校验因子key是否在白名单中
     */
    public boolean isFactorKeyAllowed(String factorKey) {
        return resolverMap.keySet().stream()
            .anyMatch(factorKey::startsWith);
    }
}
```

### 3.3 取值失败策略

- **factor key不在白名单** → 抛出异常（安全性）
- **factor key在白名单但值不存在**：
  - `nullable: false` → 返回 `EvaluationResult.blocked("factor缺失")`
  - `nullable: true` → 返回 `false`（不block）

### 3.4 历史值支持

**当前版本不支持历史值（prev）**。

**原因**：
- 阶段2约束：只使用当前快照数据
- 历史值需要额外的数据存储和查询
- 可在后续版本扩展

**未来扩展方案**：
- 在 `DecisionContext` 中添加 `previousSnapshots` 字段
- `FactorResolver` 支持 `resolveWithHistory(factorKey, ctx, lookback)` 方法

---

## 【4. OperatorExecutor（算子系统）】

### 4.1 支持的 Operator

```java
package com.qyl.v2trade.business.strategy.decision.logic.condition;

/**
 * 操作符枚举
 */
public enum Operator {
    // 数值比较
    GT("大于"),
    LT("小于"),
    GTE("大于等于"),
    LTE("小于等于"),
    EQ("等于"),
    NEQ("不等于"),
    
    // 范围比较
    BETWEEN("在范围内"),
    NOT_BETWEEN("不在范围内"),
    
    // 字符串比较
    CONTAINS("包含"),
    STARTS_WITH("以...开头"),
    ENDS_WITH("以...结尾"),
    
    // 交叉（需要历史值，当前版本不支持）
    // CROSS_UP("向上穿越"),
    // CROSS_DOWN("向下穿越");
    
    private final String description;
    
    Operator(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * 从字符串解析
     */
    public static Operator fromString(String op) {
        try {
            return valueOf(op.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("不支持的操作符: " + op);
        }
    }
}
```

### 4.2 OperatorExecutor 实现

```java
package com.qyl.v2trade.business.strategy.decision.logic.condition;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;

/**
 * 操作符执行器
 */
@Slf4j
@Component
public class OperatorExecutor {
    
    /**
     * 执行比较
     * 
     * @param left 左值
     * @param operator 操作符
     * @param right 右值
     * @return 比较结果
     * @throws IllegalArgumentException 如果操作符不支持或类型不匹配
     */
    public boolean execute(TypedValue left, Operator operator, TypedValue right) {
        // 类型检查
        if (left.getType() != right.getType()) {
            // 尝试类型转换（NUMBER <-> STRING）
            if (canConvert(left, right)) {
                return executeWithConversion(left, operator, right);
            }
            throw new IllegalArgumentException(
                String.format("类型不匹配: left=%s, right=%s", left.getType(), right.getType()));
        }
        
        // 根据类型执行比较
        switch (left.getType()) {
            case NUMBER:
                return executeNumberComparison(left.getNumberValue(), operator, right.getNumberValue());
            case STRING:
                return executeStringComparison(left.getStringValue(), operator, right.getStringValue());
            case BOOLEAN:
                return executeBooleanComparison(left.getBooleanValue(), operator, right.getBooleanValue());
            default:
                throw new IllegalArgumentException("不支持的类型: " + left.getType());
        }
    }
    
    /**
     * 数值比较
     */
    private boolean executeNumberComparison(BigDecimal left, Operator operator, BigDecimal right) {
        int comparison = left.compareTo(right);
        switch (operator) {
            case GT:
                return comparison > 0;
            case LT:
                return comparison < 0;
            case GTE:
                return comparison >= 0;
            case LTE:
                return comparison <= 0;
            case EQ:
                return comparison == 0;
            case NEQ:
                return comparison != 0;
            case BETWEEN:
                // BETWEEN需要right是数组，这里简化处理
                throw new UnsupportedOperationException("BETWEEN需要特殊处理");
            default:
                throw new IllegalArgumentException("数值类型不支持的操作符: " + operator);
        }
    }
    
    /**
     * 字符串比较
     */
    private boolean executeStringComparison(String left, Operator operator, String right) {
        switch (operator) {
            case EQ:
                return left.equals(right);
            case NEQ:
                return !left.equals(right);
            case CONTAINS:
                return left.contains(right);
            case STARTS_WITH:
                return left.startsWith(right);
            case ENDS_WITH:
                return left.endsWith(right);
            default:
                throw new IllegalArgumentException("字符串类型不支持的操作符: " + operator);
        }
    }
    
    /**
     * 布尔比较
     */
    private boolean executeBooleanComparison(Boolean left, Operator operator, Boolean right) {
        switch (operator) {
            case EQ:
                return left.equals(right);
            case NEQ:
                return !left.equals(right);
            default:
                throw new IllegalArgumentException("布尔类型不支持的操作符: " + operator);
        }
    }
    
    /**
     * 类型转换（NUMBER <-> STRING）
     */
    private boolean canConvert(TypedValue left, TypedValue right) {
        return (left.getType() == TypedValue.ValueType.NUMBER && 
                right.getType() == TypedValue.ValueType.STRING) ||
               (left.getType() == TypedValue.ValueType.STRING && 
                right.getType() == TypedValue.ValueType.NUMBER);
    }
    
    private boolean executeWithConversion(TypedValue left, Operator operator, TypedValue right) {
        // 尝试将STRING转换为NUMBER
        try {
            if (left.getType() == TypedValue.ValueType.STRING) {
                BigDecimal leftNum = new BigDecimal(left.getStringValue());
                return executeNumberComparison(leftNum, operator, right.getNumberValue());
            } else {
                BigDecimal rightNum = new BigDecimal(right.getStringValue());
                return executeNumberComparison(left.getNumberValue(), operator, rightNum);
            }
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("无法转换类型: " + e.getMessage());
        }
    }
}
```

### 4.3 容错与异常策略

- **非法operator** → 抛出 `IllegalArgumentException`（安全性）
- **类型不匹配**：
  - 可转换（NUMBER <-> STRING）→ 尝试转换
  - 不可转换 → 抛出 `IllegalArgumentException`
- **值缺失** → 由 `ConditionEvaluator` 处理（返回blocked或false）

---

## 【5. ConditionEvaluator（组合与解释执行）】

### 5.1 关键代码骨架

```java
package com.qyl.v2trade.business.strategy.decision.logic.condition;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.qyl.v2trade.business.strategy.decision.context.DecisionContext;
import lombok.Builder;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * 条件树节点
 */
@Getter
@Builder
public class ConditionTree {
    private final String version;
    private final String mode;  // ALL / ANY
    private final List<ConditionRule> rules;
    private final List<ConditionTree> groups;  // 嵌套组
}

/**
 * 条件规则
 */
@Getter
@Builder
public class ConditionRule {
    private final String factor;
    private final String operator;
    private final Object value;  // 可能是数值、字符串或因子引用
    private final String type;   // NUMBER / STRING / BOOLEAN
    private final Boolean nullable;
}

/**
 * 评估结果
 */
@Getter
@Builder
public class EvaluationResult {
    private final boolean passed;
    private final boolean blocked;  // 是否因缺值被block
    private final String blockReason;
    private final HitReason hitReason;  // 命中原因（用于审计）
    
    public static EvaluationResult passed(HitReason hitReason) {
        return EvaluationResult.builder()
            .passed(true)
            .blocked(false)
            .hitReason(hitReason)
            .build();
    }
    
    public static EvaluationResult failed(HitReason hitReason) {
        return EvaluationResult.builder()
            .passed(false)
            .blocked(false)
            .hitReason(hitReason)
            .build();
    }
    
    public static EvaluationResult blocked(String reason) {
        return EvaluationResult.builder()
            .passed(false)
            .blocked(true)
            .blockReason(reason)
            .build();
    }
}

/**
 * 命中原因（用于审计）
 */
@Getter
@Builder
public class HitReason {
    private final List<RuleHit> ruleHits;  // 规则命中情况
    private final List<GroupHit> groupHits;  // 组命中情况
    
    @Getter
    @Builder
    public static class RuleHit {
        private final String factor;
        private final String operator;
        private final Object value;
        private final boolean hit;  // 是否命中
        private final String reason;  // 命中/未命中原因
    }
    
    @Getter
    @Builder
    public static class GroupHit {
        private final String mode;
        private final boolean hit;
        private final List<RuleHit> ruleHits;
    }
}

/**
 * 条件评估器（重构版）
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class ConditionEvaluator {
    
    private final FactorResolverRegistry factorResolverRegistry;
    private final OperatorExecutor operatorExecutor;
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    /**
     * 评估条件（主入口）
     */
    public EvaluationResult evaluate(DecisionContext ctx, String conditionJson) {
        try {
            // 1. 解析JSON为条件树
            ConditionTree tree = parseConditionTree(conditionJson);
            
            // 2. 评估条件树
            return evaluateTree(ctx, tree);
            
        } catch (Exception e) {
            log.error("条件评估失败: conditionJson={}", conditionJson, e);
            return EvaluationResult.blocked("条件解析失败: " + e.getMessage());
        }
    }
    
    /**
     * 解析条件树
     */
    private ConditionTree parseConditionTree(String conditionJson) throws Exception {
        @SuppressWarnings("unchecked")
        Map<String, Object> json = objectMapper.readValue(conditionJson, Map.class);
        
        // 解析规则
        List<ConditionRule> rules = new ArrayList<>();
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> rulesJson = (List<Map<String, Object>>) json.get("rules");
        if (rulesJson != null) {
            for (Map<String, Object> ruleJson : rulesJson) {
                ConditionRule rule = ConditionRule.builder()
                    .factor((String) ruleJson.get("factor"))
                    .operator((String) ruleJson.get("operator"))
                    .value(ruleJson.get("value"))
                    .type((String) ruleJson.get("type"))
                    .nullable((Boolean) ruleJson.getOrDefault("nullable", false))
                    .build();
                rules.add(rule);
            }
        }
        
        // 解析嵌套组（递归）
        List<ConditionTree> groups = new ArrayList<>();
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> groupsJson = (List<Map<String, Object>>) json.get("groups");
        if (groupsJson != null) {
            for (Map<String, Object> groupJson : groupsJson) {
                ConditionTree group = parseConditionTree(objectMapper.writeValueAsString(groupJson));
                groups.add(group);
            }
        }
        
        return ConditionTree.builder()
            .version((String) json.getOrDefault("version", "1.0"))
            .mode((String) json.getOrDefault("mode", "ALL"))
            .rules(rules)
            .groups(groups)
            .build();
    }
    
    /**
     * 评估条件树（递归）
     */
    private EvaluationResult evaluateTree(DecisionContext ctx, ConditionTree tree) {
        List<HitReason.RuleHit> ruleHits = new ArrayList<>();
        List<HitReason.GroupHit> groupHits = new ArrayList<>();
        
        // 1. 评估规则
        List<Boolean> ruleResults = new ArrayList<>();
        for (ConditionRule rule : tree.getRules()) {
            EvaluationResult ruleResult = evaluateRule(ctx, rule);
            ruleHits.add(HitReason.RuleHit.builder()
                .factor(rule.getFactor())
                .operator(rule.getOperator())
                .value(rule.getValue())
                .hit(ruleResult.isPassed())
                .reason(ruleResult.isBlocked() ? ruleResult.getBlockReason() : 
                       (ruleResult.isPassed() ? "命中" : "未命中"))
                .build());
            
            if (ruleResult.isBlocked()) {
                // 缺值且nullable=false，直接返回blocked
                return EvaluationResult.blocked(ruleResult.getBlockReason());
            }
            
            ruleResults.add(ruleResult.isPassed());
            
            // ANY模式短路：找到第一个true即返回
            if ("ANY".equals(tree.getMode()) && ruleResult.isPassed()) {
                return EvaluationResult.passed(HitReason.builder()
                    .ruleHits(ruleHits)
                    .groupHits(groupHits)
                    .build());
            }
        }
        
        // 2. 评估嵌套组
        List<Boolean> groupResults = new ArrayList<>();
        for (ConditionTree group : tree.getGroups()) {
            EvaluationResult groupResult = evaluateTree(ctx, group);
            if (groupResult.isBlocked()) {
                return groupResult;  // 组被block，直接返回
            }
            
            groupHits.add(HitReason.GroupHit.builder()
                .mode(group.getMode())
                .hit(groupResult.isPassed())
                .ruleHits(groupResult.getHitReason().getRuleHits())
                .build());
            
            groupResults.add(groupResult.isPassed());
            
            // ANY模式短路
            if ("ANY".equals(tree.getMode()) && groupResult.isPassed()) {
                return EvaluationResult.passed(HitReason.builder()
                    .ruleHits(ruleHits)
                    .groupHits(groupHits)
                    .build());
            }
        }
        
        // 3. 组合结果
        boolean passed;
        if ("ANY".equals(tree.getMode())) {
            // ANY模式：规则或组任一满足即可
            passed = ruleResults.stream().anyMatch(b -> b) || 
                    groupResults.stream().anyMatch(b -> b);
        } else {
            // ALL模式：所有规则和组都必须满足
            passed = ruleResults.stream().allMatch(b -> b) && 
                    groupResults.stream().allMatch(b -> b);
        }
        
        HitReason hitReason = HitReason.builder()
            .ruleHits(ruleHits)
            .groupHits(groupHits)
            .build();
        
        return passed ? EvaluationResult.passed(hitReason) : EvaluationResult.failed(hitReason);
    }
    
    /**
     * 评估单个规则
     */
    private EvaluationResult evaluateRule(DecisionContext ctx, ConditionRule rule) {
        // 1. 白名单校验
        if (!factorResolverRegistry.isFactorKeyAllowed(rule.getFactor())) {
            return EvaluationResult.blocked("因子key不在白名单: " + rule.getFactor());
        }
        
        // 2. 解析左值（factor）
        Optional<TypedValue> leftValueOpt = factorResolverRegistry.resolve(rule.getFactor(), ctx);
        if (leftValueOpt.isEmpty()) {
            // 值缺失
            if (Boolean.TRUE.equals(rule.getNullable())) {
                return EvaluationResult.failed(HitReason.builder()
                    .ruleHits(List.of(HitReason.RuleHit.builder()
                        .factor(rule.getFactor())
                        .operator(rule.getOperator())
                        .value(rule.getValue())
                        .hit(false)
                        .reason("因子值缺失（nullable=true）")
                        .build()))
                    .build());
            } else {
                return EvaluationResult.blocked("因子值缺失且nullable=false: " + rule.getFactor());
            }
        }
        
        // 3. 解析右值（value，可能是字面量或因子引用）
        TypedValue rightValue = resolveRightValue(ctx, rule.getValue(), rule.getType());
        if (rightValue == null) {
            return EvaluationResult.blocked("右值解析失败: " + rule.getValue());
        }
        
        // 4. 执行比较
        try {
            Operator operator = Operator.fromString(rule.getOperator());
            boolean result = operatorExecutor.execute(leftValueOpt.get(), operator, rightValue);
            
            return result ? 
                EvaluationResult.passed(HitReason.builder()
                    .ruleHits(List.of(HitReason.RuleHit.builder()
                        .factor(rule.getFactor())
                        .operator(rule.getOperator())
                        .value(rule.getValue())
                        .hit(true)
                        .reason("命中")
                        .build()))
                    .build()) :
                EvaluationResult.failed(HitReason.builder()
                    .ruleHits(List.of(HitReason.RuleHit.builder()
                        .factor(rule.getFactor())
                        .operator(rule.getOperator())
                        .value(rule.getValue())
                        .hit(false)
                        .reason("未命中")
                        .build()))
                    .build());
                    
        } catch (Exception e) {
            log.error("规则评估异常: rule={}", rule, e);
            return EvaluationResult.blocked("规则评估异常: " + e.getMessage());
        }
    }
    
    /**
     * 解析右值（支持字面量和因子引用）
     */
    private TypedValue resolveRightValue(DecisionContext ctx, Object value, String type) {
        if (value == null) {
            return null;
        }
        
        // 如果是因子引用（如 "STATE.STOP_LOSS_PRICE"）
        if (value instanceof String && ((String) value).contains(".")) {
            String valueStr = (String) value;
            if (factorResolverRegistry.isFactorKeyAllowed(valueStr)) {
                Optional<TypedValue> factorValue = factorResolverRegistry.resolve(valueStr, ctx);
                return factorValue.orElse(null);
            }
        }
        
        // 字面量
        switch (type) {
            case "NUMBER":
                if (value instanceof Number) {
                    return TypedValue.ofNumber(BigDecimal.valueOf(((Number) value).doubleValue()));
                } else if (value instanceof String) {
                    try {
                        return TypedValue.ofNumber(new BigDecimal((String) value));
                    } catch (NumberFormatException e) {
                        return null;
                    }
                }
                break;
            case "STRING":
                return TypedValue.ofString(String.valueOf(value));
            case "BOOLEAN":
                if (value instanceof Boolean) {
                    return TypedValue.ofBoolean((Boolean) value);
                } else if (value instanceof String) {
                    return TypedValue.ofBoolean(Boolean.parseBoolean((String) value));
                }
                break;
        }
        
        return null;
    }
}
```

### 5.2 ALL/ANY 短路规则

- **ANY模式**：
  - 规则评估：找到第一个 `true` 立即返回 `passed`
  - 组评估：找到第一个 `passed` 的组立即返回 `passed`
  - 避免不必要的计算

- **ALL模式**：
  - 规则评估：必须评估所有规则，任一 `false` 则返回 `failed`
  - 组评估：必须评估所有组，任一 `failed` 则返回 `failed`

### 5.3 groups 嵌套策略

- **递归评估**：`evaluateTree()` 方法递归调用自身
- **结果组合**：嵌套组的结果与规则结果按 `mode` 组合
- **block传播**：嵌套组被block时，立即向上传播

### 5.4 输出内容

- **boolean**：`EvaluationResult.passed` 或 `failed`
- **hitReason**：完整的命中原因，包含：
  - 每个规则的命中情况（factor、operator、value、hit、reason）
  - 每个组的命中情况（mode、hit、ruleHits）

### 5.5 缺值处理策略

- **nullable: false** → 返回 `EvaluationResult.blocked()`，由 `GuardChain` 拦截
- **nullable: true** → 返回 `false`（不block），继续评估其他规则

---

## 【6. 与阶段2门禁 GuardChain 的衔接方式】

### 6.1 StalenessGate 在 evaluate 前执行

**流程**：

```java
// DecisionEngineImpl.executeDecision()
DecisionContext ctx = sampler.sample(instance, event);

// 1. GuardChain 先执行（包括 StalenessGate）
GuardResult guardResult = guardChain.check(ctx);
if (!guardResult.isAllowed()) {
    return;  // 被拦截，不执行策略逻辑
}

// 2. 策略逻辑执行（包括 ConditionEvaluator）
StrategyLogic logic = logicRegistry.getLogic(ctx.getStrategyType());
DecisionResult result = logic.decide(ctx);
```

**StalenessGate 的职责**：
- 校验信号时效（30秒内）
- 校验指标是否就绪（指标驱动策略必须有指标值）

### 6.2 缺少关键指标/信号的处理

**策略**：

1. **StalenessGate 拦截**（推荐）：
   - 指标驱动策略但指标值不存在 → `StalenessGate` 返回 `rejected`
   - 信号触发但信号无效 → `StalenessGate` 返回 `rejected`
   - **优点**：统一在门禁层处理，不进入策略逻辑

2. **ConditionEvaluator 返回 false**（备选）：
   - 如果 `nullable: true`，缺值时返回 `false`
   - **缺点**：需要进入策略逻辑才能判断

**当前实现**：采用策略1（StalenessGate拦截）

### 6.3 HOLD 不落库但 metrics/log 可追踪

**实现方式**：

```java
// DecisionEngineImpl.executeDecision()
DecisionResult result = logic.decide(ctx);

if (result.isActionIntent()) {
    // 动作意图：落库
    recorder.record(ctx, result);
    metrics.counter("strategy.decision.recorded", "action", result.getAction().getCode()).increment();
} else {
    // HOLD：不落库，但记录metrics/log
    log.debug("决策结果为HOLD: strategyId={}, tradingPairId={}, reason={}",
        ctx.getStrategyId(), ctx.getTradingPairId(), result.getReason().getStateChange());
    metrics.counter("strategy.decision.hold").increment();
}
```

**metrics指标**：
- `strategy.decision.hold`：HOLD次数
- `strategy.decision.recorded`：落库次数（按action分类）

---

## 【7. 验收用例】

### 用例1：RSI<30 且 BUY 信号 -> 空仓 -> OPEN

**前置条件**：
- 策略类型：INDICATOR_DRIVEN
- 当前状态：空仓（FLAT）
- 入场条件：`{"mode":"ALL","rules":[{"factor":"IND.RSI_14","operator":"LT","value":30,"type":"NUMBER","nullable":false},{"factor":"SIG.DIRECTION","operator":"EQ","value":"BUY","type":"STRING","nullable":false}]}`

**测试步骤**：
1. 发布 `IndicatorComputedEvent`（RSI_14 = 25）
2. 发布 `SignalIntentActivatedEvent`（direction = "BUY"）
3. 等待决策完成

**预期结果**：
- 1条OPEN记录
- `decision_reason` 包含：
  - `trigger.type = "INDICATOR"`
  - `decisionBasis.entryConditionMet = true`
  - `hitReason.ruleHits[0].hit = true`（RSI < 30）
  - `hitReason.ruleHits[1].hit = true`（SIG.DIRECTION = BUY）

**自动化脚本**：

```java
@Test
public void testRSIAndSignalEntry() {
    // 1. 准备数据
    StrategyInstance instance = createIndicatorDrivenInstance();
    instance.getLogicState().setLogicPositionSideEnum(LogicDirectionEnum.FLAT);
    
    // 2. 发布指标事件
    IndicatorComputedEvent indicatorEvent = new IndicatorComputedEvent(
        this, userId, tradingPairId, "RSI_14", "1.0",
        barTime, Map.of("RSI", BigDecimal.valueOf(25.0)), LocalDateTime.now()
    );
    
    // 3. 发布信号事件
    SignalIntentActivatedEvent signalEvent = new SignalIntentActivatedEvent(
        this, userId, strategyId, tradingPairId,
        signalIntentId, signalId, "BUY", LocalDateTime.now()
    );
    
    // 4. 执行决策
    decisionEngine.executeDecision(instance, indicatorEvent);
    
    // 5. 验证
    await().atMost(5, SECONDS).until(() -> {
        return intentRecordMapper.count(...) == 1;
    });
    
    StrategyIntentRecord record = intentRecordMapper.selectOne(...);
    assertThat(record.getIntentActionEnum()).isEqualTo(IntentActionEnum.OPEN);
    
    Map<String, Object> reason = parseJson(record.getDecisionReason());
    assertThat(reason)
        .extracting("decisionBasis.entryConditionMet")
        .isEqualTo(true);
}
```

### 用例2：RSI>=30 -> 不动作 -> 不落库

**前置条件**：
- 策略类型：INDICATOR_DRIVEN
- 当前状态：空仓（FLAT）
- 入场条件：`{"mode":"ALL","rules":[{"factor":"IND.RSI_14","operator":"LT","value":30,"type":"NUMBER","nullable":false}]}`

**测试步骤**：
1. 发布 `IndicatorComputedEvent`（RSI_14 = 50）
2. 等待决策完成

**预期结果**：
- 表中没有新记录（HOLD不落库）
- metrics中 `strategy.decision.hold` 增加1
- 日志中有INFO记录："决策结果为HOLD"

**自动化脚本**：

```java
@Test
public void testRSIGreaterThan30Hold() {
    int initialCount = intentRecordMapper.count(...);
    double initialHoldCount = metrics.getHoldCount();
    
    // 发布不满足条件的事件
    IndicatorComputedEvent event = new IndicatorComputedEvent(
        ..., "RSI_14", ..., Map.of("RSI", BigDecimal.valueOf(50.0))
    );
    
    decisionEngine.executeDecision(instance, event);
    
    await().atMost(5, SECONDS).until(() -> {
        return metrics.getHoldCount() > initialHoldCount;
    });
    
    // 验证没有新记录
    assertThat(intentRecordMapper.count(...)).isEqualTo(initialCount);
    
    // 验证metrics增加
    assertThat(metrics.getHoldCount()).isGreaterThan(initialHoldCount);
}
```

### 用例3：缺少 RSI 指标 -> Gate 拦截

**前置条件**：
- 策略类型：INDICATOR_DRIVEN
- 当前状态：空仓（FLAT）
- 入场条件：`{"mode":"ALL","rules":[{"factor":"IND.RSI_14","operator":"LT","value":30,"type":"NUMBER","nullable":false}]}`

**测试步骤**：
1. 发布 `IndicatorComputedEvent`（但指标值不存在）
2. 等待决策完成

**预期结果**：
- `StalenessGate` 返回 `rejected`（reason = "指标驱动策略但指标值未就绪"）
- 表中没有新记录
- 日志中有DEBUG记录："决策被门禁拦截: gate=StalenessGate"

**自动化脚本**：

```java
@Test
public void testMissingIndicatorBlocked() {
    // 创建没有指标值的上下文
    DecisionContext ctx = DecisionContext.builder()
        .strategyType("INDICATOR_DRIVEN")
        .indicatorSnapshot(null)  // 指标为空
        .build();
    
    GuardResult result = guardChain.check(ctx);
    
    assertThat(result.isAllowed()).isFalse();
    assertThat(result.getRejectedGate()).isEqualTo("StalenessGate");
    assertThat(result.getReason()).contains("指标值未就绪");
}
```

### 用例4：同一 JSON 规则重复触发 100 次 -> 只产生 1 条动作意图

**前置条件**：
- 策略类型：INDICATOR_DRIVEN
- 当前状态：空仓（FLAT）
- 入场条件：`{"mode":"ALL","rules":[{"factor":"IND.RSI_14","operator":"LT","value":30,"type":"NUMBER","nullable":false}]}`

**测试步骤**：
1. 发布 `IndicatorComputedEvent` 100次（相同indicatorCode和barTime）
2. 等待所有事件处理完成

**预期结果**：
- 只有1条OPEN记录
- `dedupKey = "INDICATOR:{strategyId}:{tradingPairId}:RSI_14:{barTime}"`
- Redis中有去重键（TTL = 1小时）

**自动化脚本**：

```java
@Test
public void testDuplicateTriggerDeduplication() {
    LocalDateTime barTime = LocalDateTime.now();
    
    // 发布100次相同事件
    for (int i = 0; i < 100; i++) {
        IndicatorComputedEvent event = new IndicatorComputedEvent(
            ..., "RSI_14", ..., barTime, Map.of("RSI", BigDecimal.valueOf(25.0)), ...
        );
        eventPublisher.publishEvent(event);
    }
    
    await().atMost(10, SECONDS).until(() -> {
        return intentRecordMapper.count(...) == 1;
    });
    
    // 验证只有1条记录
    assertThat(intentRecordMapper.count(...)).isEqualTo(1);
    
    // 验证Redis去重键存在
    String dedupKey = "INDICATOR:" + strategyId + ":" + tradingPairId + ":RSI_14:" + 
        barTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
    assertThat(redisTemplate.hasKey("strategy:decision:dedup:" + dedupKey)).isTrue();
}
```

### 用例5：类型错误（字符串与数字比较）-> 拦截/报错策略

**前置条件**：
- 策略类型：INDICATOR_DRIVEN
- 入场条件：`{"mode":"ALL","rules":[{"factor":"IND.RSI_14","operator":"LT","value":"abc","type":"NUMBER","nullable":false}]}`

**测试步骤**：
1. 发布 `IndicatorComputedEvent`（RSI_14 = 25）
2. 执行决策

**预期结果**：
- `ConditionEvaluator` 抛出 `IllegalArgumentException`（无法转换"abc"为数字）
- 返回 `EvaluationResult.blocked("规则评估异常: 无法转换类型")`
- 表中没有新记录
- 日志中有ERROR记录

**自动化脚本**：

```java
@Test
public void testTypeMismatchError() {
    // 创建类型错误的规则
    String conditionJson = "{\"mode\":\"ALL\",\"rules\":[{\"factor\":\"IND.RSI_14\",\"operator\":\"LT\",\"value\":\"abc\",\"type\":\"NUMBER\",\"nullable\":false}]}";
    
    DecisionContext ctx = createTestContext();
    EvaluationResult result = conditionEvaluator.evaluate(ctx, conditionJson);
    
    assertThat(result.isBlocked()).isTrue();
    assertThat(result.getBlockReason()).contains("无法转换类型");
}
```

### 用例6：出场条件触发（PX.last <= stopLoss）-> CLOSE

**前置条件**：
- 策略类型：INDICATOR_DRIVEN
- 当前状态：持仓LONG 0.1 BTC，avgEntryPrice = 65000
- 止损比例：2%（stopLossPrice = 63700）
- 出场条件：`{"mode":"ANY","rules":[{"factor":"PX.LAST","operator":"LTE","value":"STATE.STOP_LOSS_PRICE","type":"NUMBER","nullable":false}]}`

**测试步骤**：
1. 发布 `PriceTriggeredDecisionEvent`（triggerType = "STOP_LOSS", currentPrice = 63600）
2. 等待决策完成

**预期结果**：
- 1条CLOSE记录
- `decision_reason` 包含：
  - `trigger.type = "PRICE"`
  - `decisionBasis.exitConditionMet = true`
  - `hitReason.ruleHits[0].hit = true`（PX.LAST <= STATE.STOP_LOSS_PRICE）

**自动化脚本**：

```java
@Test
public void testStopLossExit() {
    // 1. 设置持仓状态
    logicState.setLogicPositionSideEnum(LogicDirectionEnum.LONG);
    logicState.setLogicPositionQty(BigDecimal.valueOf(0.1));
    logicState.setAvgEntryPrice(BigDecimal.valueOf(65000));
    
    // 2. 设置止损比例
    param.setStopLossRatio(BigDecimal.valueOf(0.02));
    
    // 3. 发布价格触发事件
    PriceTriggeredDecisionEvent event = new PriceTriggeredDecisionEvent(
        this, strategyId, tradingPairId,
        "STOP_LOSS", BigDecimal.valueOf(63700),
        BigDecimal.valueOf(63600), LocalDateTime.now()
    );
    
    // 4. 执行决策
    decisionEngine.executeDecision(instance, event);
    
    // 5. 验证
    await().atMost(5, SECONDS).until(() -> {
        return intentRecordMapper.count(...) == 1;
    });
    
    StrategyIntentRecord record = intentRecordMapper.selectOne(...);
    assertThat(record.getIntentActionEnum()).isEqualTo(IntentActionEnum.CLOSE);
    
    Map<String, Object> reason = parseJson(record.getDecisionReason());
    assertThat(reason)
        .extracting("decisionBasis.exitConditionMet")
        .isEqualTo(true);
}
```

---

## 【8. 风险点与改进建议】

### 8.1 如何避免"表达式注入"

**风险**：如果使用表达式字符串（SpEL/JS），可能执行任意代码。

**解决方案**（结构化规则树）：

1. **白名单机制**：
   ```java
   // FactorResolverRegistry.isFactorKeyAllowed()
   public boolean isFactorKeyAllowed(String factorKey) {
       return resolverMap.keySet().stream()
           .anyMatch(factorKey::startsWith);  // 只允许白名单前缀
   }
   ```

2. **Operator白名单**：
   ```java
   // Operator.fromString()
   public static Operator fromString(String op) {
       try {
           return valueOf(op.toUpperCase());  // 只允许枚举值
       } catch (IllegalArgumentException e) {
           throw new IllegalArgumentException("不支持的操作符: " + op);
       }
   }
   ```

3. **类型安全**：
   - 使用 `TypedValue` 强类型
   - 类型不匹配时抛出异常，不尝试执行

4. **JSON Schema校验**（可选增强）：
   ```java
   // 使用 JSON Schema 校验 JSON 格式
   JsonSchema schema = JsonSchemaFactory.getInstance().getSchema(...);
   JsonNode json = objectMapper.readTree(conditionJson);
   if (!schema.validate(json).isSuccess()) {
       throw new IllegalArgumentException("JSON格式不符合Schema");
   }
   ```

### 8.2 如何扩展新的 factor/op 而不修改大量代码

**扩展factor**：

1. **实现 FactorResolver 接口**：
   ```java
   @Component
   public class CustomFactorResolver implements FactorResolver {
       @Override
       public String getSupportedPrefix() {
           return "CUSTOM.";
       }
       
       @Override
       public Optional<TypedValue> resolve(String factorKey, DecisionContext ctx) {
           // 实现解析逻辑
       }
   }
   ```

2. **自动注册**：Spring自动扫描并注册到 `FactorResolverRegistry`

3. **无需修改其他代码**：`ConditionEvaluator` 通过 `FactorResolverRegistry` 调用，无需修改

**扩展operator**：

1. **在 Operator 枚举中添加**：
   ```java
   public enum Operator {
       // ... 现有操作符
       CUSTOM_OP("自定义操作");
   }
   ```

2. **在 OperatorExecutor 中添加实现**：
   ```java
   private boolean executeNumberComparison(BigDecimal left, Operator operator, BigDecimal right) {
       switch (operator) {
           // ... 现有case
           case CUSTOM_OP:
               return customOpLogic(left, right);
       }
   }
   ```

3. **插件化设计**（可选增强）：
   ```java
   // 使用策略模式
   public interface OperatorHandler {
       boolean handle(TypedValue left, TypedValue right);
   }
   
   @Component
   public class OperatorHandlerRegistry {
       private final Map<Operator, OperatorHandler> handlers;
       // 自动注册所有OperatorHandler实现
   }
   ```

### 8.3 JSON 版本管理

**当前方案**：

1. **版本字段**：
   ```json
   {
     "version": "1.0",
     "mode": "ALL",
     "rules": [...]
   }
   ```

2. **版本兼容策略**：
   ```java
   private ConditionTree parseConditionTree(String conditionJson) throws Exception {
       Map<String, Object> json = objectMapper.readValue(conditionJson, Map.class);
       String version = (String) json.getOrDefault("version", "1.0");
       
       switch (version) {
           case "1.0":
               return parseV1(json);
           case "2.0":
               return parseV2(json);  // 未来版本
           default:
               throw new IllegalArgumentException("不支持的版本: " + version);
       }
   }
   ```

3. **向后兼容**：
   - 旧版本JSON（无version字段）→ 默认按v1.0解析
   - 新字段可选（使用 `getOrDefault`）
   - 废弃字段忽略（不抛异常）

**改进建议**：

1. **版本迁移工具**：
   ```java
   public interface ConditionVersionMigrator {
       String migrate(String oldJson, String fromVersion, String toVersion);
   }
   ```

2. **版本校验**：
   ```java
   // 在保存策略参数时校验版本
   if (!isVersionSupported(version)) {
       throw new IllegalArgumentException("不支持的版本: " + version);
   }
   ```

### 8.4 性能：一次 evaluate 的复杂度

**当前复杂度**：

- **解析JSON**：O(n)，n = JSON大小（可缓存）
- **评估规则**：O(m)，m = 规则数量
- **评估组**：O(g × m)，g = 组数量（递归）
- **总复杂度**：O(n + m + g × m)

**优化方案**：

1. **缓存解析结果**：
   ```java
   @Component
   public class ConditionTreeCache {
       private final Cache<String, ConditionTree> cache = Caffeine.newBuilder()
           .maximumSize(1000)
           .expireAfterWrite(1, TimeUnit.HOURS)
           .build();
       
       public ConditionTree getOrParse(String conditionJson) {
           return cache.get(conditionJson, this::parseConditionTree);
       }
   }
   ```

2. **短路求值**：
   - ANY模式：找到第一个true立即返回
   - ALL模式：找到第一个false立即返回

3. **并行评估**（可选，适用于大量规则）：
   ```java
   // 对于大量规则，可以并行评估
   List<EvaluationResult> results = rules.parallelStream()
       .map(rule -> evaluateRule(ctx, rule))
       .collect(Collectors.toList());
   ```

4. **预编译**（可选增强）：
   ```java
   // 将ConditionTree编译为更高效的执行计划
   public interface ExecutionPlan {
       EvaluationResult execute(DecisionContext ctx);
   }
   ```

**性能目标**：
- 单次evaluate耗时 < 10ms（P95）
- 支持缓存后，重复evaluate < 1ms

---

## 总结

### 核心设计原则

1. **安全性**：白名单机制，不执行任意代码
2. **可维护性**：插件化设计，易于扩展
3. **可审计性**：完整的hitReason，便于回放
4. **可控性**：缺值处理策略明确，block机制清晰

### 实现状态

- ✅ 结构化规则树（AST）
- ✅ FactorResolver系统（5种因子类型）
- ✅ OperatorExecutor（8种操作符）
- ✅ ConditionEvaluator（支持ALL/ANY和嵌套组）
- ✅ hitReason输出（完整审计信息）
- ✅ 与GuardChain衔接
- ✅ 版本管理（v1.0）

### 后续优化方向

1. **P1**：支持CROSS_UP/CROSS_DOWN（需要历史值）
2. **P1**：支持BETWEEN操作符
3. **P2**：JSON Schema校验
4. **P2**：条件树缓存
5. **P2**：版本迁移工具

---

**文档版本**：v1.0  
**最后更新**：2024  
**维护者**：V2-Trade 架构团队