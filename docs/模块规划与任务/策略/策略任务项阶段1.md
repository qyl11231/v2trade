非常好，这一步**正是整个系统从「配置态」进入「运行态」的分水岭**。
我会**只讲清楚“阶段 1：策略实例化”这一段**，不提前引入执行、下单、风控，确保可落地、可开发、可验收。

---

# 阶段 1：策略实例化阶段（Strategy Instantiation Phase）

> **目标一句话版**
> 把「数据库中的静态配置」变成「内存中可独立运行的策略实例单元」，并且做到：
>
> * 不失忆
> * 不乱消费信号
> * 不提前做任何交易决策

---

## 一、阶段 1 的输入与输出边界（先定清楚）

### 🔹 输入（来自阶段 0 的成果）

来自你已经冻结的表结构：

* `strategy_definition`
* `strategy_param`
* `strategy_symbol`
* `strategy_signal_subscription`
* `strategy_logic_state`（可能不存在，需要补齐）

> 注意：**阶段 1 不读 execution / decision_record**

---

### 🔹 输出（阶段 1 的唯一产物）

在**内存中生成一组「策略实例单元」**

```text
StrategyRuntime
 ├── strategy_id
 ├── decision_mode
 ├── param
 ├── instances[]
        ├── trading_pair_id
        ├── logic_state (快照)
        ├── signal_view (只读最新意图)
```

👉 **阶段 1 不产生任何交易意图、不写决策表**

---

## 二、什么是「策略实例单元」？

你现在的设计已经隐含了这个答案：

> **一个策略 + 一个交易对 = 一个独立实例**

### 实例粒度（非常重要）

| 维度          | 是否共享      |
| ----------- | --------- |
| 策略参数        | ✅ 共享      |
| 信号订阅        | ✅ 共享      |
| 决策模式        | ✅ 共享      |
| logic_state | ❌ 每个交易对独立 |
| 信号意图消费      | ❌ 每个交易对独立 |

👉 你之前提到的

> “一个策略可能跑 6 个交易对”

**在阶段 1 就被拆成 6 个实例**

---

## 三、实例化的完整流程（可直接转成代码）

### Step 1️⃣ 加载策略定义

```sql
SELECT * FROM strategy_definition
WHERE enabled = 1;
```

构建内存对象：

```ts
StrategyRuntime {
  strategyId,
  decisionMode,
  strategyType
}
```

---

### Step 2️⃣ 加载并绑定策略参数

```sql
SELECT * FROM strategy_param
WHERE strategy_id = ?
```

> 参数在内存中是 **只读快照**

```ts
runtime.param = StrategyParam
```

---

### Step 3️⃣ 加载交易对，拆分实例

```sql
SELECT * FROM strategy_symbol
WHERE strategy_id = ? AND enabled = 1;
```

对每一个 `trading_pair_id`：

```ts
new StrategyInstance(strategy_id, trading_pair_id)
```

---

### Step 4️⃣ 恢复或初始化 logic_state（关键）

```sql
SELECT * FROM strategy_logic_state
WHERE strategy_id = ? AND trading_pair_id = ?
```

#### 情况 A：存在记录（正常运行过）

```text
✔ 恢复：
- logic_position_side
- qty
- avg_entry_price
- phase
- last_signal_intent_id
```

#### 情况 B：不存在记录（第一次跑）

```text
✔ 初始化：
- logic_position_side = FLAT
- qty = 0
- phase = IDLE
```

并立即 **写回 DB**（防止中途崩）

👉 这一步解决你之前评审指出的
**「系统重启会失忆」问题**

---

### Step 5️⃣ 加载信号订阅（但不消费）

```sql
SELECT * FROM strategy_signal_subscription
WHERE strategy_id = ? AND enabled = 1;
```

内存结构示意：

```ts
SignalView {
  signal_config_id,
  consume_mode,
  decision_mode
}
```

⚠️ **阶段 1 只建立“观察关系”，不拉取信号**

---

## 四、阶段 1 的核心约束（防复杂度爆炸）

### 🚫 阶段 1 明确不做的事

| 项目           | 原因       |
| ------------ | -------- |
| 不拉历史信号       | 防止补算污染   |
| 不生成 intent   | 防止状态错乱   |
| 不判断 BUY/SELL | 决策属于阶段 2 |
| 不计算资金        | 资金裁决在更下游 |

---

## 五、你提到的歧义点，在阶段 1 如何处理

### 关于 `consume_mode = LATEST_ONLY`

你现在区分得非常对：

### ❌ 错误理解（要避免）

> “策略完全跟随信号，一来就用”

### ✅ 正确理解（阶段 1 采用）

> **信号不排队，只维护“当前有效意图视图”**

也就是说：

```text
Signal Stream  →  Signal Intent 表
                     ↓
               Strategy 只读最新 ACTIVE
```

👉 阶段 1 只是**建立这个只读视图关系**
👉 **不触碰信号状态机**

---

## 六、阶段 1 的验收标准（非常重要）

你可以直接用这个做评审 checklist：

### ✅ 功能验收

* 系统重启后：

  * strategy_logic_state 正确恢复
  * 不会重复开仓
* 一个策略 6 个交易对：

  * 内存中是 6 个独立实例
* 禁用某个交易对：

  * 实例不会被创建

### ✅ 数据验收

* logic_state 永远存在（1 对 1）
* 没有任何 decision_record 被写入

---

## 七、阶段 1 与下一阶段的承接关系

| 当前阶段  | 下一阶段  |
| ----- | ----- |
| 实例化完成 | 信号触达  |
| 状态可恢复 | 意图生成  |
| 无副作用  | 可安全推进 |

👉 **阶段 1 结束的唯一标志：**

> **策略已“活着”，但还没“动手”**

---

## 最重要的一句话总结

> **阶段 1 不是做交易，而是“让策略记得自己是谁、在哪、现在是什么状态”**

你现在这个拆法：

* 是 **产品经理视角正确**
* 是 **工程师能实现**
* 是 **量化系统能长期维护**

---

如果你愿意，下一步我可以：

* 直接展开 **阶段 2：信号触达 & intent 生成**
* 或者把 **阶段 1 转成接口清单 + 伪代码**

你来定。
