我把整个策略模块严格拆成 6 个阶段，每个阶段：

有 明确输入表

有 明确输出表

有 明确“这个阶段只做什么、不做什么”

阶段 0：策略配置阶段（静态配置期）

目的：把“策略这个东西”完整地配置好，但不运行

涉及表

strategy_definition

strategy_param

strategy_symbol

strategy_signal_subscription

这个阶段做什么

创建策略（是什么策略）

设置策略参数（怎么算、怎么止盈止损）

绑定交易对（跑哪几个 symbol）

订阅信号源（监听哪些 signal_config）

这个阶段不做什么

❌ 不接收任何信号
❌ 不产生任何交易意图
❌ 不创建 logic_state

📌 这是纯配置阶段，前端 + 后端 CRUD 即可完成

阶段 1：策略实例化阶段（启动期）

目的：把“配置好的策略”变成“可运行的策略实例”

涉及表

strategy_definition

strategy_symbol

👉 初始化 strategy_logic_state

这个阶段做什么

遍历 strategy_symbol

为每个 (strategy_id + trading_pair_id)：

创建一条 strategy_logic_state

初始状态：

logic_position_side = FLAT

state_phase = IDLE

logic_position_qty = 0

这个阶段不做什么

❌ 不读取信号
❌ 不判断策略条件
❌ 不写 intent / decision

📌 这是“策略开始运行前的准备动作”，只发生一次

阶段 2：信号接收 → 意图生成阶段（信号层）

目的：把外部信号变成“策略可理解的意图”

涉及表

strategy_signal_subscription

signal_intent

这个阶段做什么

外部信号到达（TV / API）

找到订阅该信号的策略

根据策略 & 交易对：

创建一条新的 signal_intent

标记为 ACTIVE

同时将旧的 ACTIVE 意图置为 EXPIRED

这个阶段不做什么

❌ 不读取 strategy_logic_state
❌ 不判断是否持仓
❌ 不判断是否要交易

📌 这一层只做“信号语义转换”，不做任何交易判断

阶段 3：策略评估阶段（核心决策期）

目的：判断“当前这个意图，我要不要赌一把”

涉及表

signal_intent

strategy_logic_state

strategy_param

strategy_symbol

这个阶段做什么

对 每一个 ACTIVE 的 signal_intent：

读取对应的 strategy_logic_state

判断当前策略所处阶段（IDLE / OPENED / EXIT_PENDING）

结合：

入场条件（entry_condition）

退出条件（exit_condition）

当前逻辑持仓状态

得出一个策略层面的判断结果：

开

平

加

减

反手

或 什么都不做

这个阶段不做什么

❌ 不校验账户资金
❌ 不校验风控
❌ 不下真实订单

📌 这是你强调的核心思想：
策略只决定“我赌不赌”，不关心能不能赌

阶段 4：决策落库阶段（决策固化期）

目的：把“刚才的判断”变成一个不可变记录

涉及表

strategy_intent_record

strategy_logic_state

这个阶段做什么

如果策略决定有动作：

写一条 strategy_intent_record

更新 strategy_logic_state：

修改 state_phase

更新 logic_position_qty

关联 last_signal_intent_id

同时将对应的 signal_intent 标记为：

CONSUMED 或 IGNORED

这个阶段不做什么

❌ 不和交易所交互
❌ 不关心是否成交

📌 到这里，策略模块的责任已经结束

阶段 5：下游交付阶段（模块边界）

目的：把“策略决定”交给下游系统

涉及表

strategy_intent_record

这个阶段做什么

将决策结果：

推送 MQ

或提供接口给执行 / 风控 / 资金模块

这个阶段不做什么

❌ 不回写策略状态
❌ 不监听执行结果

📌 策略模块在这里“交棒”，彻底解耦