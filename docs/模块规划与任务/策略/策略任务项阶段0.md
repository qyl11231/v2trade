
阶段 0：策略配置阶段（Static Configuration Phase）

一句话目标
把“一个策略”完整、确定、可运行地描述清楚，但不运行、不接收信号、不产生任何交易行为。

一、阶段 0 的边界（必须先冻结）
这个阶段必须完成

策略“是什么”

策略“怎么算”

策略“跑哪些交易对”

策略“监听哪些信号”

这个阶段严格禁止

❌ 创建 signal_intent
❌ 创建 strategy_logic_state
❌ 任何交易判断
❌ 任何历史回放 / 回测

📌 如果有人在这个阶段做了上述事情 = 设计违规

二、阶段 0 的输入 / 输出
输入（来自用户）

用户在后台创建 / 编辑策略

输出（落库结果）

strategy_definition

strategy_param

strategy_symbol

strategy_signal_subscription

三、阶段 0 的子阶段拆分（开发可直接按这个拆）

我把阶段 0 拆成 4 个顺序子阶段，每个子阶段都可以独立开发、独立验收。

0.1 策略基础信息配置
对应表

strategy_definition

做什么

创建一条策略定义

确定：

策略名称

策略类型（SIGNAL / INDICATOR / HYBRID）

是否启用

核心校验规则（必须有）

strategy_name 在用户维度唯一

strategy_type 决定后续哪些配置必填：

SIGNAL_DRIVEN → 必须配置信号订阅

INDICATOR_DRIVEN → 可以没有信号订阅

HYBRID → 两者都可

不允许发生的事

❌ 自动创建参数
❌ 自动绑定交易对

📌 这里只是“定义”，不是“准备运行”

0.2 策略参数配置（决策规则）
对应表

strategy_param

做什么

为策略配置完整的一组决策参数

包括：

初始虚拟资金

单次下单比例

入场条件（JSON）

退出条件（JSON）

必须满足的结构性约束

strategy_id 唯一（1 策略 = 1 参数集）

entry_condition 和 exit_condition：

必须是结构化 JSON

只描述条件，不描述动作

参数层的“红线”

❌ 不允许出现交易所字段
❌ 不允许出现账户 / API Key
❌ 不允许出现风控字段

📌 这是策略的大脑，但它不看世界

0.3 策略运行交易对配置
对应表

strategy_symbol

做什么

指定该策略要运行在哪些交易对上

每个交易对都是一个独立的策略执行单元

强制规则

(strategy_id, trading_pair_id) 唯一

enabled = 0 时：

不生成 state

不接收该交易对的信号

隐含设计意义

一个策略跑 6 个交易对 ≠ 一个大策略

而是 6 个并行、互不干扰的逻辑实例

📌 这是后面所有 state / intent 的维度基础

0.4 信号订阅配置（信号路由）
对应表

strategy_signal_subscription

做什么

明确：

策略监听哪些信号配置

信号如何被消费（目前只支持 LATEST_ONLY）

关键约束

一个策略可以订阅多个 signal_config

同一个 signal_config 可以被多个策略订阅

consume_mode = LATEST_ONLY 的真实含义：

信号不会排队，只维护“当前有效意图”

不做什么

❌ 不在这里创建 signal_intent
❌ 不处理信号顺序

📌 这是“路由规则”，不是“信号处理”

四、阶段 0 的完成判定（验收标准）

以下 4 条同时满足，阶段 0 才算完成

strategy_definition 存在且 enabled

strategy_param 完整且合法

至少 1 条 strategy_symbol enabled

如果是 SIGNAL / HYBRID：

至少 1 条 strategy_signal_subscription

未满足任意一条：

策略状态 = CONFIG_INCOMPLETE

禁止进入阶段 1

五、阶段 0 与阶段 1 的衔接点（只此一个）

阶段 0 不主动触发任何事情

只有当：

策略 enabled = 1

且通过完整性校验

➡️ 系统或用户“启动策略”
➡️ 才进入 阶段 1：策略实例化阶段

六、为什么这个阶段这样设计是“可落地”的？

前端：纯表单 / JSON 编辑

后端：CRUD + 校验

没有异步

没有状态机

没有并发问题

📌 这是整个系统最安全、最便宜、最稳定的一层




阶段 0 的唯一职责（裁决级定义）

阶段 0 不做交易判断，不做资金判断，不做风控

它只做三件事：

接收外部 / 内部信号

统一规范为 signal_intent

保证策略只看到“当前唯一有效意图”

输出是：

signal_intent (ACTIVE | EXPIRED | IGNORED)

二、阶段 0 的输入 & 输出边界（冻结）
🔽 输入

外部信号源（TV、脚本策略、第三方）

内部信号模块

signal_config 过滤后的结果

🔼 输出

每个：

(strategy_id, trading_pair_id, signal_config_id)


最多只有一条 ACTIVE 的 signal_intent

三、核心裁决规则（最终版，逐条冻结）
规则 1️⃣：信号不排队（LATEST_ONLY）

系统永远只维护“当前有效意图”

新信号到达 → 覆盖旧信号

场景	结果
新 BUY	旧 BUY → EXPIRED
新 SELL	旧 BUY → EXPIRED
新 BUY	旧 SELL → EXPIRED

📌 不判断是否能交易、不判断是否合理

规则 2️⃣：意图 ≠ 指令（非常重要）
层级	含义
signal_intent	市场/信号想让我干什么
strategy_intent_record	我决定做什么

阶段 0 只产生“想法”，不产生“行动”

规则 3️⃣：信号方向是“抽象语义”
intent_direction:
BUY      表示 看多 / 做多意图
SELL     表示 看空 / 平多 / 反向
FLAT     表示 无仓 / 清仓意图
REVERSE  表示 明确反向


⚠️ 阶段 0 不解释：

BUY 是开仓还是加仓

SELL 是平仓还是反手

规则 4️⃣：与策略持仓状态完全解耦

阶段 0 不读取 strategy_logic_state

也就是说：

策略是多单 → 来 SELL → 也只是一个 SELL 意图

策略是空仓 → 来 SELL → 也只是 SELL 意图

📌 是否“匹配 / 失配”，留给阶段 1

规则 5️⃣：意图生命周期（冻结）
ACTIVE   当前唯一有效意图
CONSUMED 已被策略引用（不代表成交）
EXPIRED  被新意图覆盖
IGNORED  被策略明确丢弃


状态变化只有这几种：

ACTIVE → EXPIRED   (新信号覆盖)
ACTIVE → CONSUMED  (策略读取并决策)
ACTIVE → IGNORED   (策略判断无效)

规则 6️⃣：意图与策略的绑定方式
signal_intent:
(strategy_id, trading_pair_id)


意图是“策略维度”的，不是“全局维度”

这样可以保证：

同一个信号源

被多个策略订阅

各自产生独立意图（互不干扰）

四、阶段 0 不允许做的事情（硬性禁止）

🚫 判断是否开仓
🚫 判断是否平仓
🚫 判断是否反手
🚫 判断仓位方向是否匹配
🚫 判断止盈止损
🚫 判断资金是否足够

谁越界，谁设计错了

五、阶段 0 的数据写入清单（冻结）
✅ 会写的表
表	行为
signal_intent	新建 / 覆盖 / 过期
（可选）signal_raw_log	原始信号留档
❌ 不会写的表

strategy_logic_state

strategy_intent_record

execution / order 表

六、阶段 0 的完整时序（文本版）
[Signal Arrives]
      ↓
[signal_config 过滤]
      ↓
[查找是否存在 ACTIVE intent]
      ↓
[存在 → 标记为 EXPIRED]
      ↓
[写入新 signal_intent (ACTIVE)]


到此结束。

七、你之前提到的“信号扰乱”问题，现在如何解决？

你描述的这个问题：

信号与当前策略持仓方向长期错位，导致后续信号语义被误解

答案是：

阶段 0 不负责解决这个问题

它只是保证：

意图始终是“最新的”

旧意图一定失效

策略永远只面对一个“当前想法”

真正解决发生在：

阶段 1：Strategy Decision Engine


那里才允许：

判断“失配意图是否暂存”

判断“是否等待下一条反向确认”

判断“忽略还是延迟消费”

八、阶段 0 冻结检查表（如果全是 YES 就能开发）

 没有策略逻辑

 没有仓位判断

 没有资金判断

 信号不排队

 最新意图唯一

 状态可恢复

 数据结构简单